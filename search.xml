<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub+JSDelivr+PicGo+Typora搭建个人图床</title>
    <url>/2022/02/10/GitHub+JSDelivr+PicGo+Typora%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h1 id="0-初衷"><a href="#0-初衷" class="headerlink" title="0. 初衷"></a>0. 初衷</h1><blockquote>
<p>平时写文章，经常需要插入图片，免不了需要使用图床工具把本地图片转换成链接。市面上的图床工具非常多，但很多都需要收费，有些免费的也存在着不稳定的风险。<span id="more"></span>而 GitHub 作为全球最大的“同性交友网站”，不仅稳定性高，而且简单易用，关键还可以免费白嫖！下面教大家如何更好地利用 GitHub 搭建图床。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164911.png" alt="image-20220208202732428" style="zoom: 67%;" />

<h1 id="1-创建-GitHub-仓库"><a href="#1-创建-GitHub-仓库" class="headerlink" title="1. 创建 GitHub 仓库"></a>1. 创建 GitHub 仓库</h1><p>注册&#x2F;登录自己的 GitHub，创建一个新的名字任意的<strong>公开</strong>仓库。然后上传图片到仓库中，这里我直接使用浏览器端上传的，也可以使用 Git 进行上传。</p>
<ul>
<li>在创建的仓库中点击<code>Upload files</code>。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164912.png" alt="image-20210903190649347" style="zoom: 110%;" />

<ul>
<li><p>选择上传的图片，然后提交。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164913.png" alt="image-20220208204506190" style="zoom: 67%;" />
</li>
<li><p>提交之后，就可以在浏览器通过地址<code>https://raw.githubusercontent.com/你的用户名/你的仓库名/main/文件路径</code>来访问所上传的图片。</p>
<p>比如：<em><a href="https://raw.githubusercontent.com/SniperCoding/pictures1/main/avatar.jpg">https://raw.githubusercontent.com/SniperCoding/pictures1/main/avatar.jpg</a></em></p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164914.png" alt="image-20220208210418418" style="zoom: 67%;" />
</li>
<li><p>之后在博客中插入图片的时候，使用此链接即可。</p>
</li>
</ul>
<h1 id="2-使用-jsDelivr-进行-CDN-加速"><a href="#2-使用-jsDelivr-进行-CDN-加速" class="headerlink" title="2. 使用 jsDelivr 进行 CDN 加速"></a>2. 使用 jsDelivr 进行 CDN 加速</h1><p>前面已经利用 GitHub 仓库实现了图床功能，但是大家都知道，GitHub 在国内访问很慢，甚至经常打不开，那么我们的图片就存在加载速度慢的问题，怎么办呢？<strong>jsDelivr</strong> 可以解决此问题，显著提高图片访问的响应速度，并且开源免费！其官网为：<a href="https://www.jsdelivr.com/">jsDelivr - A free, fast, and reliable CDN for open source</a>。</p>
<p>使用方法也非常的简单，直接在浏览器通过地址<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code>就可以访问 GitHub 上的图片，并且响应速度非常快！其中@发布的版本号可以直接省略，默认加载最新版本，即直接可以简写为<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名/文件路径</code></p>
<p>比如：<em><a href="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/avatar.jpg">https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/avatar.jpg</a></em></p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164750.png" alt="image-20220208210418418" style="zoom: 67%;" />

<h1 id="3-使用PicGo上传图片"><a href="#3-使用PicGo上传图片" class="headerlink" title="3. 使用PicGo上传图片"></a>3. 使用PicGo上传图片</h1><p>前面实现了 GitHub 仓库作为图床，jsDelivr 对图片进行加速。但是每次我们都需要使用 Git 工具或者在 GitHub 仓库中进行上传图片，并且要自己拼接图片地址，非常麻烦，有没有更快速更简洁的方式呢？此时神器 <strong>PicGo</strong> 就派上了用场，同样开源免费！</p>
<p>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具，支持多个图床进行使用，其中当然包括我们现在使用的 GitHub 图床了，它同时支持 Windows、macOS、Linux平台，详情可见：<a href="https://github.com/Molunerfinn/PicGo">Molunerfinn&#x2F;PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder (github.com)</a></p>
<p>这里以 Windows 为例，说明 PicGo 的使用方法。</p>
<ul>
<li><p>下载并安装 PicGo，<a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.2.2/PicGo-Setup-2.2.2.exe">https://github.com/Molunerfinn/PicGo/releases/download/v2.2.2/PicGo-Setup-2.2.2.exe</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/20220324164915.png" alt="image-20210903201908609"></p>
</li>
<li><p>打开 PicGo 软件，找到<code>图床设置</code>中的<code>GitHub图床</code>，填写相关信息。</p>
<ul>
<li><p><strong>设定仓库名【必填】</strong>：填写<code>你的用户名/你的仓库名</code>，比如我的 SniperCoding&#x2F;pictures1</p>
</li>
<li><p><strong>设定分支名【必填】</strong>：填写<code>main</code></p>
</li>
<li><p><strong>设定Token【必填】</strong>：在Github主页点击自己头像后，依次选择【Settings】-&gt;【Developer settings】-&gt;【Personal access tokens】-&gt;【Generate new token】，填写Note描述（随便），设置过期时间Expiration为永不过期No expiration，设定勾选【repo】，点击下方的【Generate token】生成一个Token，将Token复制到 PicGo 中。</p>
</li>
<li><p>指定存储路径【选填】：可不填。</p>
</li>
<li><p><strong>设定自定义域名【选填】</strong>：图片上传后，PicGo 会按照【自定义域名+上传的图片名】的方式生成访问链接，放到剪贴板上，因为我们要使用 jsDeliver 进行加速，因而这里设置为<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名</code>，比如我设置为<strong><a href="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1">https://cdn.jsdelivr.net/gh/SniperCoding/pictures1</a></strong></p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164916.png" alt="image-20220208221048599" style="zoom: 67%;" />
</li>
<li><p>接着就可以在<code>上传区</code>，将自己的图片上传，甚至可以直接将剪切板的截图上传，上传成功后会直接将相应链接复制到剪切板中，我们就可以直接复制到博客（MarkDown 编辑器）中。</p>
</li>
<li><p>在<code>PicGo设置中</code>，可以自定义一些设置，比如上传前重命名、时间戳重命名等，自行设置。</p>
</li>
</ul>
<h1 id="4-Typora-配置-PicGo-上传"><a href="#4-Typora-配置-PicGo-上传" class="headerlink" title="4. Typora 配置 PicGo 上传"></a>4. Typora 配置 PicGo 上传</h1><p>前面使用了 PicGo 工具快速上传图片并获取图片 URL 链接，方便了很多，但是每次都要先在 PicGo 中进行上传，然后将剪切板中链接复制到 MarkDown 编辑器中，有没有更优雅简便的方式，可以将两步合二为一呢？答案是<strong>Typera+PicGo</strong>。</p>
<p>Typera 是一款轻便简洁的 Markdown 编辑器，可以即时渲染，并且完全免费，推荐大家用此软件进行写作，其官网为：<a href="https://www.typora.io/">Typora — a markdown editor, markdown reader.</a></p>
<p>下面介绍 Typora 结合 PicGo 实现上传功能。</p>
<ul>
<li><p>下载 Typora，网址<a href="https://www.typora.io/#windows">Typora — a markdown editor, markdown reader.</a></p>
</li>
<li><p>打开 PicGo，在<code>PicGo设置</code>中，点击【设置 Server 】，将监听端口修改为：36677</p>
</li>
<li><p>打开 Typera，点击【文件】 -&gt; 【偏好设置】-&gt; 【图像】，然后进行如下配置，其中 PicGo 路径是你的 PicGo 的安装路径。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324164917.png" style="zoom: 67%;" />


</li>
<li><p>在 Typera 中书写文章，插入图片（也可以直接将截图复制）时会自动将图片进行上传，并显示在文章中，非常的方便。</p>
</li>
</ul>
<p>以上就是使用 <code>GitHub</code> + <code>jsDelivr</code> + <code>PicGo</code> + <code>TyPora</code> 搭建免费稳定图床的全过程，希望对你有所帮助！</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建个人博客</title>
    <url>/2022/02/10/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="0-初衷"><a href="#0-初衷" class="headerlink" title="0. 初衷"></a>0. 初衷</h1><blockquote>
<p>将所学知识点记录在博客上是一个很好的习惯。一方面，可以加深自己对技术点的理解，同时方便以后复习回顾；另一方面，可以将自己的见解分享出去，帮助更多的人，更好的发挥开源精神。</p>
<span id="more"></span>

<p>目前存在许许多多的博客平台，但是很多平台都比较乱，甚至有很多广告，而且有些博客平台也不支持自定义样式。</p>
<p>如果想要有一个只属于自己的博客，并且页面可以自定义为所喜欢的样式，同时还可以免费白嫖，那该多好 啊！而 <strong>GitHub + Hexo</strong> 就可以实现这些！</p>
</blockquote>
<h1 id="1-前置环境"><a href="#1-前置环境" class="headerlink" title="1. 前置环境"></a>1. 前置环境</h1><p>使用 GitHub + Hexo 搭建环境之前，需要提前做以下准备：</p>
<ul>
<li><p>注册 GitHub 账号，官网：<a href="https://github.com/">https://github.com/</a></p>
</li>
<li><p>安装 Git，官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>安装较为简单，基本流程：下载安装包—-&gt;双击安装包后一路 Next—&gt;cmd 窗口使用 git –version 验证安装是否成功，之后需要做一些初始化设置，比如用户名和邮箱，并于自己的GitHub进行关联，Git学习教程可见<a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></p>
</li>
<li><p>安装 Node.js，官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
<p>安装较为简单，基本流程：下载安装包—-&gt;双击安装包后一路 Next —&gt; cmd 窗口分别输入 node -v 和 npm -v 验证安装是否成功。</p>
</li>
</ul>
<h1 id="2-安装-Hexo"><a href="#2-安装-Hexo" class="headerlink" title="2. 安装 Hexo"></a>2. 安装 Hexo</h1><ul>
<li><p>打开 cmd 命令行窗口，输入命令：<code>npm install -g hexo-cli</code> 进行安装。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165047.png" style="zoom: 55%;" />
</li>
<li><p>输入 <code>hexo -v</code>，出现版本号，即安装成功！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165048.png" style="zoom:51%;" /></li>
</ul>
<h1 id="3-本地部署-Hexo"><a href="#3-本地部署-Hexo" class="headerlink" title="3. 本地部署 Hexo"></a>3. 本地部署 Hexo</h1><p>安装完Hexo后，接下来在本地进行部署，部署完成后，Hexo服务器会运行在本地的4000端口上，当我们输入<a><a href="http://localhost:4000/">http://localhost:4000/</a></a> 时就可以在浏览器中看到自己的博客网站了！具体步骤如下：</p>
<ul>
<li><p>在任意地方（比如在D盘）新建一个文件夹 Blog（以后发布的文章、主题均在此文件夹中，也可以自定义为其他名称），进入文件夹，在空白处点击右键，选择  <code>Git Bash Here</code></p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165049.png" style="zoom:70%;" />
</li>
<li><p>在Git Bash中输入<code>hexo init</code>，初始化 hexo 博客（此时会去 GitHub 中克隆 hexo-starter）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165050.png" style="zoom:70%;" />
</li>
<li><p>初始化完成后，Blog 文件夹中会多出一些文件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165051.png" style="zoom:67%;" />
</li>
<li><p>在 Git Bash 中输入<code>hexo g</code>，生成静态文件（也可以使用全命令 hexo generate）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165052.png" style="zoom:67%;" />
</li>
<li><p>在 Git Bash 中输入<code>hexo s</code>，启动 hexo 服务器（也可以使用全命令 hexo server） </p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165053.png" style="zoom:67%;" />
</li>
<li><p>启动 hexo 服务器后，在浏览器输入网址：<a><a href="http://localhost:4000/">http://localhost:4000/</a></a>，出现以下界面，即表明本地 hexo 部署成功！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165054.png" style="zoom: 50%;" /></li>
</ul>
<h1 id="4-远程部署（GitHub）Hexo"><a href="#4-远程部署（GitHub）Hexo" class="headerlink" title="4. 远程部署（GitHub）Hexo"></a>4. 远程部署（GitHub）Hexo</h1><p>以上我们将 Hexo 部署到了本地，但是存在一个问题，此时仅自己或者是局域网内的小伙伴可以看到此博客网站，其他人并不能在网络上进行访问，为了让所有人都可以访问我们的博客网站，可以借助于 GitHub 实现远程部署。下面是远程部署流程：</p>
<ul>
<li><p>在 GitHub 上新建一个仓库，仓库名<strong>必须</strong>为：<code>你的用户名.github.io</code>，比如我的叫：<em>SniperCoding.github.io</em></p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165055.png" style="zoom:67%;" />
</li>
<li><p>点击<code>Create repository</code>创建仓库后，复制仓库地址</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165056.png" style="zoom:65%;" />
</li>
<li><p>打开 Blog 文件夹中的 _config.yml 文件，将最下面内容修改如下（其中 repository 填写刚才复制的地址）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/你的用户名/你的用户名.github.io.git</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165057.png" style="zoom:60%;" />
</li>
<li><p>在 Git Bash 中使用 Ctrl+C 退出刚才的本地部署，然后输入命令<code> npm install --save hexo-deployer-git</code>安装 Git 部署插件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165058.png" style="zoom:67%;" />
</li>
<li><p>接着依次键入</p>
<ul>
<li><code>hexo clean</code> (清除缓存文件 (db.json) 和已生成的静态文件 (public)。)</li>
<li><code>hexo g</code>（hexo generate，生成静态文件）</li>
<li><code>hexo d</code>（hexo deploy，部署网站到配置文件中指定的仓库，此步需要输入 GitHub 账号密码）</li>
</ul>
</li>
<li><p>在浏览器打开 <code>https://你的用户名.github.io/</code>（比如我的是 <a><a href="https://snipercoding.github.io/">https://snipercoding.github.io/</a></a>），出现以下界面，即表明 Hexo 远程部署成功！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165059.png" style="zoom:50%;" /></li>
</ul>
<h1 id="5-Hexo目录结构"><a href="#5-Hexo目录结构" class="headerlink" title="5. Hexo目录结构"></a>5. Hexo目录结构</h1><table>
<thead>
<tr>
<th>文件&#x2F;文件夹</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>node_modules</td>
<td>存放已安装的各类依赖包</td>
</tr>
<tr>
<td><strong>public</strong></td>
<td>当执行<code>Hexo g</code>命令后会生成此文件夹，实际上会将source文件夹里的Markdown文档，使用当前主题将其转换成HTML文件，我们在博客中看到的就是此页面。（使用 <code>hexo clean</code>会 清除 db.json 和 public 文件夹下的所有文件。）</td>
</tr>
<tr>
<td>scaffolds</td>
<td>模版 文件夹。当新建文章时，Hexo 会根据 scaffold 来建立文件。包含 page，post，draft三种模板，分别对应 页面、要发布的文章、草稿。</td>
</tr>
<tr>
<td><strong>source</strong></td>
<td>用户资源文件夹。 其下_posts 文件夹用来存放图片、Markdown 文章等，通过<code>Hexo g</code>命令将文章解析为HTML文件放到public文件夹中</td>
</tr>
<tr>
<td>themes</td>
<td>主题文件夹。每个主题都会有一个单独文件夹。其默认主题为<a href="https://link.segmentfault.com/?url=https://github.com/hexojs/hexo-theme-landscape">landscape</a>。</td>
</tr>
<tr>
<td><strong>_config.yml</strong></td>
<td>全局配置文件。可设置包括网站标题、副标题、作者、关键字和描述信息、主题等</td>
</tr>
<tr>
<td><strong>.deploy_git</strong></td>
<td>当执行<code>hexo d</code>远程部署时会生成此文件夹，实际上会将public文件夹的内容提交到Github后中，内容与public文件夹基本一致（不一致的情况是由于重新生成，但是没有发布站点造成，此时 public 内容新于 .deploy_gi 内容）。</td>
</tr>
</tbody></table>
<h1 id="6-Hexo发布文章"><a href="#6-Hexo发布文章" class="headerlink" title="6. Hexo发布文章"></a>6. Hexo发布文章</h1><p>在 Git Bash 中输入<code>hexo new &quot;文章标题&quot;</code>，会在 &#x2F;source&#x2F;_posts&#x2F; 文件夹中生成<strong>文章标题.md</strong>文件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165100.png" style="zoom:70%;" />

<p>打开<strong>文章标题.md</strong>文件，然后编写文章内容（遵循Markdown语法规范）</p>
<p>之后在 Git Bash 依次键入以下命令远程部署：</p>
<ul>
<li><code>hexo clean</code> (清除缓存文件 (db.json) 和已生成的静态文件 (public)。)</li>
<li><code>hexo g</code>（hexo generate，生成静态文件）</li>
<li><code>hexo d</code>（hexo deploy，部署网站到配置文件中指定的仓库，此步需要输入github账号密码）</li>
</ul>
<p>打开 GitHub网址，即可看到自己新发布的文章.</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165101.png" style="zoom:35%;" />

<p>注意：文章中使用图片较为特殊，建议大家利用充分利用 GitHub, 将其作为图床，将本地图片转化为url链接，然后在文章中使用，详情可见：<a href="https://snipercoding.github.io/2022/02/10/GitHub+JSDelivr+PicGo+Typora%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/">GitHub+JSDelivr+PicGo+Typora搭建个人图床</a></p>
<p>也可以使用下面方式配置图片路径（配置一次就好）：</p>
<ul>
<li><p>打开 **_config.yml **配置文件，将 <strong>post_asset_folder</strong> 的值修改为 true</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165102.png" style="zoom:67%;" />
</li>
<li><p>在 Git Bash 中输入命令<code>npm install hexo-asset-image --save</code>安装插件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165103.png" style="zoom:67%;" />
</li>
<li><p>修改 node_modules\hexo-asset-image\index.js 内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">	<span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.<span class="title function_">shift</span>();</span><br><span class="line">			  src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">			  <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完图片路径后，以后在使用 <code>hexo new &quot;文章标题&quot;</code>命令后，会在 &#x2F;source&#x2F;_post 下生成<strong>文章标题.md文件</strong>和<strong>文章标题文件夹</strong>，将所需要的图片放入到标题文件夹中。在文章中可以使用相对路径引用图片资源<code>![](图片相对路径)</code></p>
<p>比如使用 hexo new “test_article” 创建一篇文章，会在 &#x2F;source&#x2F;_post 生成 <strong>test_article.md 文件</strong>和 <strong>test_article文件夹</strong>，然后将 test.jpg 放入 test_article 文件夹中，在文章中只需要使用<code>![](test_article/test.jpg)</code>即可。</p>
</li>
</ul>
<h1 id="7-Hexo配置站点信息"><a href="#7-Hexo配置站点信息" class="headerlink" title="7. Hexo配置站点信息"></a>7. Hexo配置站点信息</h1><p>打开 _config.yml 文件，按自己需求修改以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">SniperCoding的个人博客</span>		 			  <span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>		  						      <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;请不要假装很努力，因为结果不会陪你演戏&#x27;</span>  <span class="comment"># 网站描述（一般为格言）</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">SniperCoding</span>					   		  <span class="comment"># 网站作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>									  <span class="comment"># 网站语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>						  <span class="comment"># 网站时区</span></span><br></pre></td></tr></table></figure>

<p>注意_config.yml 文件的编码格式应为 utf-8，否则会出现中文乱码。</p>
<p>以上就是使用 <code>GitHub</code> + <code>Hexo</code> 搭建简易个人博客的流程，但是博客默认主题样式不够美观，如果想要自定义博客样式的话，可以自行更换主题，下期我将向大家介绍，如何将Hexo的主题更换为next主题，并对自己的个人博客增加各种功能，比如添加背景、进度条、评论、文章目录等等。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>Hexo博客之主题NexT的详细设置</title>
    <url>/2022/02/10/Hexo_Next%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一-Hexo修改主题"><a href="#一-Hexo修改主题" class="headerlink" title="一. Hexo修改主题"></a>一. Hexo修改主题</h1><blockquote>
<p>Hexo 默认的主题是 landscape，如果想要博客渲染更为美观，可自行修改主题。修改 Hexo 主题很方便，首先下载所需主题，放到 <code>themes</code> 文件夹内，然后修改 <code>_config.yml</code> 内的 <code>theme</code> 设定，即可修改主题。下面以NexT主题为例。</p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>下载 NexT 主题，并放到 themes&#x2F;next 文件夹中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/20220324165200.png"></p>
</li>
<li><p>修改 _config.yml 文件，将 theme 修改为 next</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/20220324165201.png"></p>
</li>
<li><p>之后再使用 <code>hexo clean</code>、<code>hexo g</code>、<code>hexo d </code>命令远程部署后，打开网站就会发现主题焕然一新。</p>
</li>
</ul>
<h1 id="二-NexT主题优化"><a href="#二-NexT主题优化" class="headerlink" title="二. NexT主题优化"></a>二. NexT主题优化</h1><blockquote>
<p>通过修改 NexT 主题的一些配置进行优化（中文参考文档 <a><a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a></a>），下面如果不特殊说明，默认修改的是 NexT 主题配置文件（Blog\themes\next\_config.yml），而不是Hexo配置文件（Blog\_config.yml），注意区分。</p>
</blockquote>
<h2 id="1、风格方案"><a href="#1、风格方案" class="headerlink" title="1、风格方案"></a>1、风格方案</h2><p>可选：Muse（ 默认）、Mist、Pisces、Gemini，可以根据喜好选择自己喜欢的方案。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h2 id="2、导航栏菜单设置（首页、标签、归档等）"><a href="#2、导航栏菜单设置（首页、标签、归档等）" class="headerlink" title="2、导航栏菜单设置（首页、标签、归档等）"></a>2、导航栏菜单设置（首页、标签、归档等）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span>    			<span class="comment"># 首页</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span>   		<span class="comment"># 关于</span></span><br><span class="line">  <span class="comment"># tags: /tags/ || fa fa-tags			# 标签</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span>    	<span class="comment"># 分类</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span>   	<span class="comment"># 归档</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar	# 日历</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || fa fa-sitemap 	# 站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment"># commonweal: /404/ || fa fa-heartbeat   	# 公益</span></span><br></pre></td></tr></table></figure>

<p>若想添加【分类】页面，除了修改上述配置文件外，还需要在 Git Bash 中输入<code>hexo new page categories</code>新建一个分类页面，否则点击分类会出现 404。在 Blog\source 文件夹下会生成 categories\index.md 文件，编辑此文件，添加<code>type: &quot;categories&quot;</code>；</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: categories</span><br><span class="line">date: 2022-02-10 14:50:56</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<p>之后在新生成文件后，可以在最开头加上 categories: 类别，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">title: GitHub+JSDelivr+PicGo+Typora搭建个人图床</span><br><span class="line"><span class="built_in">date</span>: 2022-02-10 14:52:38</span><br><span class="line">categories: 图床</span><br></pre></td></tr></table></figure>

<p>【标签】页面与【分类】页面新建类似，<code>hexo new page tags</code>；</p>
<p>【关于】页面与【分类页面新建类似，<code>hexo new page about</code>，在 Blog\source 文件夹下会生成 about\index.md 文件，之后可以根据需要在 index.md 文件中书写相关内容。</p>
<h2 id="3、设置侧边栏（显示头像、社交账号等）"><a href="#3、设置侧边栏（显示头像、社交账号等）" class="headerlink" title="3、设置侧边栏（显示头像、社交账号等）"></a>3、设置侧边栏（显示头像、社交账号等）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 头像</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span>  	<span class="comment"># 头像地址（将头像放在themes\next\source\images目录下，并重命名）</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span> 		   <span class="comment"># 头像为圆形（true），头像为方形（false）</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span>		   <span class="comment"># 鼠标触碰头像时，头像旋转（true），不旋转（false）</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 社交账号 </span></span><br><span class="line"><span class="comment"># 格式为，链接名:链接地址 || 链接图标（Font Awesome icon）</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/SniperCoding</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br></pre></td></tr></table></figure>

<h2 id="4、设置文章目录"><a href="#4、设置文章目录" class="headerlink" title="4、设置文章目录"></a>4、设置文章目录</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  	<span class="comment"># 是否自动生成目录</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>  	<span class="comment"># 目录是否自动产生编号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span>  		<span class="comment"># 标题过长是否换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span>  	<span class="comment"># 是否展开所有级别</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">3</span>  	<span class="comment"># 最大标题深度</span></span><br></pre></td></tr></table></figure>

<h2 id="5、设置代码高亮主题和代码复制按钮"><a href="#5、设置代码高亮主题和代码复制按钮" class="headerlink" title="5、设置代码高亮主题和代码复制按钮"></a>5、设置代码高亮主题和代码复制按钮</h2><p>可选样式为：normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">eighties</span>  <span class="comment"># 高亮主题样式</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>		<span class="comment"># 是否开启代码复制按钮</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span>		<span class="comment"># 是否显示代码复制结果</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span>			<span class="comment"># 风格，可选default | flat | mac</span></span><br></pre></td></tr></table></figure>

<h2 id="6、首页文章部分预览"><a href="#6、首页文章部分预览" class="headerlink" title="6、首页文章部分预览"></a>6、首页文章部分预览</h2><p>在首页，文章默认会全文显示，若想仅预览（显示）文章的前面一小部分。只需要在编写的md文章中，插入<code>&lt;!--more--&gt;</code> ，首页便只会显示此标记以前的内容。</p>
<h2 id="7、添加文章版权信息"><a href="#7、添加文章版权信息" class="headerlink" title="7、添加文章版权信息"></a>7、添加文章版权信息</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span>  		<span class="comment"># 执照类型 by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>		<span class="comment"># 是否在侧边栏中显示版权标识</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>		  	<span class="comment"># 是否每篇文章底部自动显示版权信息（本文作者、本文链接、版权声明）</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-Hans</span>	  	<span class="comment"># 语言</span></span><br></pre></td></tr></table></figure>

<p>注意需要将 Hexo 配置文件，（即 Blog\_coonfig.yml）中的 url 修改为自己的域名，否则显示本文链接时会出现问题。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://SniperCoding.github.io/</span></span><br></pre></td></tr></table></figure>

<h2 id="8、统计阅读人数-x2F-访客数信息"><a href="#8、统计阅读人数-x2F-访客数信息" class="headerlink" title="8、统计阅读人数&#x2F;访客数信息"></a>8、统计阅读人数&#x2F;访客数信息</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                    	<span class="comment"># 是否启用不蒜子统计</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>		<span class="comment"># 是否统计总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span>   <span class="comment"># 总访客数图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>		<span class="comment"># 是否统计总访问数（所有文章访问数总和）</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>	    <span class="comment"># 总访问数图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>		<span class="comment"># 是否统计文章访问数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span>	    <span class="comment"># 文章访问数图标</span></span><br></pre></td></tr></table></figure>

<h2 id="9、统计文章字数-x2F-阅读时间"><a href="#9、统计文章字数-x2F-阅读时间" class="headerlink" title="9、统计文章字数&#x2F;阅读时间"></a>9、统计文章字数&#x2F;阅读时间</h2><ul>
<li><p>安装 <code>hexo-symbols-count-time</code> 插件，在 Git Bash 中输入以下命令进行安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 NexT 配置文件（Blog\themes\next\_config.yml）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>		<span class="comment"># 是否另起一行显示（即不和发表时间等同一行显示）</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>		<span class="comment"># 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span>		<span class="comment"># 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Hexo 配置文件（Blog\_config.yml）中新增如下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>				<span class="comment"># 是否统计文章阅读时长</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>				<span class="comment"># 是否统计文章字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>			<span class="comment"># 是否统计站点总阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>			<span class="comment"># 是否统计站点总字数</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">true</span>		<span class="comment"># 是否排除代码字数统计</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10、侧栏显示阅读进度百分比"><a href="#10、侧栏显示阅读进度百分比" class="headerlink" title="10、侧栏显示阅读进度百分比"></a>10、侧栏显示阅读进度百分比</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>      	<span class="comment"># 是否开启</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>  	<span class="comment"># 是否在侧边栏显示</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span>  	<span class="comment"># 按钮是否显示阅读进度</span></span><br></pre></td></tr></table></figure>

<h2 id="11、顶部加载阅读进度条"><a href="#11、顶部加载阅读进度条" class="headerlink" title="11、顶部加载阅读进度条"></a>11、顶部加载阅读进度条</h2><ul>
<li><p>安装 <code>reading_progress</code> 模块，在 Git Bash 输入以下命令进行安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-reading-progress themes/next/source/lib/reading_progress</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 NexT 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>			<span class="comment"># 是否启用进度条</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span>			<span class="comment"># 进度条位置（top | bottom）</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;#37c6c0&quot;</span>		<span class="comment"># 进度条颜色</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span>			<span class="comment"># 进度条高度</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12、添加评论系统（Valine）"><a href="#12、添加评论系统（Valine）" class="headerlink" title="12、添加评论系统（Valine）"></a>12、添加评论系统（Valine）</h2><ul>
<li><p>获取 <code>APP ID</code>  和  <code>APP Key</code></p>
<p>进入官网 <a href="https://leancloud.cn/">LeanCloud</a> 进行注册, 注册登陆认证后进入应用，点击创建应用，输入任意名称，并选择开发</p>
<p>版，点击创建。进入所创建的应用，选择左下角的<code>设置</code>&gt;<code>应用凭证</code>，就看到 <code>APP ID</code> 和 <code>APP Key</code>了。</p>
</li>
<li><p>将博客域名添加到安全域名中</p>
<p>进入所创建的应用，选择左下角<code>设置</code>&gt;<code>安全中心</code>，然后将自己的博客域名(举例：<a href="https://snipercoding.github.io/)%E5%A1%AB%E5%86%99%E5%9C%A8Web%E5%AE%89%E5%85%A8%E5%9F%9F%E5%90%8D%E4%B8%AD%EF%BC%8C%E5%B9%B6%E4%BF%9D%E5%AD%98%E3%80%82">https://snipercoding.github.io/)填写在Web安全域名中，并保存。</a></p>
</li>
<li><p>修改 NexT 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>					<span class="comment"># 是否启动valine评论</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="string">xxxxxx</span> 				<span class="comment"># 你的aapid【重要】</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">xxxxxx</span>				<span class="comment"># 你的appkey【重要】</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">true</span> 					<span class="comment"># 是否开启评论回复邮件通知</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">true</span>	 				<span class="comment"># 评论前是否开启验证码</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">撰写你的评论叭~</span>    		<span class="comment"># 评论框的占位符</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> 					<span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> 			<span class="comment"># 自定义评论标题【昵称，邮箱，网址】</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> 					<span class="comment"># 分页大小</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span>				<span class="comment"># 语言</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> 				<span class="comment"># 是否允许游客评论</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> 				<span class="comment"># 评论计数是否显示在主页</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> 				<span class="comment"># 是否记录注释IP</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>评论数据管理</p>
<p>当想要管理用户的评论时，比如删除一些不当评论，可以到在 <a href="https://leancloud.cn/">LeanCloud</a>中进入<code>你创建的应用&gt;数据化存储&gt;结构化数据&gt;选择Class Comment</code>，进行管理。（注意，刚开始是没有Comment这个Class，当博客第一次有评论时，会自动创建，也可以自行先创建）</p>
</li>
<li><p>【问题记录1】，在修改_config.yml文件中的appid和appkey时，注意将后面的注释删除掉（有可能会把注释当成appid&#x2F;appkey的一部分），否则可能会出现401错误。</p>
</li>
<li><p>【问题记录2】，在文章顶部不显示评论数，而是显示valine，此时修改<code>themes/next/languages/zh-CN.yml</code>文件，在post标签下添加<code>comments.valine: 评论数</code>即可。</p>
</li>
<li><p>【问题记录3】，默认情况下，评论右下角会有Valine的角标（Powered By <a href="https://valine.js.org/">Valine</a>v1.4.14），如果想要将此删除，可以编辑<code>themes/next/layout/_third-party/comments/valine.swig</code>文件，修改为下面样式即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;%- set valine_uri = theme.<span class="property">vendors</span>.<span class="property">valine</span> or <span class="string">&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;</span> %&#125;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="title class_">NexT</span>.<span class="property">utils</span>.<span class="title function_">loadComments</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#valine-comments&#x27;</span>), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">NexT</span>.<span class="property">utils</span>.<span class="title function_">getScript</span>(<span class="string">&#x27;&#123;&#123; valine_uri &#125;&#125;&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable constant_">GUEST</span> = [<span class="string">&#x27;nick&#x27;</span>, <span class="string">&#x27;mail&#x27;</span>, <span class="string">&#x27;link&#x27;</span>];</span><br><span class="line">    <span class="keyword">var</span> guest = <span class="string">&#x27;&#123;&#123; theme.valine.guest_info &#125;&#125;&#x27;</span>;</span><br><span class="line">    guest = guest.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">GUEST</span>.<span class="title function_">includes</span>(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Valine</span>(&#123;</span><br><span class="line">      el         : <span class="string">&#x27;#valine-comments&#x27;</span>,</span><br><span class="line">      verify     : &#123;&#123; theme.<span class="property">valine</span>.<span class="property">verify</span> &#125;&#125;,</span><br><span class="line">      notify     : &#123;&#123; theme.<span class="property">valine</span>.<span class="property">notify</span> &#125;&#125;,</span><br><span class="line">      appId      : <span class="string">&#x27;&#123;&#123; theme.valine.appid &#125;&#125;&#x27;</span>,</span><br><span class="line">      appKey     : <span class="string">&#x27;&#123;&#123; theme.valine.appkey &#125;&#125;&#x27;</span>,</span><br><span class="line">      <span class="attr">placeholder</span>: &#123;&#123; theme.<span class="property">valine</span>.<span class="property">placeholder</span> | json &#125;&#125;,</span><br><span class="line">      avatar     : <span class="string">&#x27;&#123;&#123; theme.valine.avatar &#125;&#125;&#x27;</span>,</span><br><span class="line">      meta       : guest,</span><br><span class="line">      pageSize   : <span class="string">&#x27;&#123;&#123; theme.valine.pageSize &#125;&#125;&#x27;</span> || <span class="number">10</span>,</span><br><span class="line">      visitor    : &#123;&#123; theme.<span class="property">valine</span>.<span class="property">visitor</span> &#125;&#125;,</span><br><span class="line">      lang       : <span class="string">&#x27;&#123;&#123; theme.valine.language &#125;&#125;&#x27;</span> || <span class="string">&#x27;zh-cn&#x27;</span>,</span><br><span class="line">      path       : location.<span class="property">pathname</span>,</span><br><span class="line">      recordIP   : &#123;&#123; theme.<span class="property">valine</span>.<span class="property">recordIP</span> &#125;&#125;,</span><br><span class="line">      serverURLs : <span class="string">&#x27;&#123;&#123; theme.valine.serverURLs &#125;&#125;&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 添加以下内容，删除Powered By Valine</span></span><br><span class="line">    <span class="keyword">var</span> infoEle = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.vpower&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (infoEle)&#123;</span><br><span class="line">        infoEle.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(infoEle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13、修改网站底部信息（footer）"><a href="#13、修改网站底部信息（footer）" class="headerlink" title="13、修改网站底部信息（footer）"></a>13、修改网站底部信息（footer）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2022</span>  			<span class="comment"># 建站时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span>	<span class="comment"># 一个❤的图标</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>		<span class="comment"># 图标是否跳动</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span>	<span class="comment"># 图标颜色</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span>  		<span class="comment"># 是否显示“由 Hexo &amp; NexT.Gemini 强力驱动”</span></span><br></pre></td></tr></table></figure>

<p>若想在底部显示站点运行时间，可编辑<code>\themes\next\layout\_partials\footer.swig</code>，在下图所在位置添加指定内容</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165202.png" alt="" style="zoom:67%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;sitetime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">javascript</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">function</span> <span class="title function_">siteTime</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="string">&quot;siteTime()&quot;</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> seconds = <span class="number">1000</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> days = hours * <span class="number">24</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> years = days * <span class="number">365</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todayYear = today.<span class="title function_">getFullYear</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todayMonth = today.<span class="title function_">getMonth</span>()+<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todayDate = today.<span class="title function_">getDate</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todayHour = today.<span class="title function_">getHours</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todayMinute = today.<span class="title function_">getMinutes</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> todaySecond = today.<span class="title function_">getSeconds</span>();</span></span><br><span class="line"><span class="language-javascript">		<span class="comment">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		year - 作为date对象的年份，为4位年份值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		month - 0-11之间的整数，做为date对象的月份</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		day - 1-31之间的整数，做为date对象的天数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		minutes - 0-59之间的整数，做为date对象的分钟数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		seconds - 0-59之间的整数，做为date对象的秒数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> t1 = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2021</span>,<span class="number">08</span>,<span class="number">13</span>,<span class="number">00</span>,<span class="number">00</span>,<span class="number">00</span>); <span class="comment">//北京时间2021-08-13 00:00:00（修改为自己的建站时间）</span></span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> t2 = <span class="title class_">Date</span>.<span class="title function_">UTC</span>(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diff = t2-t1;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diffYears = <span class="title class_">Math</span>.<span class="title function_">floor</span>(diff/years);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diffDays = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff/days)-diffYears*<span class="number">365</span>);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diffHours = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days)/hours);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diffMinutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours)/minutes);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">var</span> diffSeconds = <span class="title class_">Math</span>.<span class="title function_">floor</span>((diff-(diffYears*<span class="number">365</span>+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span></span><br><span class="line"><span class="language-javascript">		<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;sitetime&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot; 本网站已运行&quot;</span>+<span class="comment">/*diffYears+&quot; 年 &quot;+*/</span>diffDays+<span class="string">&quot; 天 &quot;</span>+diffHours+<span class="string">&quot; 小时 &quot;</span>+diffMinutes+<span class="string">&quot; 分钟 &quot;</span>+diffSeconds+<span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">siteTime</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="14、添加网易云音乐"><a href="#14、添加网易云音乐" class="headerlink" title="14、添加网易云音乐"></a>14、添加网易云音乐</h2><ul>
<li>在网页版<a href="https://music.163.com/">网易云音乐</a>中选择自己喜欢的歌曲&#x2F;歌单，然后点击<u>生成外链播放器</u>，官方教程<a href="https://music.163.com/#/outchain/0/786909207/">https://music.163.com/#/outchain/0/786909207/</a></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165203.png" alt="" style="zoom:50%;" />

<ul>
<li><p>在生成外链界面，修改所要显示的格式以及宽高，然后复制HTML代码</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165204.png" alt="" style="zoom: 67%;" />
</li>
<li><p>将代码插入到<code>Blog\themes\next\layout\_macro\sidebar.swig</code>文件中（位置仅供参考，可自行选择所需位置，不同的位置效果呈现的效果不同）。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165205.png" alt="" style="zoom:60%;" /></li>
</ul>
<h2 id="15、设置主题页面布局为圆角"><a href="#15、设置主题页面布局为圆角" class="headerlink" title="15、设置主题页面布局为圆角"></a>15、设置主题页面布局为圆角</h2><p>将页面中的方形边框修改为圆角。</p>
<ul>
<li><p>打开<code>Blog\themes\next\source\css\_variables\Gemini.styl </code>文件（我用的是 Gemini 主题风格，如果用的是其他的，就打开相应的文件）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165206.png" alt="" style="zoom: 67%;" />
</li>
<li><p>将最低端代码修改为以下内容（可自行修改圆角尺寸，这里以15px为例）</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $border-radius-inner    = initial;</span></span><br><span class="line"><span class="comment">// $border-radius		= initial;</span></span><br><span class="line"><span class="variable">$border</span>-radius-inner = <span class="number">15px</span> <span class="number">15px</span> <span class="number">15px</span> <span class="number">15px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius = <span class="number">15px</span>;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165207.png" alt="" style="zoom:67%;" /></li>
</ul>
<h2 id="16、添加动态背景（添加动态背景的同时也可以添加静态背景）"><a href="#16、添加动态背景（添加动态背景的同时也可以添加静态背景）" class="headerlink" title="16、添加动态背景（添加动态背景的同时也可以添加静态背景）"></a>16、添加动态背景（添加动态背景的同时也可以添加静态背景）</h2><p>Nest支持的常见的动态背景有 <strong>Canvas-nest</strong> 风格、**JavaScript 3D  library <strong>风格 、</strong>Canvas-ribbon **风格三种动态背景，但都需要自己手动下载相应静态资源，这里以 <strong>JavaScript 3D  library</strong> 风格为例。</p>
<p>JavaScript 3D  library 的官方地址为<a href="https://github.com/theme-next/theme-next-three">https://github.com/theme-next/theme-next-three</a></p>
<ul>
<li><p>Git Bash 进入 NexT 文件目录，然后将动态背景模块安装到 <code>source\lib</code> 目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-three <span class="built_in">source</span>/lib/three</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>Blog\themes\next\_config.yml</code> 配置文件，启动 JavaScript 3D library，并且设置<code>three_waves\canvas_lines\canvas_sphere </code> 三个中任意一个为true（三个背景的样式不同，可自行选择）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>			<span class="comment"># 启用此动态背景</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">false</span>		<span class="comment"># 动态背景样式一</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">true</span>		<span class="comment"># 动态背景样式二</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span>		<span class="comment"># 动态背景样式三</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="17、鼠标点击出现礼花效果"><a href="#17、鼠标点击出现礼花效果" class="headerlink" title="17、鼠标点击出现礼花效果"></a>17、鼠标点击出现礼花效果</h2><ul>
<li><p>在 <code>Blog/themes/next/source/js</code> 里面新建 <code>fireworks.js</code> 的文件，并写入以下内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">&#123; origin, speed, color, angle, context &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">origin</span> = origin</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">position</span> = &#123; ...<span class="variable language_">this</span>.<span class="property">origin</span> &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">speed</span> = speed</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">angle</span> = angle</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderCount</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">fillStyle</span> = <span class="variable language_">this</span>.<span class="property">color</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">beginPath</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">arc</span>(<span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">y</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">fill</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">x</span> = (<span class="title class_">Math</span>.<span class="title function_">sin</span>(<span class="variable language_">this</span>.<span class="property">angle</span>) * <span class="variable language_">this</span>.<span class="property">speed</span>) + <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">x</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">y</span> = (<span class="title class_">Math</span>.<span class="title function_">cos</span>(<span class="variable language_">this</span>.<span class="property">angle</span>) * <span class="variable language_">this</span>.<span class="property">speed</span>) + <span class="variable language_">this</span>.<span class="property">position</span>.<span class="property">y</span> + (<span class="variable language_">this</span>.<span class="property">renderCount</span> * <span class="number">0.3</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boom</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (&#123; origin, context, circleCount = <span class="number">16</span>, area &#125;) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">origin</span> = origin</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circleCount</span> = circleCount</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">area</span> = area</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stop</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circles</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">randomArray</span>(<span class="params">range</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> length = range.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> randomIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(length * <span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">    <span class="keyword">return</span> range[randomIndex]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">randomColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> range = [<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range) + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range) + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range) + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range) + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range) + <span class="variable language_">this</span>.<span class="title function_">randomArray</span>(range)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">randomRange</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (end - start) * <span class="title class_">Math</span>.<span class="title function_">random</span>() + start</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">circleCount</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(&#123;</span><br><span class="line">        <span class="attr">context</span>: <span class="variable language_">this</span>.<span class="property">context</span>,</span><br><span class="line">        <span class="attr">origin</span>: <span class="variable language_">this</span>.<span class="property">origin</span>,</span><br><span class="line">        <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="title function_">randomColor</span>(),</span><br><span class="line">        <span class="attr">angle</span>: <span class="variable language_">this</span>.<span class="title function_">randomRange</span>(<span class="title class_">Math</span>.<span class="property">PI</span> - <span class="number">1</span>, <span class="title class_">Math</span>.<span class="property">PI</span> + <span class="number">1</span>),</span><br><span class="line">        <span class="attr">speed</span>: <span class="variable language_">this</span>.<span class="title function_">randomRange</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">circles</span>.<span class="title function_">push</span>(circle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circles</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">circle, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (circle.<span class="property">position</span>.<span class="property">x</span> &gt; <span class="variable language_">this</span>.<span class="property">area</span>.<span class="property">width</span> || circle.<span class="property">position</span>.<span class="property">y</span> &gt; <span class="variable language_">this</span>.<span class="property">area</span>.<span class="property">height</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">circles</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      circle.<span class="title function_">move</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">circles</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">stop</span> = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">circles</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">circle</span> =&gt;</span> circle.<span class="title function_">draw</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CursorSpecialEffects</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computerCanvas</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderCanvas</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computerContext</span> = <span class="variable language_">this</span>.<span class="property">computerCanvas</span>.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderContext</span> = <span class="variable language_">this</span>.<span class="property">renderCanvas</span>.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">globalWidth</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">globalHeight</span> = <span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">booms</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleMouseDown</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> boom = <span class="keyword">new</span> <span class="title class_">Boom</span>(&#123;</span><br><span class="line">      <span class="attr">origin</span>: &#123; <span class="attr">x</span>: e.<span class="property">clientX</span>, <span class="attr">y</span>: e.<span class="property">clientY</span> &#125;,</span><br><span class="line">      <span class="attr">context</span>: <span class="variable language_">this</span>.<span class="property">computerContext</span>,</span><br><span class="line">      <span class="attr">area</span>: &#123;</span><br><span class="line">        <span class="attr">width</span>: <span class="variable language_">this</span>.<span class="property">globalWidth</span>,</span><br><span class="line">        <span class="attr">height</span>: <span class="variable language_">this</span>.<span class="property">globalHeight</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    boom.<span class="title function_">init</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">booms</span>.<span class="title function_">push</span>(boom)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> || <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handlePageHide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">booms</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> style = <span class="variable language_">this</span>.<span class="property">renderCanvas</span>.<span class="property">style</span></span><br><span class="line">    style.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span></span><br><span class="line">    style.<span class="property">top</span> = style.<span class="property">left</span> = <span class="number">0</span></span><br><span class="line">    style.<span class="property">zIndex</span> = <span class="string">&#x27;999999999999999999999999999999999999999999&#x27;</span></span><br><span class="line">    style.<span class="property">pointerEvents</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line">    style.<span class="property">width</span> = <span class="variable language_">this</span>.<span class="property">renderCanvas</span>.<span class="property">width</span> = <span class="variable language_">this</span>.<span class="property">computerCanvas</span>.<span class="property">width</span> = <span class="variable language_">this</span>.<span class="property">globalWidth</span></span><br><span class="line">    style.<span class="property">height</span> = <span class="variable language_">this</span>.<span class="property">renderCanvas</span>.<span class="property">height</span> = <span class="variable language_">this</span>.<span class="property">computerCanvas</span>.<span class="property">height</span> = <span class="variable language_">this</span>.<span class="property">globalHeight</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(<span class="variable language_">this</span>.<span class="property">renderCanvas</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousedown&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseDown</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;pagehide&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handlePageHide</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">running</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">booms</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">running</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(<span class="variable language_">this</span>.<span class="property">run</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>))</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computerContext</span>.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">globalWidth</span>, <span class="variable language_">this</span>.<span class="property">globalHeight</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderContext</span>.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">globalWidth</span>, <span class="variable language_">this</span>.<span class="property">globalHeight</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">booms</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">boom, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (boom.<span class="property">stop</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">booms</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      boom.<span class="title function_">move</span>()</span><br><span class="line">      boom.<span class="title function_">draw</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">renderContext</span>.<span class="title function_">drawImage</span>(<span class="variable language_">this</span>.<span class="property">computerCanvas</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">globalWidth</span>, <span class="variable language_">this</span>.<span class="property">globalHeight</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cursorSpecialEffects = <span class="keyword">new</span> <span class="title class_">CursorSpecialEffects</span>()</span><br><span class="line">cursorSpecialEffects.<span class="title function_">init</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 <code>Blog\themes\next\layout\_layout.swig</code> 文件，添加如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.fireworks %&#125; </span><br><span class="line">   &lt;script async <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/fireworks.js&quot;</span>&gt;&lt;/script&gt;    </span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165208.png" style="zoom:67%;" />
</li>
<li><p>打开 <code>Blog\themes\next\_config.yml</code> 配置文件，在任意位置添加以下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鼠标点击，出现烟花效果</span></span><br><span class="line">fireworks: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="18、修改网页图标"><a href="#18、修改网页图标" class="headerlink" title="18、修改网页图标"></a>18、修改网页图标</h2><p>Hexo 博客的默认图标是 <code>N</code>，可自定义修改，步骤如下：</p>
<ul>
<li><p>准备一张 16*16 大小的 png 格式图标和一张 32*32 大小的png格式图标，然后放置到<code>Blog\themes\next\source\images</code> 文件夹下。</p>
</li>
<li><p>修改 <code>Blog\themes\next\_config.yml</code> 配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/tiger_16_16.png</span>   	<span class="comment"># 自定义16*16图片的路径名 </span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/tiger_32_32.png</span>	<span class="comment"># 自定义32*32图片的路径名 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="19、添加页面萌宠"><a href="#19、添加页面萌宠" class="headerlink" title="19、添加页面萌宠"></a>19、添加页面萌宠</h2><p>使用live2d插件，官方网址：<a href="https://github.com/EYHN/hexo-helper-live2d">https://github.com/EYHN/hexo-helper-live2d</a></p>
<ul>
<li><p>安装 live2d 插件，在 Git Bash 中输入以下命令（Blog 文件夹内）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认在页面中展示的是 shizuku，如下图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/20220324165209.png"></p>
<p>根据爱好可自行选择自己的萌宠，所有萌宠在<a href="https://huaji8.top/post/live2d-plugin-2.0/%E4%B8%AD%E6%9C%89gif%E5%8A%A8%E5%9B%BE%E5%B1%95%E7%A4%BA%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E5%90%8D%E7%A7%B0%E3%80%82">https://huaji8.top/post/live2d-plugin-2.0/中有gif动图展示，下面是名称。</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru/01</span><br><span class="line">live2d-widget-model-haru/02</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure>

<p>比如选择 <code>live2d-widget-model-wanko</code>，在 Git Bash 中输入以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-wanko --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>Blog\_config.yml </code>文件，添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># live2d插件</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>							<span class="comment"># 是否启用</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span>						<span class="comment">#  使用本地脚本文件</span></span><br><span class="line">  <span class="attr">model:</span>							</span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span>		<span class="comment"># 所使用的萌宠【修改为自己想要】</span></span><br><span class="line">  <span class="attr">display:</span>								<span class="comment"># 萌宠放置位置以及大小</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span>								<span class="comment">#是否在手机端显示</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：live2d可能会与不蒜子计数出现冲突，解决方案见：<a href="https://blog.csdn.net/weixin_37891983/article/details/105362748">https://blog.csdn.net/weixin_37891983/article/details/105362748</a></p>
<h2 id="20、添加文章结束提示语"><a href="#20、添加文章结束提示语" class="headerlink" title="20、添加文章结束提示语"></a>20、添加文章结束提示语</h2><p>将下面代码插入到 <code>themes\next\layout\_macro\post.swig</code> 文件的END POST BODY下面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color:#ccc;font-size:20px;margin-top:30px&quot;</span>&gt;</span></span><br><span class="line">        -------本 文 结 束 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 感 谢 您 的 阅 读-------</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/个人博客搭建/20220324165210.png"  style="zoom:67%;" />

<p>注意文档编码应为 UTF-8.</p>
<h2 id="21、添加本地搜索"><a href="#21、添加本地搜索" class="headerlink" title="21、添加本地搜索"></a>21、添加本地搜索</h2><p>使用 Git Bash 安装搜素插件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>打开 <code>Blog\_config.yml</code> 配置文件，在任意位置添加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地搜索</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span>		<span class="comment"># 索引文件的路径，相对于站点根目录</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span>			<span class="comment"># 搜索范围，默认是 post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span>			<span class="comment"># 限制搜索的条目数</span></span><br></pre></td></tr></table></figure>

<p>修改 <code>Blog\themes\next\_config.yml</code> 文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础知识</title>
    <url>/2022/02/18/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、数据库的好处"><a href="#一、数据库的好处" class="headerlink" title="一、数据库的好处"></a>一、数据库的好处</h1><ol>
<li>持久化数据到本地</li>
<li>可以实现结构化查询，方便管理</li>
</ol>
<span id="more"></span>

<h1 id="二、数据库相关概念"><a href="#二、数据库相关概念" class="headerlink" title="二、数据库相关概念"></a>二、数据库相关概念</h1><blockquote>
<ul>
<li><strong>数据库 DB（DataBase）</strong>：保存一组有组织的数据的容器。</li>
<li><strong>数据库管理系统 DBMS（DataBase Management System）</strong>：又称为数据库软件，用于管理DB中的数据，比如 MySQL、Oracle、SQL Server…</li>
<li><strong>结构化查询语言 SQL（Structured Query Language）</strong>：SQL 用来和数据库打交道，完成和数据库的通信。</li>
<li><u>表（table）</u>：用来存储特定类型的数据，具有行和列两种属性。数据存储在表中，表再放在库中。一个数据库可以有多个表，但表名不能重复。</li>
<li><u>列（column）</u>：又称为字段， 每一列存储着相同类型的数据。</li>
<li><u>行（row）</u>：表中的一个记录，每一行记录着一组完整的信息。</li>
<li><u>主键（primary key）</u>：主键是一列，通过主键可以唯一区分表中的每一行，如果一列为主键，那么这一列中的数据不能有重复。比如学生的学号可以唯一标识一个学生的信息，那么其可以作为主键，而学生的姓名由于存在同名的可能，就不能作为主键。</li>
</ul>
</blockquote>
<h1 id="三、MySQL-简介"><a href="#三、MySQL-简介" class="headerlink" title="三、MySQL 简介"></a>三、MySQL 简介</h1><h2 id="1-MySQL-使用"><a href="#1-MySQL-使用" class="headerlink" title="1. MySQL 使用"></a>1. MySQL 使用</h2><p><strong>① MySQL 服务的启动和停止</strong></p>
<ul>
<li>方式一：计算机——右击管理——服务</li>
<li>方式二：通过管理员身份运行 cmd，输入命令：<ul>
<li><code>net start 服务名</code>（启动服务）</li>
<li><code>net stop 服务名</code>（停止服务）</li>
</ul>
</li>
</ul>
<p><strong>② MySQL 服务的登录和退出</strong> </p>
<ul>
<li>登录：<u>mysql 【-h主机名 -P端口号 】-u用户名 -p密码</u></li>
<li>退出：exit 或 ctrl+C</li>
</ul>
<h2 id="2-MySQL-的语法规范"><a href="#2-MySQL-的语法规范" class="headerlink" title="2. MySQL 的语法规范"></a>2. MySQL 的语法规范</h2><ul>
<li>不区分大小写，但为了提高可读性，关键字一般大写，其他小写；</li>
<li>每条命令最好用分号结尾；</li>
<li>每条命令根据需要，可以进行缩进或换行以便提高可读性；</li>
<li>注释<ul>
<li>单行注释：# 注释文字</li>
<li>单行注释：– 注释文字</li>
<li>多行注释：&#x2F;* 注释文字 *&#x2F;</li>
</ul>
</li>
</ul>
<h2 id="3-SQL的语言分类"><a href="#3-SQL的语言分类" class="headerlink" title="3. SQL的语言分类"></a>3. SQL的语言分类</h2><ul>
<li><code>DQL（Data Query Language）</code>：数据查询语言，select </li>
<li><code>DML(Data Manipulate Language)</code>：数据操作语言，insert 、update、delete</li>
<li><code>DDL（Data Define Languge）</code>：数据定义语言，create、drop、alter</li>
<li><code>DCL（Data Control Language）</code>：数据控制语言，commit、rollback</li>
</ul>
<h1 id="四、SQL-语言"><a href="#四、SQL-语言" class="headerlink" title="四、SQL 语言"></a>四、SQL 语言</h1><h2 id="1-DDL-语言的学习"><a href="#1-DDL-语言的学习" class="headerlink" title="1. DDL 语言的学习"></a>1. DDL 语言的学习</h2><h3 id="①-库和表的管理"><a href="#①-库和表的管理" class="headerlink" title="① 库和表的管理"></a>① 库和表的管理</h3><p><u><strong>库的管理：</strong></u></p>
<ul>
<li><p>创建库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database 【if <span class="keyword">not</span> <span class="keyword">exists</span>】库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 【if <span class="keyword">exists</span>】库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前所有的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datebase()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用当前数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">user</span> 数据库名</span><br></pre></td></tr></table></figure></li>
</ul>
<p><u><strong>表的管理：</strong></u></p>
<ul>
<li><p><strong>创建表 create table</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 【if <span class="keyword">not</span> <span class="keyword">exists</span>】 表名(</span><br><span class="line">    字段名 字段类型 【约束】,</span><br><span class="line">    字段名 字段类型 【约束】,</span><br><span class="line">    ...</span><br><span class="line">    字段名 字段类型 【约束】 </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 示例 </span><br><span class="line"># 创建一个学生表，包含学号、姓名、班级、性别、分数和电话号码</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    grade <span class="type">int</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    score <span class="type">int</span>,</span><br><span class="line">    phone <span class="type">varchar</span>(<span class="number">20</span>)       </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表 alter table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"><span class="number">1</span>).添加列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">column</span> 列名 类型 【<span class="keyword">first</span><span class="operator">|</span>after 字段名】;</span><br><span class="line"><span class="number">2</span>).修改列的类型或约束</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 列名 新类型 【新约束】;</span><br><span class="line"><span class="number">3</span>).修改列名</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表名 change <span class="keyword">column</span> 旧列名 新列名 类型;</span><br><span class="line"><span class="number">4</span>).删除列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">column</span> 列名;</span><br><span class="line"><span class="number">5</span>).修改表名(重命名表)</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename 【<span class="keyword">to</span>】 新表名;	</span><br><span class="line">	</span><br><span class="line"># 示例</span><br><span class="line"># 在学生表中添加一列用于显示email（邮箱）	</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> <span class="keyword">column</span> email <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"># 将学生表中的电话号码类型改为<span class="type">int</span></span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> students modify <span class="keyword">column</span> phone <span class="type">int</span>;</span><br><span class="line"># 将学生表中的name列名称改为stu_name</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> students change <span class="keyword">column</span> name stu_name <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"># 将学生表中的email列删除</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> <span class="keyword">column</span> email;</span><br><span class="line"># 将学生表名改为stu_tables</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> students rename <span class="keyword">to</span> stu_tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表 drop table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span>【if <span class="keyword">exists</span>】 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># <span class="number">1</span>)、复制表的结构</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> 表名 <span class="keyword">like</span> 旧表;</span><br><span class="line"># <span class="number">2</span>)、复制表的结构<span class="operator">+</span>数据</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> 表名 </span><br><span class="line">	<span class="keyword">select</span> 查询列表 </span><br><span class="line">	<span class="keyword">from</span> 旧表</span><br><span class="line">	【<span class="keyword">where</span> 筛选】;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"># <span class="number">1</span>)、查看当前库的所有表</span><br><span class="line">	<span class="keyword">show</span> tables;</span><br><span class="line"># <span class="number">2</span>)、查看其它库的所有表</span><br><span class="line">	<span class="keyword">show</span> tables <span class="keyword">from</span> 库名;</span><br><span class="line"># <span class="number">3</span>)、查看表结构</span><br><span class="line">	<span class="keyword">desc</span> 表名</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="②-常见类型"><a href="#②-常见类型" class="headerlink" title="② 常见类型"></a>② 常见类型</h3><ul>
<li><p><strong>数值型</strong></p>
<ul>
<li><p><code>tinyint</code> 、<code>smallint</code> 、<code>mediumint</code> 、<code>int</code> 、<code>bigint</code> 、<code>double(M,D)</code>、 <code>float(M,D)</code>、 <code>decimal(M,D)</code>  </p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/MySQL/20220325215906.png"></p>
</li>
<li><p><strong>整数</strong></p>
<ul>
<li>都可以设置无符号和有符号，默认有符号，通过 unsigned 设置无符号，有符号和无符号占用相同的磁盘空间，并具有相同的性能。</li>
<li>如果超出了范围，会报 out of range 异常，并插入临界值;</li>
<li>长度可以不指定，默认会有一个长度，长度代表显示的最大宽度，如果不够则左边用 0 填充， 但需要搭配 zerofill，并且默认变无符号整型。<strong>注意指定的长度只是用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的 。</strong></li>
<li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型，如只需存 0~200，tinyint unsigned 更好。</li>
</ul>
</li>
<li><p><strong>小数</strong></p>
<ul>
<li>M 代表整数部位 + 小数部位的个数，D 代表小数部位</li>
<li>如果超出范围，则报 out or range 异常，并且插入临界值</li>
<li>M 和 D 都可以省略，但对于定点数，M 默认为 10，D 默认为 0</li>
<li>如果精度要求较高，则优先考虑使用定点数</li>
<li>float 占用 4 字节，double 占用 8 字节</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字符型：</strong></p>
<ul>
<li><code>char</code>、<code>varchar</code>、<code>binary</code>、<code>varbinary</code>、<code>enum</code>、<code>set</code>、<code>text</code>、<code>blob</code></li>
<li><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/MySQL/20220325215937.png"></li>
<li><strong>varchar 用于存储可变长字符串</strong>，它仅使用必要的空间。需要额外适用 1~2 个字节记录字符串的长度，如果列的最大长度小于或等于 255，用 1 个字节记录长度，否则用 2 个字节记录长度。</li>
<li><strong>char 用于存储定长字符串</strong>，适合存储很短的字符串或所有值都接近同一个长度。比如适合存储密码的 MD5值，对于经常变更的数据，char 比 varchar 更好，因为定长的 char 不容易产生碎片，且在存储空间上更有效率（因为 varchar 要额外记录长度）。</li>
<li><strong>Blog 和 Text 用于存储很大的数据</strong>，分别采取二进制和字符方式存储。</li>
</ul>
</li>
<li><p><strong>日期型：</strong></p>
<ul>
<li><code>year </code>年、<code>date</code> 日期、<code>time </code>时间、<code>datetime </code> 日期+时间、<code>timestamp</code> 日期+时间</li>
<li><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/MySQL/20220325215938.png"></li>
<li><strong>timestamp 只占用 datetime 一半的存储空间，但允许的时间范围更小。</strong></li>
</ul>
</li>
</ul>
<h3 id="③-常见约束"><a href="#③-常见约束" class="headerlink" title="③ 常见约束"></a>③ 常见约束</h3><ul>
<li><p>定义</p>
<p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
</li>
<li><p><strong>常见约束</strong></p>
<ul>
<li><code>NOT NULL</code>：非空，表示该字段的值必填。通常情况下，最好指定列为 NOT NULL，除非真的需要存储 NULL 值，如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂。可为 NULL 的列会使用更多的存储空间。</li>
<li><code>UNIQUE</code>：唯一，表示该字段的值不可重复</li>
<li><code>DEFAULT</code>：默认，表示该字段的值如果不插入会有默认值</li>
<li><code>CHECK</code>：检查，mysql 8.0.16 版本后才支持</li>
<li><code>PRIMARY KEY</code>：主键，表示该字段的值不可重复并且非空  unique+not null</li>
<li><code>FOREIGN KEY</code>：外键，表示该字段的值引用了另外的表的字段（弊大于利，有利于数据一致性，但会导致更新一张表还得去查其外键表，慢，而且复杂不利于开发）</li>
</ul>
</li>
<li><p>主键与唯一的区别</p>
<ul>
<li>一个表至多有一个主键，但可以有多个唯一;  </li>
<li>主键不允许为空，唯一可以为空。</li>
</ul>
</li>
<li><p>添加约束有两种时机</p>
<ul>
<li><p>创建表时添加约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段名 字段类型 列级约束,</span><br><span class="line">    字段名 字段类型,</span><br><span class="line">    表级约束</span><br><span class="line">)</span><br><span class="line"># 示例：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    字段名 字段类型 <span class="keyword">not</span> <span class="keyword">null</span>,	    # 非空</span><br><span class="line">    字段名 字段类型 <span class="keyword">primary</span> key,	# 主键</span><br><span class="line">    字段名 字段类型 <span class="keyword">unique</span>,	    # 唯一</span><br><span class="line">    字段名 字段类型 <span class="keyword">default</span> 值,	   # 默认</span><br><span class="line">    <span class="keyword">constraint</span> 约束名 <span class="keyword">foreign</span> key(字段名) <span class="keyword">references</span> 主表（被引用列）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表时添加或删除约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、非空</span><br><span class="line">	# 添加非空</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line">	# 删除非空</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 ;</span><br><span class="line"># <span class="number">2</span>、默认</span><br><span class="line">	# 添加默认</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 <span class="keyword">default</span> 值;</span><br><span class="line">	# 删除默认</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify <span class="keyword">column</span> 字段名 字段类型 ;</span><br><span class="line"># <span class="number">3</span>、主键</span><br><span class="line">	# 添加主键</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">primary</span> key(字段名);</span><br><span class="line">	# 删除主键</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"># <span class="number">4</span>、唯一</span><br><span class="line">	# 添加唯一</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">unique</span>(字段名);</span><br><span class="line">	# 删除唯一</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名;</span><br><span class="line"># <span class="number">5</span>、外键</span><br><span class="line">	# 添加外键</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span>【 <span class="keyword">constraint</span> 约束名】 <span class="keyword">foreign</span> key(字段名) <span class="keyword">references</span> 主表（被引用列）;</span><br><span class="line">	# 删除外键</span><br><span class="line">		<span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 约束名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<ul>
<li><p>表级约束语法：在各个字段的最下面【constraint 约束名】 约束类型(字段名)</p>
<p>特殊：【constraint 约束名】 foreign key(字段名) references 主表（被引用列）</p>
<p>表级约束的 constraint 约束名可省略，如可以直接 primary key(id)</p>
</li>
<li><p>列级约束和表级约束的区别</p>
<p>列级约束除了外键都支持，而且不可以起约束名；表级约束除了非空和默认均支持，并且除了主键均可起约束名称；</p>
</li>
<li><p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自增长列</strong></p>
<p>特点：</p>
<ul>
<li>不用手动插入值，可以自动提供序列值，默认从 1 开始，步长为 1,可以通过下面语句改变步长：<code>set auto_increment_increment=值</code> ;</li>
<li>一个表至多有一个自增长列</li>
<li>自增长列只能支持数值型</li>
<li>自增长列必须为一个 key</li>
</ul>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 一、创建表时设置自增长列</span><br><span class="line">	<span class="keyword">create</span> <span class="keyword">table</span> 表(</span><br><span class="line">		字段名 字段类型 约束 auto_increment</span><br><span class="line">	)</span><br><span class="line"># 二、修改表时设置自增长列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表 modify <span class="keyword">column</span> 字段名 字段类型 约束 auto_increment</span><br><span class="line"># 三、删除自增长列</span><br><span class="line">	<span class="keyword">alter</span> <span class="keyword">table</span> 表 modify <span class="keyword">column</span> 字段名 字段类型 约束 </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-DQL语言的学习【重点】"><a href="#2-DQL语言的学习【重点】" class="headerlink" title="2. DQL语言的学习【重点】"></a>2. DQL语言的学习【重点】</h2><p>编写顺序与执行顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/MySQL/20220325215939.png" alt="image-20220324191158367"></p>
<h3 id="①-基础查询"><a href="#①-基础查询" class="headerlink" title="① 基础查询"></a>① 基础查询</h3><p><u><strong>语法</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表名; </span><br></pre></td></tr></table></figure>

<p><u><strong>特点</strong>：</u></p>
<ul>
<li>通过 select 查询完的结果 ，是一个虚拟的表格，不是真实存在</li>
<li>要查询的东西可以是常量值、可以是表达式、可以是字段、可以是函数</li>
<li>可以没有 from 语句</li>
<li>先执行 from 语句，再执行 select 查询</li>
</ul>
<p><u><strong>示例</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询单个字段</span><br><span class="line">	<span class="keyword">select</span> 字段名</span><br><span class="line">	<span class="keyword">from</span> 表名;</span><br><span class="line"># 查询多个字段</span><br><span class="line">	<span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,...,字段n</span><br><span class="line">	<span class="keyword">from</span> 表名;</span><br><span class="line"># 查询所有字段（查询整个表数据）</span><br><span class="line">	<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">	<span class="keyword">from</span> 表名; # 虽然这种方式比较简单，但是为了提高可读性，建议不使用<span class="operator">*</span>，而是列出所有字段。</span><br><span class="line"># 查询时给字段起别名（<span class="keyword">as</span>）</span><br><span class="line">	<span class="keyword">select</span> 字段<span class="number">1</span> 【<span class="keyword">as</span>】 别名<span class="number">1</span>,字段<span class="number">2</span> 【<span class="keyword">as</span>】 别名<span class="number">2.</span>..</span><br><span class="line">	<span class="keyword">from</span> 表;  # 其中<span class="keyword">as</span>可以省略，直接用空格</span><br><span class="line"># 查询结果去重（<span class="keyword">distinct</span>）</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">distinct</span> 字段</span><br><span class="line">	<span class="keyword">from</span> 表;  </span><br></pre></td></tr></table></figure>

<h3 id="②-条件查询"><a href="#②-条件查询" class="headerlink" title="② 条件查询"></a>② 条件查询</h3><blockquote>
<p>条件查询：根据条件过滤原始表的数据，查询到想要的数据</p>
</blockquote>
<p><u><strong>语法</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">where</span> 筛选条件;</span><br></pre></td></tr></table></figure>

<p><u><strong>特点</strong>：</u></p>
<p>先执行from语句，在执行where语句，最后执行select语句</p>
<p><u><strong>分类</strong>：</u></p>
<ul>
<li><p>条件表达式 </p>
<ul>
<li><p><code>&gt;、&lt; 、&gt;=、 &lt;=、 =、 !=、 &lt;&gt;、 &lt;=&gt;</code> ，安全等于 &lt;&#x3D;&gt; 可以判断 null 值，而 &#x3D; 不能判断 null 值</p>
</li>
<li><p><code>between 值1 and 值2</code> ，筛选所需要的值在值1和值2之间，等同于 &gt;&#x3D;值1 and &lt;&#x3D;值2</p>
</li>
<li><p><code>is null /is not null</code>，用于判断 null 值（也只能判断 null 值）</p>
</li>
<li><p><code>in / not in    </code> ，in是指包含，后面接(值1,值2…)，相当于多个 or，但效率更高</p>
</li>
<li><p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 筛选学生表中：姓名为张三的所有信息。</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>逻辑表达式</p>
<ul>
<li><p><code>and（&amp;&amp;）</code>，两个条件如果同时成立，结果为 true，否则为 false</p>
</li>
<li><p><code>or(||)</code>，两个条件只要有一个成立，结果为true，否则为false</p>
</li>
<li><p><code>not(!)</code>，如果条件成立，则not后为false，否则为true</p>
</li>
<li><p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 示例：筛选学生表中：分数在<span class="number">60</span>和<span class="number">70</span>之间的学生全部信息。</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">and</span> scord<span class="operator">&lt;=</span><span class="number">70</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>模糊查询</p>
<ul>
<li><p><code>like</code> ， 通常搭配通配符使用，%任意多个字符，_任意单个字符（%不能表示null）</p>
</li>
<li><p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 示例：筛选学生表中：姓名第二个字为伟的学生全部信息</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;_伟%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="③-排序查询"><a href="#③-排序查询" class="headerlink" title="③ 排序查询"></a>③ 排序查询</h3><blockquote>
<p>排序查询：对查询的结果按某一字段进行排序。</p>
</blockquote>
<p><u><strong>语法</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序的字段<span class="operator">|</span>表达式<span class="operator">|</span>函数<span class="operator">|</span>别名 【<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>】;</span><br></pre></td></tr></table></figure>

<p><u><strong>特点</strong>：</u></p>
<ul>
<li>可以没有 where 筛选语句</li>
<li>asc 值升序，desc 指降序，如果不写默认为升序</li>
<li><u>排序列表支持单个字段、多个字段、函数、表达式、别名</u></li>
<li>order by 的位置一般放在查询语句的最后（除 limit 语句之外）</li>
<li>先执行 from 语句，再执行 where 语句，然后执行 select，最后执行 order by 排序</li>
</ul>
<p><u><strong>示例</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询学生表中：所有姓张的学生全部信息，并按照考试成绩进行降序排列</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<h3 id="④-常见函数"><a href="#④-常见函数" class="headerlink" title="④ 常见函数"></a>④ 常见函数</h3><p><strong>1) 单行函数</strong></p>
<ul>
<li><p>concat：将多个字段&#x2F;字符进行拼接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：concat(字段/字符1,字段/字符2,...,字段/字符n)</span><br><span class="line"># 示例：查询学生表中：所有学生的姓名和成绩，并显示为一列，格式示范：张三（98分）</span><br><span class="line">	select concat(name,&#x27;(&#x27;,score,&#x27;分)&#x27;) as 姓名（分数）</span><br><span class="line">	from students;	</span><br></pre></td></tr></table></figure>
</li>
<li><p>ifnull：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：ifnull(字段/表达式,指定值)</span><br><span class="line"># 示例：查询学生表中：所有学生的姓名和成绩，并将原来成绩为null（没参加考试）的同学成绩改为0分</span><br><span class="line">	select name,ifnull(score,0)</span><br><span class="line">	from students;</span><br></pre></td></tr></table></figure>
</li>
<li><p>isnull：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：ifnull(字段/表达式)</span><br><span class="line"># 示例：查询学生表中：所有学生的姓名以及是否缺考，如果缺考记为1，否则记为0</span><br><span class="line">	select name,ifnull(score)</span><br><span class="line">	from students;</span><br></pre></td></tr></table></figure>
</li>
<li><p>substr：截取子串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：substr(字段/字符,初始索引,截取字符长度)</span><br><span class="line"># 注意：字符串索引从1开始，而不是从0开始，如果截取字符长度省略，则截取到最后。</span><br><span class="line"># 示例：截取一个字符串的前三个字母</span><br><span class="line">	select substr(&#x27;zhang&#x27;,1,3); #查询结果为zha</span><br></pre></td></tr></table></figure>
</li>
<li><p>length ：获取字节个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：length(字段/字符)</span><br><span class="line"># 注意：获取的是字节个数，而不是字符个数，在utf8编码中，1个汉字为3个字节，1个字母为1个字节。</span><br><span class="line"># 示例：</span><br><span class="line">	select length(&#x27;123张&#x27;); #查询结果为6</span><br></pre></td></tr></table></figure>
</li>
<li><p>instr：返回子串第一次出现的索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：instr(字段/字符,子串)</span><br><span class="line"># 注意：如果字串不在原字符中，则返回0</span><br><span class="line"># 示例：</span><br><span class="line">	select instr(&#x27;123六六456&#x27;,&#x27;六六&#x27;); #查询结果为4</span><br><span class="line">	select instr(&#x27;123六六456&#x27;,&#x27;六六六&#x27;); #查询结果为0</span><br></pre></td></tr></table></figure>
</li>
<li><p>round：四舍五入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：round(数字,保留小数位数)</span><br><span class="line"># 注意：保留小数位数可以不写，那么默认四舍五入为整数。</span><br><span class="line"># 示例：</span><br><span class="line">	select round(4.76,1); #查询结果为4.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>truncate：截断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：truncate(数字，保留小数位数)</span><br><span class="line"># 注意：保留小数位数可以不写，那么默认截断为整数。截断不是四舍五入，而是均舍掉，4.1、4.9截断均为4。</span><br><span class="line"># 示例：</span><br><span class="line">	select truncate(4.76,1); #查询结果为4.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>rand：0-1 之间随机数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：rande()</span><br><span class="line"># 示例：	</span><br><span class="line">	select rand(); #返回一个范围在0-1之间的随机值</span><br></pre></td></tr></table></figure>
</li>
<li><p>floor：向下取整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：floor(数字)</span><br><span class="line"># 注意：返回一个不大于括号中值的最大整数。</span><br><span class="line"># 示例：	</span><br><span class="line">	select floor(4.7); #查询结果为4</span><br></pre></td></tr></table></figure>
</li>
<li><p>ceil：向上取整</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：floor(数字)</span><br><span class="line"># 注意：返回一个不小于括号中值的最大整数。</span><br><span class="line"># 示例：	</span><br><span class="line">	select ceil(4.7); #查询结果为5</span><br></pre></td></tr></table></figure>
</li>
<li><p>mod：取余</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：mod(数1,数2);</span><br><span class="line"># 注意：返回结果为数1除以数2所得的余数。</span><br><span class="line"># 示例：</span><br><span class="line">	SELECT MOD(10,3); #查询结果为1</span><br></pre></td></tr></table></figure>
</li>
<li><p>now：当前系统日期+时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：now();</span><br><span class="line"># 示例：</span><br><span class="line">	SELECT now(); #查询结果为：2020-07-08 16:43:35</span><br></pre></td></tr></table></figure>
</li>
<li><p>curdate：当前系统日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：curdate();</span><br><span class="line"># 示例：</span><br><span class="line">	SELECT curdate(); #查询结果为：2020-07-08</span><br></pre></td></tr></table></figure>
</li>
<li><p>curtime：当前系统时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：curtime();</span><br><span class="line"># 示例：</span><br><span class="line">	SELECT curtime(); #查询结果为：16:45:28</span><br></pre></td></tr></table></figure>
</li>
<li><p>str_to_date：将字符转换成日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：str_to_date(字符,日期格式);</span><br><span class="line"># 注意：%Y是年，%m是月，%d是日，%H是小时，%i是分，%s是秒</span><br><span class="line"># 示例：</span><br><span class="line">	select str_to_date(&#x27;2020-7-8&#x27;,&#x27;%Y-%m-%d&#x27;); #查询结果为：2020-07-08</span><br></pre></td></tr></table></figure>
</li>
<li><p>date_format：将日期转换成字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 语法：date_format(日期,日期格式);</span><br><span class="line"># 注意：%Y是年，%m是月，%d是日，%H是小时，%i是分，%s是秒</span><br><span class="line"># 示例：</span><br><span class="line">	select date_format(&#x27;2020-7-8&#x27;,&#x27;今天是%Y年%m月%d日&#x27;)); #查询结果为：今天是2020年07月08日</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他日期函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select date(now()); #返回日期，结果为：2020-07-08</span><br><span class="line">select year(now()); #返回年，结果为：2020</span><br><span class="line">select month(now()); #返回月</span><br><span class="line">select day(now()); #返回日</span><br><span class="line">select minute(now()); #返回分钟</span><br><span class="line">select second(now()); #返回秒</span><br><span class="line">select datediff(&#x27;2020-08-08&#x27;,&#x27;2020-07-08&#x27;):# 返回两个日期相差的天数，结果为：31</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2）分组函数&#x2F;聚集函数</strong></p>
<p>聚集函数：作用于一组函数，最后返回一个值</p>
<p>分类：<code>sum() </code>求和、<code>min()  </code>最小值、<code>max()  </code>最大值、<code>avg()</code>  平均值、<code>count()</code>  计数</p>
<p>特点：</p>
<ul>
<li>*<em>以上五个分组函数都忽略 null 值，除了count(</em>)**（注意：count(具体字段)会忽略null值）；</li>
<li>sum 和 avg 一般用于处理数值型，max、min、count可以处理任何数据类型；</li>
<li>都可以搭配 distinct 使用，用于统计去重后的结果。</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询学生表中，学生成绩的总和、最小值、最大值、平均成绩以及学生总人数</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(score),<span class="built_in">min</span>(score),<span class="built_in">max</span>(score),<span class="built_in">avg</span>(score),<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>

<h3 id="⑤-分组查询"><a href="#⑤-分组查询" class="headerlink" title="⑤ 分组查询"></a>⑤ 分组查询</h3><blockquote>
<p>分组查询：将查询结果按照1个或多个字段进行分组，字段值相同的为一组。</p>
</blockquote>
<p><u><strong>语法</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询的字段，分组函数</span><br><span class="line"><span class="keyword">from</span> 表</span><br><span class="line">【<span class="keyword">where</span> 分组前的筛选条件】</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组的字段</span><br><span class="line">【<span class="keyword">having</span> 分组后的筛选条件】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序】</span><br></pre></td></tr></table></figure>

<p><u><strong>特点</strong>：</u></p>
<ul>
<li>where 语句、having 语句和 order by 语句可以没有；</li>
<li>可以按单个字段分组，也可以按多个字段分组，字段之间用逗号隔开；</li>
<li>和分组函数一同查询的字段最好是分组后的字段，其他字段没有意义；</li>
<li>分组筛选<ul>
<li><strong>where    在分组前对原始表进行筛选，位于group by的前面，不能对聚合函数进行判断</strong></li>
<li><strong>havng    在分组后对分组后的结果集进行筛选，位于group by的后面，可以对聚合函数进行判断</strong></li>
</ul>
</li>
<li>having 后可以支持别名；</li>
<li>先执行 from，再执行 where，然后执行 group by，having，接着执行 select，最后执行 order by。</li>
</ul>
<p><u><strong>示例</strong>：</u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询学生表中，每个班级的平均分数，并根据此进行降序排列</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(score) <span class="keyword">as</span> 平均分数,grade <span class="keyword">as</span> 班级名</span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> grade</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">avg</span>(score);</span><br></pre></td></tr></table></figure>

<h3 id="⑥-连接查询"><a href="#⑥-连接查询" class="headerlink" title="⑥ 连接查询"></a>⑥ 连接查询</h3><blockquote>
<p>连接查询：所要查询的内容在多个表中，对多个表进行连接后查询<br>笛卡尔乘积：如果连接条件省略或无效则会出现。检索出的行数目等于第一个表中的行数乘以第二个表的行数。<br>解决办法：添加上连接条件</p>
</blockquote>
<p><strong>SQL92语法（了解）：支持内连接（等值连接、非等值连接、自连接）</strong></p>
<ul>
<li><p>等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名,表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">where</span> 表<span class="number">1.</span>key<span class="operator">=</span>表<span class="number">2.</span>key</span><br><span class="line">【<span class="keyword">and</span> 筛选条件】</span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">【<span class="keyword">having</span> 分组后的筛选】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序字段】</span><br></pre></td></tr></table></figure>

<ul>
<li>一般为表起别名；</li>
<li>多表的顺序可以调换；；</li>
<li>n表连接至少需要n-1个连接条件；</li>
<li>等值连接的结果是多表的交集部分。</li>
</ul>
</li>
<li><p>非等值连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询列表</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> 别名,表<span class="number">2</span> 别名</span><br><span class="line"><span class="keyword">where</span> 非等值的连接条件</span><br><span class="line">【<span class="keyword">and</span> 筛选条件】</span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">【<span class="keyword">having</span> 分组后的筛选】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序字段】</span><br></pre></td></tr></table></figure>
</li>
<li><p>自连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表 别名1,表 别名2</span><br><span class="line">where 等值的连接条件</span><br><span class="line">【and 筛选条件】</span><br><span class="line">【group by 分组字段】</span><br><span class="line">【having 分组后的筛选】</span><br><span class="line">【order by 排序字段】</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>SQL99语法（重点）：支持内连接（等值连接、非等值连接、自连接）、外连接（左外、右外、全外）和交叉连接。</strong></p>
<ul>
<li><p><strong>内连接</strong></p>
<p><u><strong>语法：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段，...</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span></span><br><span class="line">【<span class="keyword">inner</span>】 <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span>  连接条件</span><br><span class="line">【<span class="keyword">inner</span>】 <span class="keyword">join</span> 表<span class="number">3</span> <span class="keyword">on</span>  连接条件</span><br><span class="line">...</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】</span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">【<span class="keyword">having</span> 分组后的筛选条件】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段或表达式】</span><br></pre></td></tr></table></figure>

<p><u><strong>特点：</strong></u></p>
<ul>
<li>① 一般为表起别名；</li>
<li>② 多表的顺序可以调换；</li>
<li>③ n 表连接至少需要 n-1 个连接条件；</li>
<li>④ 内连接的结果是多表的交集部分；</li>
<li>⑤ inner 关键字可以省略；</li>
<li>⑥ 先执行 from，再执行 join on，接着 where，之后 group by having，然后 select，最后 order by</li>
</ul>
</li>
<li><p><strong>外连接</strong></p>
<p><u><strong>语法：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段，...</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span><span class="operator">/</span><span class="keyword">full</span> 【<span class="keyword">outer</span>】 <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span>  连接条件</span><br><span class="line"><span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span><span class="operator">/</span><span class="keyword">full</span> 【<span class="keyword">outer</span>】 <span class="keyword">join</span> 表<span class="number">3</span> <span class="keyword">on</span>  连接条件</span><br><span class="line">...</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】</span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">【<span class="keyword">having</span> 分组后的筛选条件】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段或表达式】</span><br></pre></td></tr></table></figure>

<p><u><strong>特点：</strong></u></p>
<ul>
<li>① 查询的结果&#x3D;主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null；</li>
<li>② 多表的顺序很重要，left join 左边的是主表，right join 右边的就是主表，full join 两边都是主表；</li>
<li>③ outer 关键字可以省略</li>
</ul>
</li>
<li><p>交叉连接（不常用，关键字为 cross join）</p>
</li>
</ul>
<h3 id="⑦-子查询"><a href="#⑦-子查询" class="headerlink" title="⑦ 子查询"></a>⑦ 子查询</h3><blockquote>
<p>子查询：一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询</p>
<p>主查询：在外面的查询语句，称为主查询或外查询</p>
</blockquote>
<p><u><strong>特点：</strong></u></p>
<ul>
<li>子查询都放在小括号内；</li>
<li>子查询可以放在 from 后面、select 后面、where 后面、having 后面，但一般放在条件的右侧；</li>
<li>子查询优先于主查询执行，主查询使用了子查询的执行结果；</li>
<li>子查询根据查询结果的行数不同分为以下两类：<ul>
<li>单行子查询（结果集只有一行），一般搭配单行操作符使用：<code>&gt; &lt; = &lt;&gt; &gt;= &lt;= </code><br>  非法使用子查询的情况：子查询的结果为一组值、子查询的结果为空</li>
<li>多行子查询（结果集有多行），一般搭配多行操作符使用：<code>any、all、in、not in</code><br>   一in 是属于子查询结果中的任意一个就行；any 和 all 往往可以用其他查询代替</li>
</ul>
</li>
</ul>
<h3 id="⑧-分页查询"><a href="#⑧-分页查询" class="headerlink" title="⑧ 分页查询"></a>⑧ 分页查询</h3><blockquote>
<p>应用场景：当要查询的条目数太多，一页显示不全</p>
</blockquote>
<p><u><strong>语法：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="operator">|</span>表达式,...</span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span></span><br><span class="line">【连接类型 <span class="keyword">join</span> 表<span class="number">2</span>  <span class="keyword">on</span> 连接条件】</span><br><span class="line">【<span class="keyword">where</span> 条件】</span><br><span class="line">【<span class="keyword">group</span> <span class="keyword">by</span> 分组字段】</span><br><span class="line">【<span class="keyword">having</span> 条件】</span><br><span class="line">【<span class="keyword">order</span> <span class="keyword">by</span> 排序的字段】</span><br><span class="line">limit 【起始的条目索引,】条目数;</span><br></pre></td></tr></table></figure>

<p><u><strong>特点：</strong></u></p>
<ul>
<li>① 起始条目索引从 0 开始，<code>起始索引=(查询页码-1)*每页显示记录数</code>。</li>
<li>② 其实条目索引可以省略，如省略默认为0</li>
<li>③ limit 子句放在查询语句的最后；</li>
<li>④ <strong>先执行 from，再执行 join on，接着 where，再接着 group by having，之后 select，然后 order by，最后limit</strong>。</li>
</ul>
<p><u><strong>示例：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询学生表中，分数位于前五的学生全部信息（假设前五名没有并列排名）</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span></span><br><span class="line">    limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="⑨-联合查询"><a href="#⑨-联合查询" class="headerlink" title="⑨ 联合查询"></a>⑨ 联合查询</h3><blockquote>
<p>union：合并、联合，将多次查询结果合并成一个结果集</p>
</blockquote>
<p><u><strong>语法：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="operator">|</span>常量<span class="operator">|</span>表达式<span class="operator">|</span>函数 【<span class="keyword">from</span> 表】 【<span class="keyword">where</span> 条件】 <span class="keyword">union</span> 【<span class="keyword">all</span>】</span><br><span class="line"><span class="keyword">select</span> 字段<span class="operator">|</span>常量<span class="operator">|</span>表达式<span class="operator">|</span>函数 【<span class="keyword">from</span> 表】 【<span class="keyword">where</span> 条件】 <span class="keyword">union</span> 【<span class="keyword">all</span>】</span><br><span class="line"><span class="keyword">select</span> 字段<span class="operator">|</span>常量<span class="operator">|</span>表达式<span class="operator">|</span>函数 【<span class="keyword">from</span> 表】 【<span class="keyword">where</span> 条件】 <span class="keyword">union</span>  【<span class="keyword">all</span>】</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">select</span> 字段<span class="operator">|</span>常量<span class="operator">|</span>表达式<span class="operator">|</span>函数 【<span class="keyword">from</span> 表】 【<span class="keyword">where</span> 条件】</span><br></pre></td></tr></table></figure>

<p><u><strong>特点：</strong></u></p>
<ul>
<li>① 多条查询语句的查询的列数必须是一致的；</li>
<li>② 多条查询语句的查询的各列类型、顺序最好一致,各列数据类型也可以不一致，但必须兼容(可以隐含转换)；</li>
<li>③ union 代表去重，union all 代表不去重。</li>
</ul>
<p><u><strong>示例：</strong></u></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># （多个表）：假设一班和二班均有一张成绩表，现在要把两张表的信息合并。</span><br><span class="line">    <span class="keyword">select</span> name,score</span><br><span class="line">    <span class="keyword">from</span> grade1</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> name,score</span><br><span class="line">    <span class="keyword">from</span> grade2;</span><br><span class="line"></span><br><span class="line"># （一个表）：查询学生表中：成绩大于<span class="number">90</span>或者姓赵的同学的全部信息（要求用<span class="keyword">union</span>不用<span class="keyword">or</span>）</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> score<span class="operator">&gt;</span><span class="number">90</span></span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> students</span><br><span class="line">    <span class="keyword">where</span> name <span class="keyword">like</span>(<span class="string">&#x27;赵%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-DML语言的学习【重点】"><a href="#3-DML语言的学习【重点】" class="headerlink" title="3. DML语言的学习【重点】"></a>3. DML语言的学习【重点】</h2><h3 id="①-插入"><a href="#①-插入" class="headerlink" title="① 插入"></a>① 插入</h3><p>在表中插入数据，有两种方式。</p>
<ul>
<li><p><u><strong>方式一(重点)：</strong></u></p>
<p><u><strong>语法</strong></u>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段<span class="number">1</span>,...)</span><br><span class="line"><span class="keyword">values</span>(值<span class="number">1</span>,...);</span><br></pre></td></tr></table></figure>

<p><u><strong>特点</strong></u>：</p>
<ul>
<li>① 字段类型和值类型一致或兼容，而且一一对应；</li>
<li>② 字段的个数和顺序不一定与原始表中的字段个数和顺序一致，但必须保证值和字段一一对应；</li>
<li>③ 字段可以省略，默认为所有字段，并且顺序和表中的存储顺序一致；</li>
<li>④ 不可以为空的字段，必须插入值；</li>
<li>⑤ 假如表中有可以为null的字段，注意可以通过以下两种方式插入null值：字段和值都省略&#x2F;字段写上，值使用null。</li>
</ul>
</li>
<li><p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名</span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,...,字段n<span class="operator">=</span>值n;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式一优点：</p>
<ul>
<li><p>方式一<strong>支持一次插入多行</strong>，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名【(字段名,..)】 </span><br><span class="line"><span class="keyword">values</span>(值，..),(值，...),...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式一支持子查询，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在学生表中插入一条学生信息，学号：<span class="number">8</span>，姓名：李四，班级：<span class="number">2</span>，姓别：男，成绩：<span class="number">88</span>，电话：<span class="number">123456789</span></span><br><span class="line"># 方式一</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> students(id,name,grade,gender,score,phone)</span><br><span class="line">    <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">88</span>,<span class="string">&#x27;123456789&#x27;</span>); </span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> students</span><br><span class="line">	<span class="keyword">set</span> id<span class="operator">=</span><span class="number">8</span>,name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>,grade<span class="operator">=</span><span class="number">2</span>,gender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>,score<span class="operator">=</span><span class="number">88</span>,phone<span class="operator">=</span><span class="string">&#x27;123456789&#x27;</span>; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="②-修改"><a href="#②-修改" class="headerlink" title="② 修改"></a>② 修改</h3><p>**<u>语法</u>**：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 </span><br><span class="line"><span class="keyword">set</span> 字段<span class="number">1</span><span class="operator">=</span>新值<span class="number">1</span>,字段<span class="number">2</span><span class="operator">=</span>新值<span class="number">2</span>,...</span><br><span class="line">【<span class="keyword">where</span> 条件】</span><br></pre></td></tr></table></figure>

<p>**<u>特点</u>**：</p>
<p>如果没有where筛选条件，则会更改表中所有行。</p>
<p><u><strong>示例</strong></u>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在学生表中修改李四的成绩为90分</span><br><span class="line">	update students</span><br><span class="line">	set score=90</span><br><span class="line">	where name=&#x27;李四&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="③-删除"><a href="#③-删除" class="headerlink" title="③ 删除"></a>③ 删除</h3><p>删除表中数据，有两种方式。</p>
<ul>
<li><p><strong>方式一(重点)：<code>delete</code>语句</strong></p>
<p>**<u>语法</u>**：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名</span><br><span class="line">【<span class="keyword">where</span> 筛选条件】;</span><br></pre></td></tr></table></figure>

<p>**<u>特点</u>**：</p>
<ul>
<li>① 如果没有 where 筛选条件，则会删除表中所有行；</li>
<li>② delect 删除的是表中的一行，而不是整个表，也不是一行中的某一个数据。</li>
</ul>
</li>
<li><p>方式二：<code>truncate table</code> 语句</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>① truncate table 不能删除某一行，而是删除表中所有数据；</li>
<li>② truncate table 语句删除效率更高，其实质是删除原来的表，然后重建了新表，而不是逐行删除表数据。</li>
</ul>
</li>
<li><p>二者区别</p>
<ul>
<li>truncate table 不能加 where条件，而 delete 可以加 where 条件</li>
<li>truncate table 删除带自增长的列的表后，如果再插入数据，数据从 1 开始，delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始。</li>
<li>truncate table 删除不能回滚，delete 删除可以回滚</li>
</ul>
</li>
<li><p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在学生表中删除李四的信息</span><br><span class="line"># 只能用方式一，不能用方式二</span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">from</span> students</span><br><span class="line">	<span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">	</span><br><span class="line"># 删除学生表中全部信息	</span><br><span class="line"># 方式<span class="number">1</span></span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">from</span> students;</span><br><span class="line"># 方式<span class="number">2</span></span><br><span class="line">	<span class="keyword">truncate</span> <span class="keyword">table</span> students;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-DCL语言的学习【重点】"><a href="#4-DCL语言的学习【重点】" class="headerlink" title="4. DCL语言的学习【重点】"></a>4. DCL语言的学习【重点】</h2><blockquote>
<p>事务：一条或多条 sql 语句组成一个执行单位，这一组sql语句要么都执行，要么都不执行；</p>
</blockquote>
<p>事务的特点：（ACID）</p>
<ul>
<li><strong>原子性（Atomicity）</strong>：<u>一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；</u>如果事务中一个 sql 语句执行失败，那么已执行的语句也会回滚，数据库退回到事务前的状态，就像这个事务从来没有执行过一样，也就是说，对于一个事务而言，不可能只执行其中的一部分操作。</li>
<li><strong>一致性（Consistency）：</strong>事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li>
<li><strong>隔离性（Isolation）：</strong><u>数据库允许多事务并发对其数据进行读写和修改，一个事务的执行不受另外一个事务的干扰，通常来说，一个事务所做的修改在最终提交之前，对其他事务时不可见的（但是具体也要看隔离级别的设置状态）</u>。</li>
<li><strong>持久性（Durability ）：</strong><u>事务一旦提交后，对数据的修改就是永久的</u>，即便系统故障也不会丢失。</li>
</ul>
<p>事务的使用步骤：</p>
<ul>
<li><p>隐式事务：没有明显的开启和结束事务的标志，本身就是一条事务可以自动提交，比如 insert、update、delete</p>
</li>
<li><p>显示事务：具有明显的开启和结束事务的标志.</p>
<ul>
<li><p><code>set autocommit=0; </code>取消自动提交事务的功能，</p>
<p>MySQL 默认采用自动提交模式，也就是说，如果不显示地开始开始一个事务，则每个查询都会被当作一个事务执行提交操作。</p>
</li>
<li><p>开启事务<br><code>start transaction;</code></p>
</li>
<li><p>编写事务的一组逻辑操作单元（多条sql语句）<br>支持 insert、update、delete语句<br>【savepoint 回滚点名;】 &#x2F;&#x2F; 设置回滚点，可以没有</p>
</li>
<li><p>提交事务或回滚事务<br><code>commit; </code>提交、<code>rollback;</code> 回滚、<code>rollback to 回滚点名</code>;</p>
</li>
</ul>
</li>
</ul>
<p>事务的并发问题：</p>
<ul>
<li><strong>脏读：</strong>事务 A 访问数据时，读取到了事务 B 修改了但尚未提交的数据。（事务 B 没有提交，可能提交成功，但也有可能回滚）</li>
<li><strong>不可重复读：</strong>事务 A 在访问数据时，由于事务 B 对数据进行了<strong>修改</strong>，使得事务 A 多次读取到的数据不一致。（违反了事务的一致性）</li>
<li><strong>幻读：</strong>事务 A 读取某个范围内的数据时，事务 B 在该范围内进行了<strong>插入或删除</strong>，导致事务A再次读取该范围的记录时，会产生幻行。</li>
</ul>
<p>如何避免事务的并发问题？（设置隔离级别）</p>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read uncommitted（读未提交）</td>
<td align="center">可能发生</td>
<td align="center">可能发生</td>
<td align="center">可能发生</td>
</tr>
<tr>
<td align="center">read committed（读已提交）</td>
<td align="center">不可能发生</td>
<td align="center">可能发生</td>
<td align="center">可能发生</td>
</tr>
<tr>
<td align="center">repeatable read（可重复读，默认）</td>
<td align="center">不可能发生</td>
<td align="center">不可能发生</td>
<td align="center">可能发生</td>
</tr>
<tr>
<td align="center">serializable（串行化）</td>
<td align="center">不可能发生</td>
<td align="center">不可能发生</td>
<td align="center">不可能发生</td>
</tr>
</tbody></table>
<p>注意：<strong>事务隔离级别越高，性能越差</strong>。</p>
<p>设置隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set session|global  transaction isolation level 隔离级别名;</span><br></pre></td></tr></table></figure>
<p>查看隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation; # mysql默认的隔离级别是repeatable read（可重复读）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ进阶知识</title>
    <url>/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-消息可靠性"><a href="#1-消息可靠性" class="headerlink" title="1. 消息可靠性"></a>1. 消息可靠性</h1><p>可靠性是评估消息队列优劣的一个重要标准之一，在一些核心业务，尤其是一些涉及到 money 方面的一些业务中，可靠性至关重要！消息队列在传递消息的过程中要保证消息的不丢失。在消息的传递过程中，涉及到生产者、RabbitMQ和消费者，那么消息可能在哪些情况下丢失呢？主要有以下三个方面：</p>
<span id="more"></span>

<ul>
<li><strong>消息在生产者到 RabbitMQ 的传递之间丢失。</strong></li>
<li><strong>RabbitMQ 宕机，导致消息丢失。</strong></li>
<li><strong>消费者发生异常，导致消息丢失。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220224.png" alt="image-20220319100542408" style="zoom: 80%;" />

<p>相对应的解决方案如下：</p>
<ul>
<li>生产者丢失消息<ul>
<li>开启 RabbitMQ 事务（同步）</li>
<li>开启 confirm 机制（异步，推荐）</li>
</ul>
</li>
<li>RabbitMQ 丢失消息：开启 RabbitMQ 持久化</li>
<li>消费者丢失消息：采用 ack 机制。</li>
</ul>
<h2 id="1-1-生产者丢失消息"><a href="#1-1-生产者丢失消息" class="headerlink" title="1.1 生产者丢失消息"></a>1.1 生产者丢失消息</h2><blockquote>
<p>在生产者将消息投递给消息队列时，可能出现以下问题：</p>
<ol>
<li>外界环境问题导致：发生<u>网络丢包、网络故障</u>等造成消息丢失。</li>
<li>代码层面，配置层面，考虑不全导致消息丢失，比如<u>发送给不存在的交换器、发送给路由不到的队列。</u></li>
</ol>
</blockquote>
<p>一般来说，可采用以下两个方案解决消息丢失问题：</p>
<p><strong>事务机制</strong></p>
<ul>
<li>RabbitMQ 提供了事务功能，生产者发送数据之前开启 RabbitMQ 事务 <code>channel.txSelect()</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，中间出现了某些问题，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback()</code> ，重新发送消息；如果 RabbitMQ 收到了消息，那么可以提交事务 <code>channel.txCommit()</code> 。</li>
<li>优点在于事务操作可以保证消息一定能够发送到RabbitMQ中，发送端不会出现消息丢失的情况；</li>
<li>缺点在于事务机制是阻塞（同步）的，每次发送消息必须要等到mq回应之后才能继续发送消息，<u>生产者生产消息的吞吐量和性能都会大大降低。</u></li>
</ul>
<p><strong>confirm 机制（推荐）</strong></p>
<ul>
<li><p>由于事务操作会大大降低生产者的性能，RabbitMQ 提供了一种<code>confirm</code>机制来避免消息发送给 MQ 的过程中出现丢失情况，并且这种机制是『异步的』，<u>在发送完一个消息后可以继续发送下一个消息，MQ 接收到消息后会异步回调接口告知消息接收结果</u>，克服了事务『同步』所固有的缺点。</p>
</li>
<li><p>具体而言，生产者开启 <code>confirm</code> 机制后，为每个消息指定一个唯一的id，如果消息成功发送到了 MQ 中，那么 MQ 就会返回 一个 <strong>ack</strong> 消息，表示消息接收成功，反之会返回一个 <strong>nack</strong> 消息，表示消息接收失败，可以进行重试。依据这个机制，我们可以维护每个消息 id 的状态，如果超过一定时间还是没有接收到 MQ 的回调，那么就重发消息。</p>
</li>
<li><p>在 SpringBoot 配置文件中，配置以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启消息到达exchange的回调，发送成功失败都会触发回调</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span>	<span class="comment"># 开启消息从exhcange路由到queue的回调，只有路由失败时才会触发回调</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span>	<span class="comment"># 如果exchange根据routingKey将消息路由到queue时找不到匹配的queue，触发return回调，为false时，exchange直接丢弃消息。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>publisher-confirm-type  </code>可以设置为三种类型：simple、correlated,、none;</p>
<ul>
<li>NONE 值是禁用发布确认模式，默认值。</li>
<li>CORRELATED 值是<strong>发布消息成功&#x2F;失败到交换器后会触发回调方法 ConfirmCallback</strong>。</li>
<li>SIMPLE 值是同步等待 confirm 结果，直到超时。</li>
</ul>
<p>我们可以在 RabbitTemplate 配置 ConfirmCallBack 回调函数，用于接收 MQ 返回的回调信息。可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发消息。</p>
</li>
<li><p><code>publish-returns</code>：开启消息<strong>从交换机到队列的回调</strong>，只有路由失败时才会触发回调。我们可以在 RabbitTemplate 配置 ReturnCallback 回调函数。</p>
</li>
<li><p><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</p>
</li>
<li><p>总结：</p>
<ul>
<li>消息正确到达<u>交换机</u>，触发ConfirmCallback 回调，返回 ack，消息没有正确到达交换机，触发ConfirmReturnCallback 回调，返回 nack，并带有异常信息（比如交换机不存在）；</li>
<li>当消息正确发送交换机后，如果消息正确的从交换机路由到<u>队列</u>，不触发 ReturnCallback 回调，而消息没有正确的从交换机路由到队列，在设置 mandory&#x3D;true 的情况下，触发 ReturnCallback 回调（比如队列不存在）；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;exchange-name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 配置ConfirmCallBack 回调函数</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消息&#123;&#125;接收成功&quot;</span>,correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;消息&#123;&#125;接收失败，原因&#123;&#125;&quot;</span>,correlationData.getId(),cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 2.配置ReturnCallback 回调函数</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey)-&gt;&#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息&#123;&#125;发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;&quot;</span>,message.toString(),replyCode,replyText,exchange,routingKey);</span><br><span class="line">        &#125;);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3.发送消息，注意每个消息要指定一个唯一的id</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">            rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;&quot;</span>,<span class="string">&quot;消息==&gt;&quot;</span>+i,correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：事务机制和确认机制二者不能共存！</p>
<h2 id="1-2-RabbitMQ-丢失消息"><a href="#1-2-RabbitMQ-丢失消息" class="headerlink" title="1.2 RabbitMQ 丢失消息"></a>1.2 RabbitMQ 丢失消息</h2><blockquote>
<p>RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的。如果消息已经由生产者传递到了 RabbitMQ 的队列中，而消费者还没来得及消费时，RabbitMQ 意外宕机，此时消息就会丢失。</p>
</blockquote>
<p>解决方法就是<strong>开启 RabbitMQ 持久化功能</strong>。消息到达队列后，将其持久化到磁盘中，那么即使 RabbitMQ 意外宕机了，也能在重启后自动从磁盘中读取数据，恢复原始消息。</p>
<p>持久化分为以下三个步骤：</p>
<ol>
<li><p><strong>交换机设置持久化。</strong></p>
<p>SpringAMQP 中可以通过以下代码指定交换机持久化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 声明的交换机都是持久化的，不用特意指定。</p>
</li>
<li><p><strong>队列设置持久化。</strong></p>
<p>SpringAMQP 中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 声明的队列都是持久化的，不用特意指定。</p>
</li>
<li><p><strong>消息设置持久化。</strong></p>
<p>利用 SpringAMQP 发送消息时，可以设置消息的属性（MessageProperties），指定 delivery-mode：</p>
<ul>
<li>1 代表非持久化（NON_PERSISTENT）</li>
<li>2 代表持久化（PERSISTENT）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDurableMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello, spring&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 2.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 发出的消息都是持久化的，不用特意指定。</p>
</li>
</ol>
<p>注意：即使 RabbitMQ 开启了持久化机制，也<u>存在丢失数据的一种可能</u>，即消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。解决方案是持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code> ，那么生产者也可以重发消息。</p>
<h2 id="1-3-消费者丢失消息"><a href="#1-3-消费者丢失消息" class="headerlink" title="1.3 消费者丢失消息"></a>1.3 消费者丢失消息</h2><blockquote>
<p>如果消费者收到消息后没来得及处理或者在处理过程中出现了异常（比如重启或断电等），此时消费者进程挂掉了，而 RabbitMQ 不知道消费者挂掉了，以为消息已经成功被消费了，就会从队列中删除消息，从而导致消息丢失。</p>
</blockquote>
<p>解决方法是<strong>采用 RabbitMQ 提供的 ack 确认机制</strong>。当消费者获取消息后，需要向 RabbitMQ 发送 <code>ack</code> 回执，表明自己已经处理消息。没有收到 ACK 的消息，消费者断开连接后，RabbitMQ 会把这条消息发送给其他消费者。如果没有其他消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑。其中 <code>ack</code> 在 AMQP 中有三种确认模式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  <span class="comment"># none，关闭ack；manual，手动ack；auto：自动ack</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>manual</strong>：手动 ack，需要在业务代码结束后，调用 api （basicAck&#x2F;basicNack ）发送 ack&#x2F;nack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;queue-name&#125;&quot;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收消息过程中出现异常，执行nack&quot;</span>);</span><br><span class="line">            <span class="comment">// 第三个参数为true表示异常消息重新返回队列，会导致一直在刷新消息，且返回的消息处于队列头部，影响后续消息的处理</span></span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>auto</strong>：自动 ack（默认），由 spring 监测 listener 代码是否出现异常，没有异常则返回 ack，反之返回 nack。</p>
<p>注意：如果消费者执行异常的话，就相当于执行了 nack 方法，消息会requeue（重新入队）到队列头部，然后再次发送给消费者，但是可能消费者继续出现异常，周而复始，消息会被无限期的执行，从而导致后续的消息无法消费。发生这种原因所在便是因为 RabbitMQ的<code>消息失败重试机制</code>。但是在很多情况下，我们并不想无限重试，而是重试到一定阈值后，就认为此消息无法被正确处理，就放弃处理或专用人工处理等。</p>
<p>为了解决这一问题，我们可以在配置文件中对 RabbitMQ 的消息重试（retry）进行重新配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  	<span class="comment"># 消费者自动ack消息确认</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>            	<span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span>  	<span class="comment"># 初始失败重试间隔</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">3</span>				<span class="comment"># 失败的等待时长配置，下次重试间隔= multiplier * initial-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">4</span>   		<span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li>RejectAndDontRequeueRecoverer：（默认）重试耗尽后，直接 reject，丢弃消息。</li>
<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回 nack，消息重新入队</li>
<li>RepublishMessageRecoverer：（推荐）重试耗尽后，将失败消息投递到指定的交换机</li>
</ul>
<p>可以看出前两种实现都不太好，推荐第三种方式，当重试几次后，仍然得不到好的处理，就将无法被正确处理的消息投递到指定的交换机中，然后在存储到专门用于存储异常消息的队列中，后续可采取人工方式进行集中处理！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220215.png" alt="image-20220319155905258" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常消息的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常消息的队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定异常交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorMessageBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorMessageExchange()).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置失败消息投递到指定的交换机和Routing key</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>none</strong>：关闭 ack，MQ 在消息投递后会立即删除消息。</p>
</li>
</ul>
<h1 id="2-消息有效期"><a href="#2-消息有效期" class="headerlink" title="2. 消息有效期"></a>2. 消息有效期</h1><p>默认情况下，RabbitMQ中的消息是不会过期的，即使消息没被消费掉，也会一直存储在队列中。</p>
<h2 id="2-1-TTL"><a href="#2-1-TTL" class="headerlink" title="2.1 TTL"></a>2.1 TTL</h2><p>如果我们想给消息指定一个有效时间，那么通过指定TTL（<strong>Time-To-Live，即存活时间</strong>）来实现，当消息在队列中的存活时间超过指定的 TTL 时（注意是从入队时开始算），这个消息就会被清除。</p>
<p>RabbitMQ 支持以下两种方式设置 TTL：</p>
<ul>
<li><p>在声明队列时，<u>指定此队列中消息的有效期</u>，那么所有进入该队列的消息都会有一个相同的有效期。</p>
<p><u>当消息过期了就会被立马删除</u>，因为消息进入 RabbitMQ 后是存在一个消息队列中，队列的头部是最早要过期的消息，所以 RabbitMQ 只需要一个定时任务，从头部开始扫描是否有过期消息，有的话就直接删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定队列中消息的有效期，下面两种方式均可以</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;ttl.queue&quot;</span>)</span><br><span class="line">        .ttl(<span class="number">10000</span>)  <span class="comment">// 指定队列中消息的过期时间为10s</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;ttl.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在发送消息时，<u>指定此消息的有效期</u>，那么不同的消息就具有不同的有效期。</p>
<p><u>当消息过期后并不会立马被删除</u>，而是当消息要投递给消费者的时候才会去删除，因为每条消息的过期时间都不一样，想要知道哪条消息过期，必须要遍历队列中的所有消息才能实现，当消息比较多时这样就比较耗费性能，因此针对这种情况，消息要投递给消费者的时候才去删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定消息的有效期</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello TTL message&quot;</span>.getBytes())</span><br><span class="line">    .setExpiration(<span class="string">&quot;10000&quot;</span>)  <span class="comment">// 设置消息的过期时间为10s</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果两种方式 TTL 同时指定，会以时间短的为准。</p>
<h2 id="2-2-死信交换机"><a href="#2-2-死信交换机" class="headerlink" title="2.2 死信交换机"></a>2.2 死信交换机</h2><p>当一个消息过期后，它实际上会成为一个死信(dead-lettered)，不仅如此，以下几种情况均会使得消息成为死信：</p>
<ul>
<li><p>消费者拒收消息（basic.reject&#x2F;basic.nack）并且没有重新入队 requeue&#x3D;false。</p>
</li>
<li><p>消息 TTL 过期</p>
</li>
<li><p>队列达到最大长度，已经堆积满了，最早的消息被丢弃</p>
</li>
</ul>
<p>当一个消息成为死信时：</p>
<ol>
<li><p>如果当前队列配置了<code>dead-letter-exchange</code> 属性，指定了一个死信交换机（Dead-Letter-Exchange，DLX），那么它就会被投递到这个交换机中，之后发送到绑定死信交换机的死信队列中。</p>
<p>可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性（注意和消费者消息重试的 RepublishMessageRecoverer 区分）。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220210.png" alt="image-20220319171652756" style="zoom:80%;" />
</li>
<li><p>如果当前队列没有指定交换机，这个消息就会被丢弃。</p>
</li>
</ol>
<p>实际上，DLX 本身就是一个普通交换机，我们可以为任意队列指定 DLX，当该队列中存在死信时，RabbitMQ 就会自动的将这个死信投递到 DLX 上去，进而被路由到死信队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置死信交换机和死信队列</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机、队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机、队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dl_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信的交换机、队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dlExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(DL_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;dlQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DL_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明正常的交换机、队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;normalExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">normalExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(NORMAL_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;normalQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正常队列绑定死信交换机</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DL_EXCHANGE); <span class="comment">// x-dead-letter-exchange：死信交换机的名称</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;dl.message&quot;</span>); <span class="comment">// x-dead-letter-routing-key：死信交换机的路由键,注意这个key要能够使得死信交换机和死信队列之间绑定的key生效</span></span><br><span class="line">        params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>); <span class="comment">// 设置过期时间</span></span><br><span class="line">        params.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">10</span>); <span class="comment">// 设置队列的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(NORMAL_QUEUE).withArguments(params).build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         // 下面方式也可以</span></span><br><span class="line"><span class="comment">         return QueueBuilder.durable(NORMAL_QUEUE) // 指定队列名称，并持久化</span></span><br><span class="line"><span class="comment">        	.ttl(10000) // 设置队列的超时时间，10秒</span></span><br><span class="line"><span class="comment">        	.deadLetterExchange(DL_EXCHANGE) // 指定死信交换机</span></span><br><span class="line"><span class="comment">        	.build();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常队列和正常交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;normalQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;normalExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;normal.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列和死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;dlQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;dlExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dl.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-延迟队列"><a href="#3-延迟队列" class="headerlink" title="3. 延迟队列"></a>3. 延迟队列</h1><blockquote>
<p>延迟队列是⼀种带有延迟功能的消息队列， 生产者将消息发送到消息队列服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某⼀个时间投递到消费者进行消费，该消息即定时消息。</p>
</blockquote>
<p>我们经常在业务中需要用到延迟功能，比如：</p>
<ul>
<li>比如在电商交易中，当用户下单后，需要在 30 分钟之内付款，否则订单将被自动取消。</li>
<li>在会议预定成功后，会在会议开始前几分钟通知所有预定该会议的用户。</li>
<li>用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。</li>
<li>…</li>
</ul>
<p>RabbitMQ默认没有延迟队列，但可以通过以下两种方式实现延迟队列：</p>
<ul>
<li>死信队列 + TTL</li>
<li>官方插件 <strong><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq-delayed-message-exchange</a></strong></li>
</ul>
<h2 id="3-1-死信队列-TTL"><a href="#3-1-死信队列-TTL" class="headerlink" title="3.1 死信队列 + TTL"></a>3.1 死信队列 + TTL</h2><p>我们在前面已经介绍过死信队列和 TTL 的概念与用法，通过这两个东西我们可以巧妙的实现延迟队列功能。基本思想是：</p>
<ul>
<li>给一个设置有 TTL 的队列 Q1 指定一个死信交换机 DLX。</li>
<li>让一个死信队列 Q2 绑定此死信交换机 DLX。</li>
<li>对于Q1，我们不添加任何消费者对其进行消费，那么一旦生产者发送消息投递到 Q1 中后，由于没有消费者进行消费，那么消息一定会超时，从而会被投递到 DLX，从而被投递到 Q2中，我们设置消费者用于对 Q2 进行消费，此时就实现了生产者与消费者之间消息的延迟接收。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220203.png" alt="image-20220319175550818" style="zoom:80%;" />

<h2 id="3-2-官方插件"><a href="#3-2-官方插件" class="headerlink" title="3.2  官方插件"></a>3.2  官方插件</h2><p>因为延迟队列的需求非常多，所以 RabbitMQ 的官方也推出了一个 DelayExchange 插件，用于支持延迟队列效果。通过安装插件，自定义交换机，让交换机拥有延迟发送消息的能力，从而实现延迟消息。</p>
<p>与死信队列 + TTL 实现延迟队列的方式相比：</p>
<ul>
<li>延迟插件方式只需创建一个交换机和一个队列，而死信队列方式需要创建两个交换机（死信队列交换机+处理队列交换机）、两个队列（死信队列+处理队列）。</li>
<li>死信队列的方式不需要格外安装任何内容，而延迟插件需要额外下载插件并安装。</li>
<li>延迟交换机主要是变更了消息存储的维度到交换机，但是假如消息正在交换机中存储，但是还未路由到队里中，一旦服务宕机，延迟交换机中存储的消息直接就丢失了。只适用于对于数据少量丢失容忍性比较强的业务场景。</li>
</ul>
<p>延迟插件开源地址为：<a href="https://github.com/rabbitmq/rabbitmq-delaed-message-exchange">https://github.com/rabbitmq/rabbitmq-delaed-message-exchange</a></p>
<p>选择合适的版本，我的 RabbitMQ 版本为3.8.15，那么插件可以选择<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9">3.8.9版本</a>，然后下载 .ez文件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220200.png" alt="image-20220319214015332" style="zoom:80%;" />

<p>将.ez文件传到服务器，并复制到 docker 容器内部</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">cp</span> rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez rabbitmq_study:/plugins</span><br><span class="line"><span class="comment"># 这里的rabbitmq_study是我的rabbitmq容器的名称（按自己的名称来），也可以用容器id代替</span></span><br></pre></td></tr></table></figure>

<p>进入 rabbitmq 容器内部，并启动插件功能</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it rabbitmq_study /bin/bash</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p>此时我们在 RabbitMQ 的管理页面创建交换机时，就会发现多了一个 <code>x-delayed-message</code> 类型。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220153.png" alt="image-20220319214751218" style="zoom:80%;" />

<p>从名称上就可以看出 <code>rabbitmq-delaed-message-exchange</code>实际上是针对交换机做的延迟，而不是队列，其原理。当我们发送消息到类型为 <code>x-delayed-message</code> 的交换机时，此交换机会有以下处理步骤：</p>
<ol>
<li>接收消息</li>
<li>判断消息 header 中是否具备 x-delay 属性，如果有 x-delay 属性，说明是延迟消息，则将持久化到硬盘，并读取 x-delay 值，作为延迟时间。如果没有就按正常消息处理。</li>
<li>当 x-delay 时间到期后，再将消息投递到指定队列，实现消息的延迟发送。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建延迟交换机</span></span><br><span class="line"><span class="comment">// 方式1：注解的方式，将delayed属性设置为true即可</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayExchange</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到了delay.queue的延迟消息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：Bean的方式设置 delayed属性为true即可</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(RDELAYED_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">     directExchange.setDelayed(<span class="literal">true</span>);</span><br><span class="line">     <span class="keyword">return</span> directExchange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者发送消息，注意需要在请求头中设置消息的延迟时间</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody((<span class="string">&quot;hello Delay Exchange&quot;</span>).getBytes(<span class="string">&quot;UTF-8&quot;</span>)).setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>).build();</span><br></pre></td></tr></table></figure>

<h1 id="4-消息堆积"><a href="#4-消息堆积" class="headerlink" title="4. 消息堆积"></a>4. 消息堆积</h1><blockquote>
<p><strong>消息堆积</strong>是指当生产者发送消息的速度大于消费者处理消息的速度，不可避免的会导致队列中消息越来越多，不断堆积，直到队列存储到达上限。</p>
</blockquote>
<p>针对于消息堆积，一般的解决方案为：</p>
<ol>
<li>排查消费者内部逻辑，分析出性能瓶颈（比如消费者可能出现异常宕机了），并且可以采取<u>多线程</u>形式提升消息处理速度。</li>
<li>增加<u>多个消费者</u>，从而增加处理速度。</li>
<li>扩大队列的容量，提升存储上限。</li>
<li>惰性队列。</li>
</ol>
<p>惰性队列与普通队列的区别：</p>
<ul>
<li><strong>普通队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。</strong>即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</li>
<li><strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>。它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。<ul>
<li>lazy queue 消息不持久化 ， 但是这种模式还是会把消息放到硬盘里，RAM的使用率会一直很稳定，但是重启后一样会丢失消息。</li>
<li>lazy queue 消息持久化，这种方式无疑是最佳搭配，消息放到硬盘并且不会因为服务器重启而丢失，面对高并发也是从容不已。</li>
</ul>
</li>
<li>惰性队列减少了内存的消耗，但会增加 I&#x2F;O 的使用，相当于以<strong>空间换时间</strong>，当然惰性队列的发送速度不一定比普通队列慢，尤其在高并发场景下可能比普通队列还快，原因是普通队列会由于内存不足而不得不将消息换页至磁盘。</li>
</ul>
<p>在队列声明的时候可以通过<code>x-queue-mode</code>参数来设置队列的模式，取值为『default』和『lazy』，其中 lazy 就是定义惰性队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Springboot 声明队列为LazyQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">        .lazy()  <span class="comment">// 惰性队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;lazy.queue&quot;, durable = &quot;true&quot;,arguments = @Argument(name = &quot;x-queue-mode&quot;,value = &quot;lazy&quot;)),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;lazy.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;lazy&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到了lazy.queue的延迟消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-消费端限流"><a href="#5-消费端限流" class="headerlink" title="5. 消费端限流"></a>5. 消费端限流</h1><blockquote>
<p>在业务高峰时期，可能会出现生产者发送消息的速度远超消费者处理消息的速度的情况，比如双十一时，大量的订单涌入，此时消息队列就会囤积大量的消息，而<u>如果此时消费者一次取出大量的消息， 但是又无法同时处理这么多消息， 就可能导致服务崩溃， 所以需要对消费端进行限流。</u></p>
</blockquote>
<p>RabbitMQ 提供了一种 <strong>qos</strong> （服务质量保证）功能，<strong>在手动确认消息的前提下</strong>，如果指定 Qos 数目的消息没有被确认前，不会消费新的消息。</p>
<p>可以在 springboot 配置类中配置 <code>prefetch=n</code>，此值表示消费端每次从 MQ 拉 n 条消息消费，直到手动确认消费完毕后，才会继续拉去下一条消息。比如将 perfetch 设置为1000，那么一次拉 1000 条消息，等待手动确认后，再拉取 1000 条消息，就可以实现消息的削峰限流。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span>  <span class="comment"># 手动确认消息</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1000</span>	<span class="comment"># 一次最多取消息的个数</span></span><br></pre></td></tr></table></figure>

<h1 id="6-幂等性（消息重复消费）"><a href="#6-幂等性（消息重复消费）" class="headerlink" title="6. 幂等性（消息重复消费）"></a>6. 幂等性（消息重复消费）</h1><blockquote>
<p> 消息的幂等性是指对于同一个系统，在同样条件下，<strong>一次请求和重复多次请求对资源的影响是一致的</strong>，不会因为多次点击而产生了副作用。</p>
</blockquote>
<p>生活中常见要求幂等性的场景如：</p>
<ol>
<li>用户支付时，一笔订单应当只能扣一次钱，无论是网络问题或者其他问题而重新付款，都只应该扣一次钱；</li>
<li>用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；</li>
<li>用户对一篇文章进行点赞，无论点了多少次，最终实际上也能将点赞数+1；</li>
<li>前端重复提交选中的数据，后台也只会产生对应这个数据的一个反应结果。</li>
</ol>
<p>增删改查的幂等性：</p>
<ul>
<li><code>Get </code> 用于获取资源，不会对系统资源进行改变，因此是幂等的。</li>
<li><code>Delete</code> 用于删除资源，虽然改变了系统资源，但是第一次和第N次删除操作对系统的作用是相同的，所以是幂等的。比如要删除一个 id 为 1 的资源，可能第一次调用时会删除，而后面所有调用的时候由于系统中已经没有这个 id 的资源了，就无法进行删除了。但是第一次操作和后面的操作对系统的作用是相同的，所以这也是幂等的，调用者可以多次调用这个接口不必担心错误。</li>
<li><code>Post </code> 用于新增资源，这意味着每次调用都会在系统中产生新的资源，所以该操作注定不是幂等操作。</li>
<li><code>Put </code> 用于修改资源，如果是设置具体值，则是幂等的，比如设置用户张三的分数为98，那么无论修改一次还是多次，最终结果都一样。但如果是增量修改，则可能不是幂等的，比如将用户张三的分数减10，那么多次修改和一次修改的效果是完全不同的。</li>
</ul>
<p>RabbitMQ 的幂等性问题</p>
<ul>
<li><p><strong>消息重复投递</strong>。生产者发送消息到 broker后，broker在confirm 确认的时候出现网络故障，使得生产者没收到该消息ACk 而重新发送消息到 broker 中。</p>
</li>
<li><p><strong>消息重复消费</strong>。<u>消费者处理完一条消息后，在向 MQ 发送 ack 确认时出现了网络故障，使得 MQ 没有收到此 ack 确认， 那么 MQ 并不会将该条消息删除，而是重新发送给其他的消费者或者当重新建立起连接后，再次发送给该消费者，这就造成了消息的重复消费。</u></p>
</li>
<li><p>解决了消息重复消费的问题其实就解决了消息重复投递的问题。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>&#x3D;&#x3D;全局唯一ID + 唯一索引&#x3D;&#x3D;</p>
<p>通过时间戳或者UUID或按自己的规则生成一个全局唯一id，每次消费消息时用该id先判断该消息是否已消费过。比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。不过在高并发时，如果是单个数据库就会有写入性能瓶颈（可采用分库分表提升性能）。</p>
</li>
<li><p>&#x3D;&#x3D;Redis原子性&#x3D;&#x3D;</p>
<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费，如果 ack 失败，在 RabbitMQ 将消息交给其他的消费者时，先执行 setnx，如果 key 已经存在（说明之前有人消费过该消息），获取他的值，如果是 0，当前消费者就什么都不做，如果是 1，直接 ack。</p>
</li>
</ul>
<h1 id="7-集群（高可用）"><a href="#7-集群（高可用）" class="headerlink" title="7. 集群（高可用）"></a>7. 集群（高可用）</h1><blockquote>
<p>使用了 MQ 后，整个系统会依赖于MQ的可靠性、安全性、吞吐能力，比如若MQ宕机，整个系统都会崩溃。因而会降低系统的可用性，那么如何改善这一缺点呢？答案是搭建集群环境。</p>
</blockquote>
<p>RabbitMQ的集群有两种模式：</p>
<ul>
<li><strong>普通集群【无高可用】</strong>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</li>
<li><strong>镜像集群【高可用】</strong>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</li>
</ul>
<h2 id="7-1-普通集群"><a href="#7-1-普通集群" class="headerlink" title="7.1 普通集群"></a>7.1 普通集群</h2><p>普通集群模式是使用多台服务器，在每台服务器中启动一个 RabbitMQ 实例，我们创建的每一个队列 Queue，它的元数据（主要就是 Queue 的一些配置信息）会在所有的 RabbitMQ 实例中进行同步，但是<strong>队列中的消息只会存在于一个 RabbitMQ 实例上</strong>，而不会同步。</p>
<p>当消费者拉取消息时，如果连接到了另外一个实例，那么此实例实际会通过元数据定位到 队列所在的位置，之后访问队列所在的实例，并拉取数据发送给消费者。</p>
<p>可见，这种集群<strong>可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用</strong>，因为一旦一个 RabbitMQ 实例挂了，其中的消息就访问不到了，其他实例中并不会保存挂掉的实例中的消息。</p>
<ul>
<li>如果 MQ 做了持久化，那么实例恢复后，才可以继续访问；</li>
<li>如果 MQ 没做持久化，那么消息就丢了。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220145.png" alt="image-20220320204329857" style="zoom:80%;" />

<h2 id="7-2-镜像集群"><a href="#7-2-镜像集群" class="headerlink" title="7.2 镜像集群"></a>7.2 镜像集群</h2><p>由于普通集群并没有实现 RabbitMQ 的高可用，实际生产条件下一般不会使用，而是会使用镜像集群。</p>
<p>相较于普通集群，<strong>镜像集群会将队列的所有数据（包括实际消息）同时存储在多台机器上，而不是仅仅存储队列的元数据。</strong>每个 RabbitMQ 实例都有一份镜像数据（副本数据）。在每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。</p>
<p>本质上是主从结构，创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。一旦某个 RabbitMQ 示例挂机了，那么其镜像节点就会成为新的主节点。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220139.png" alt="image-20220320205249660" style="zoom:80%;" />

<p>镜像集群模式并不需要额外搭建，只需要我们在普通集群的基础上将队列配置为镜像队列即可。</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>Java通过JDBC访问数据库</title>
    <url>/2022/02/20/JDBC/</url>
    <content><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><h2 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h2><ul>
<li><p>持久化 (persistence) ：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以『固化』，而持久化的实现过程大多通过各种关系数据库来完成。</p>
<span id="more"></span>
</li>
<li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142147.png" alt="image-20220325235907151" style="zoom:67%;" />


<h2 id="1-2-Java-中的数据存储技术"><a href="#1-2-Java-中的数据存储技术" class="headerlink" title="1.2 Java 中的数据存储技术"></a>1.2 Java 中的数据存储技术</h2><ul>
<li><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><p><strong>JDBC 直接访问数据库</strong></p>
</li>
<li><p>JDO (Java Data Object )技术</p>
</li>
<li><p>第三方 ORM 工具，如 Hibernate、Mybatis等</p>
</li>
</ul>
</li>
<li><p><strong>JDBC 是 java 访问数据库的基石</strong>，<u>JDO、Hibernate、MyBatis 等只是更好的封装了 JDBC</u>。</p>
</li>
</ul>
<h2 id="1-3-JDBC-介绍"><a href="#1-3-JDBC-介绍" class="headerlink" title="1.3 JDBC 介绍"></a>1.3 JDBC 介绍</h2><ul>
<li>JDBC（Java Database Connectivity）是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准 Java 类库（java.sql，javax.sql），使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li>
<li>JDBC 为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC 的目标是使 Java 程序员使用 JDBC 可以连接任何<strong>提供了 JDBC 驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
<li>如果没有 JDBC，那么 Java 程序将直接访问不同的数据库，开发人员需要写不同的程序。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142148.png" alt="image-20220328135519866" style="zoom:67%;" />

<ul>
<li><p>有了JDBC，Java 程序通过 JDBC 访问不同的数据库，JDBC 为 Java 操作数据库提供了统一的接口，每一种数据库都需要自行提供一个 JDBC 的具体实现程序。因此即使操作不同的数据库，实际开发人员需要编写的代码是一致的。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142150.png" alt="image-20220328095444035" style="zoom:67%;" /></li>
</ul>
<h2 id="1-4-JDBC-体系结构"><a href="#1-4-JDBC-体系结构" class="headerlink" title="1.4 JDBC 体系结构"></a>1.4 JDBC 体系结构</h2><blockquote>
<p>JDBC 是 sun 公司提供一套用于数据库操作的接口，java 程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p>
</blockquote>
<p>JDBC 接口（API）包括两个层次：</p>
<ul>
<li><strong>面向应用的 API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行 SQL 语句，获得结果）。</li>
<li><strong>面向数据库的 API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li>
</ul>
<h2 id="1-5-JDBC-程序编写步骤"><a href="#1-5-JDBC-程序编写步骤" class="headerlink" title="1.5 JDBC 程序编写步骤"></a>1.5 JDBC 程序编写步骤</h2><p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142151.png" alt="1566136831283"></p>
<h1 id="2、获取数据库连接"><a href="#2、获取数据库连接" class="headerlink" title="2、获取数据库连接"></a>2、获取数据库连接</h1><h2 id="2-1-要素一：Driver-接口实现类"><a href="#2-1-要素一：Driver-接口实现类" class="headerlink" title="2.1 要素一：Driver 接口实现类"></a>2.1 要素一：Driver 接口实现类</h2><h3 id="2-1-1-Driver-接口介绍"><a href="#2-1-1-Driver-接口介绍" class="headerlink" title="2.1.1 Driver 接口介绍"></a>2.1.1 Driver 接口介绍</h3><ul>
<li><p><code>java.sql.Driver </code>接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p>
</li>
<li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类 (java.sql.DriverManager) 去调用这些 Driver 实现。</p>
<ul>
<li>Oracle 的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li>
<li>mySql 的驱动： <strong>com.mysql.jdbc.Driver</strong></li>
</ul>
</li>
<li><p>使用：</p>
<ul>
<li>将ojdbc14.jar 和 mysql-connector-java-5.1.7-bin.jar 拷贝到 Java 工程的一个目录中，习惯上新建一个 lib 文件夹。</li>
<li>在驱动 jar 上右键–&gt; Build Path –&gt; Add to Build Path</li>
<li>注意：如果是 Dynamic Web Project（动态的web项目）话，则是把驱动 jar 放到 WebContent（有的开发工具叫WebRoot）目录中的 WEB-INF 目录中的 lib 目录下即可</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-加载与注册-JDBC驱动"><a href="#2-1-2-加载与注册-JDBC驱动" class="headerlink" title="2.1.2 加载与注册 JDBC驱动"></a>2.1.2 加载与注册 JDBC驱动</h3><ul>
<li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p>
<ul>
<li><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>;</li>
</ul>
</li>
<li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p>
<ul>
<li><p><strong>使用 DriverManager.registerDriver(com.mysql.jdbc.Driver) 来注册驱动</strong></p>
</li>
<li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是 MySQL 的 Driver 实现类的源码：</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142149.png" alt="image-20220328135558312"  /></li>
</ul>
</li>
</ul>
<h2 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h2><ul>
<li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p>
</li>
<li><p>JDBC URL 的标准由三部分组成，各部分间用冒号分隔。 </p>
<ul>
<li><p><strong>jdbc:子协议:子名称</strong></p>
</li>
<li><p><strong>协议</strong>：JDBC URL中的协议总是 jdbc </p>
</li>
<li><p><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</p>
</li>
<li><p><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的 ip 地址)<strong>，端口号，数据库名</strong></p>
</li>
<li><p>举例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142154.png" alt="1566569819744"></p>
</li>
</ul>
</li>
<li><p><strong>几种常用数据库的 JDBC URL</strong></p>
<ul>
<li><p>MySQL 的连接 URL 编写方式：</p>
<ul>
<li>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</li>
<li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</li>
<li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test**?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8**（如果 JDBC 程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li>
<li>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?user&#x3D;root&amp;password&#x3D;123456</li>
</ul>
</li>
<li><p>Oracle 的连接 URL 编写方式：</p>
<ul>
<li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li>
<li>jdbc:oracle:thin:@localhost:1521:test</li>
</ul>
</li>
<li><p>SQLServer 的连接 URL 编写方式：</p>
<ul>
<li><p>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</p>
</li>
<li><p>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;test</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h2><ul>
<li>user，password 可以用“属性名&#x3D;属性值”方式告诉数据库</li>
<li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li>
</ul>
<h2 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h2><h3 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        driver = <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供url，指明具体操作的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.调用driver的connect()，获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：上述代码中显式出现了第三方数据库的API</p>
</blockquote>
<h3 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.实例化Driver</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.提供url，指明具体操作的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.调用driver的connect()，获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url, info);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：相较于方式一，这里使用反射实例化 Driver，不在代码中体现第三方数据库的 API。体现了面向接口编程思想。</p>
</blockquote>
<h3 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection3</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">           <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">           <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">           <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(driverName);</span><br><span class="line">           <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用 DriverManager 实现数据库的连接。体会获取连接必要的 4 个基本要素。</p>
</blockquote>
<h3 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">        Class.forName(driverName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">        <span class="comment">//3.注册驱动</span></span><br><span class="line">        <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">            static &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">                &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：不必显式的注册驱动了。因为在 DriverManager 的源码中已经存在静态代码块，实现了驱动的注册。</p>
</blockquote>
<h3 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.加载配置文件</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取配置信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.加载驱动</span></span><br><span class="line">    Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,user,password);</span><br><span class="line">    System.out.println(conn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p>
<p><strong>使用配置文件的好处：</strong></p>
<p>① 实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>② 如果修改了配置信息，省去重新编译的过程。</p>
</blockquote>
<p>总结：</p>
<p>获取连接需要三步：</p>
<ol>
<li>加载配置信息（url，用户名，密码，驱动名称）</li>
<li>加载驱动（反射的形式， Class.forName(驱动名称);）</li>
<li>获取连接（DriverManager.getConnection(url,用户名,密码);）</li>
</ol>
<h1 id="3、使用-PreparedStatement-实现-CRUD-操作"><a href="#3、使用-PreparedStatement-实现-CRUD-操作" class="headerlink" title="3、使用 PreparedStatement 实现 CRUD 操作"></a>3、使用 PreparedStatement 实现 CRUD 操作</h1><h2 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h2><ul>
<li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。<strong>其实一个数据库连接就是一个 Socket 连接。</strong></p>
</li>
<li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p>
<ul>
<li><p><code>Statement</code>：用于执行静态 SQL 语句并返回它所生成结果的对象。 </p>
</li>
<li><p><code>PreparedStatement</code>：SQL 语句被<u>预编译</u>并存储在此对象中，可以使用此对象多次高效地执行该语句。</p>
</li>
<li><p><code>CallableStatement</code>：用于执行 SQL 存储过程。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142152.png" alt="image-20220328104214789" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h2 id="3-2-使用-Statement-操作数据表的弊端"><a href="#3-2-使用-Statement-操作数据表的弊端" class="headerlink" title="3.2 使用 Statement 操作数据表的弊端"></a>3.2 使用 Statement 操作数据表的弊端</h2><ul>
<li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p>
</li>
<li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>) # 执行更新操作<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>) # 执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是使用 Statement 操作数据表存在弊端：</p>
<ul>
<li><strong>问题一：存在拼串操作，繁琐</strong></li>
<li><strong>问题二：存在 SQL 注入问题</strong></li>
</ul>
</li>
<li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user&#x3D;’a’ OR 1 &#x3D; ‘ AND password &#x3D; ‘ OR ‘1’ &#x3D; ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p>
</li>
<li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement (从Statement扩展而来) 取代 Statement 就可以了。</p>
</li>
<li><p>代码演示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatementTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLogin</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">		System.out.print(<span class="string">&quot;用户名：&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">		System.out.print(<span class="string">&quot;密   码：&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// SELECT user,password FROM user_table WHERE USER = &#x27;1&#x27; or &#x27; AND PASSWORD = &#x27;=&#x27;1&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT user,password FROM user_table WHERE USER = &#x27;&quot;</span> + userName + <span class="string">&quot;&#x27; AND PASSWORD = &#x27;&quot;</span> + password</span><br><span class="line">				+ <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> get(sql, User.class);</span><br><span class="line">		<span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;登陆成功!&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用户名或密码错误！&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1.加载配置文件</span></span><br><span class="line">			<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">			<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">			pros.load(is);</span><br><span class="line">			<span class="comment">// 2.读取配置信息</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">			<span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">			<span class="comment">// 3.加载驱动</span></span><br><span class="line">			Class.forName(driverClass);</span><br><span class="line">			<span class="comment">// 4.获取连接</span></span><br><span class="line">			conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">            <span class="comment">// 5.获取 statement</span></span><br><span class="line">			st = conn.createStatement();</span><br><span class="line">			<span class="comment">// 6.执行查询</span></span><br><span class="line">			rs = st.executeQuery(sql);</span><br><span class="line">			<span class="comment">// 7.获取结果集的元数据</span></span><br><span class="line">			<span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">			<span class="comment">// 8.获取结果集的列数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">				t = clazz.newInstance();</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;</span><br><span class="line">					<span class="comment">// //1. 获取列的名称</span></span><br><span class="line">					<span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line">					<span class="comment">// 1. 获取列的别名</span></span><br><span class="line">					<span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">					<span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">					<span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(columnName);</span><br><span class="line">					<span class="comment">// 3. 将数据表中得到的数据，封装进对象（反射）</span></span><br><span class="line">					<span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnName);</span><br><span class="line">					field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">					field.set(t, columnVal);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 关闭资源</span></span><br><span class="line">			<span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					rs.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (st != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					st.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					conn.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上：</p>
<p><img src="/JDBC.assets/20220328142155.png" alt="1555580152530"></p>
<h2 id="3-3-PreparedStatement-的使用"><a href="#3-3-PreparedStatement-的使用" class="headerlink" title="3.3 PreparedStatement 的使用"></a>3.3 PreparedStatement 的使用</h2><h3 id="3-3-1-PreparedStatement-介绍"><a href="#3-3-1-PreparedStatement-介绍" class="headerlink" title="3.3.1 PreparedStatement 介绍"></a>3.3.1 PreparedStatement 介绍</h3><ul>
<li><p>可以通过调用 Connection 对象的 <code>preparedStatement(String sql)</code> 方法获取 PreparedStatement 对象</p>
</li>
<li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p>
</li>
<li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p>
</li>
</ul>
<h3 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h3><ul>
<li><p>代码的可读性和可维护性。</p>
</li>
<li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p>
<ul>
<li>DBServer 会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被 DBServer 的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li>
<li>在 statement 语句中,即使是相同操作但因为数据内容不一样，所以整个语句本身不能匹配，没有缓存语句的意义。事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li>
<li>(语法检查，语义检查，翻译成二进制命令，缓存)</li>
</ul>
</li>
<li><p>PreparedStatement 可以防止 SQL 注入 ，<strong>语句中使用了占位符，规定了 sql 语句的结构。用户可以设置”?”的值，但是不能改变 sql 语句的结构</strong>，因此想在sql语句后面加上如“or 1&#x3D;1”实现 sql 注入是行不通的。PreparedStatement 不是将参数简单拼凑成 sql，而是做了一些预处理，将参数转换为 string，两端加单引号，将参数内的一些特殊字符（换行，单双引号，斜杠等）做转义处理，这样就很大限度的避免了 sql 注入。</p>
<ul>
<li><p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 当我们需要查询users表中的userid时，执行下面这句<span class="keyword">sql</span>语句</span><br><span class="line">String userid<span class="operator">=</span>&quot;用户输入id&quot;</span><br><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from users where userid = &quot; <span class="operator">+</span> userid;</span><br><span class="line"></span><br><span class="line"># 如果使用statement这样拼接字符串的形式很容易导致<span class="keyword">sql</span>注入问题，比如用户输入：userid <span class="operator">=</span> &quot;1;delete users;&quot; ，此时<span class="keyword">sql</span>语句在编译时会编译成<span class="number">2</span>条语句，对<span class="keyword">user</span>进行了非法删除，就出现了<span class="keyword">sql</span>注入问题</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> userid<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> users;</span><br><span class="line"></span><br><span class="line"># 当我们使用preparestatement时，<span class="keyword">sql</span>语句会被预编译成：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> userid <span class="operator">=</span> <span class="string">&#x27;?&#x27;</span></span><br><span class="line"># 当执行时这条<span class="keyword">sql</span>时，?参数会被替换成用户输入参数：</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> userid <span class="operator">=</span> <span class="string">&#x27;1;delete users;&#x27;</span> ; # 查询结果为<span class="keyword">null</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-3-3-Java-与-SQL-对应数据类型转换表"><a href="#3-3-3-Java-与-SQL-对应数据类型转换表" class="headerlink" title="3.3.3 Java 与 SQL 对应数据类型转换表"></a>3.3.3 Java 与 SQL 对应数据类型转换表</h3><table>
<thead>
<tr>
<th>Java类型</th>
<th>SQL类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>BIT</td>
</tr>
<tr>
<td>byte</td>
<td>TINYINT</td>
</tr>
<tr>
<td>short</td>
<td>SMALLINT</td>
</tr>
<tr>
<td>int</td>
<td>INTEGER</td>
</tr>
<tr>
<td>long</td>
<td>BIGINT</td>
</tr>
<tr>
<td>String</td>
<td>CHAR,VARCHAR,LONGVARCHAR</td>
</tr>
<tr>
<td>byte，array</td>
<td>BINARY  ,    VAR BINARY</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>DATE</td>
</tr>
<tr>
<td>java.sql.Time</td>
<td>TIME</td>
</tr>
<tr>
<td>java.sql.Timestamp</td>
<td>TIMESTAMP</td>
</tr>
</tbody></table>
<h3 id="3-3-4-使用-PreparedStatement-实现增、删、改操作"><a href="#3-3-4-使用-PreparedStatement-实现增、删、改操作" class="headerlink" title="3.3.4 使用 PreparedStatement 实现增、删、改操作"></a>3.3.4 使用 PreparedStatement 实现增、删、改操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String sql,Object ... args)</span>&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取数据库的连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 3.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.执行sql语句</span></span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">// 5.关闭资源</span></span><br><span class="line">        JDBCUtils.closeResource(conn, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-5-使用-PreparedStatement-实现查询操作"><a href="#3-3-5-使用-PreparedStatement-实现查询操作" class="headerlink" title="3.3.5 使用 PreparedStatement 实现查询操作"></a>3.3.5 使用 PreparedStatement 实现查询操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取数据库连接</span></span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">        ps = conn.prepareStatement(sql);</span><br><span class="line">        <span class="comment">// 3.填充占位符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">        <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">        <span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line">        <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; columnCount; i++) &#123;<span class="comment">// 遍历每一个列</span></span><br><span class="line">                <span class="comment">// 获取列值</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">columnVal</span> <span class="operator">=</span> rs.getObject(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">columnLabel</span> <span class="operator">=</span> rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                field.set(t, columnVal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7.关闭资源</span></span><br><span class="line">        JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：使用 PreparedStatement 实现的查询操作可以替换 Statement 实现的查询操作，解决 Statement 拼串和SQL 注入问题。</p>
</blockquote>
<h2 id="3-4-ResultSet-与-ResultSetMetaData"><a href="#3-4-ResultSet-与-ResultSetMetaData" class="headerlink" title="3.4 ResultSet 与 ResultSetMetaData"></a>3.4 ResultSet 与 ResultSetMetaData</h2><h3 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h3><ul>
<li><p>查询需要调用 PreparedStatement 的 executeQuery() 方法，查询结果是一个 ResultSet 对象。</p>
</li>
<li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现。</p>
</li>
<li><p><strong>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</strong></p>
</li>
<li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于 Iterator 对象的 hasNext() 和 next() 方法的结合体。</p>
</li>
<li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p>
<ul>
<li>例如: getInt(1), getString(“name”)</li>
<li><strong>注意：Java 与数据库交互涉及到的相关 Java API 中的索引都从 1 开始。</strong></li>
</ul>
</li>
<li><p>ResultSet 接口的常用方法：</p>
<ul>
<li><p>boolean next()</p>
</li>
<li><p>getString()</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142153.png" alt="image-20220328102233700" style="zoom:80%;" />

<h3 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h3><ul>
<li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p>
</li>
<li><p>ResultSetMetaData meta &#x3D; rs.getMetaData();</p>
<ul>
<li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p>
</li>
<li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名 ★</p>
</li>
<li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数 ★。 </p>
</li>
<li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p>
</li>
<li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p>
</li>
<li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p>
</li>
<li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142156.png" alt="1555579494691"></p>
<p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p>
<pre><code> 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData
</code></pre>
<p><strong>问题2：关于ResultSetMetaData</strong></p>
<ol>
<li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li>
<li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li>
<li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142157.png" alt="1555579816884"></p>
<h2 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h2><ul>
<li>释放 ResultSet、 Statement、Connection。</li>
<li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果 Connection 不能及时正确的关闭将导致系统宕机。Connection 的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li>
<li>可以在 finally 中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li>
</ul>
<h2 id="3-6-JDBC-API-小结"><a href="#3-6-JDBC-API-小结" class="headerlink" title="3.6 JDBC API 小结"></a>3.6 JDBC API 小结</h2><ul>
<li><p>两种思想</p>
<ul>
<li><p>面向接口编程的思想</p>
</li>
<li><p>ORM 思想（object relational mapping）</p>
<ul>
<li>一个数据表对应一个java类</li>
<li>表中的一条记录对应java类的一个对象</li>
<li>表中的一个字段对应java类的一个属性</li>
</ul>
</li>
</ul>
<blockquote>
<p>sql 是需要结合列名和表的属性名来写。注意起别名。</p>
</blockquote>
</li>
<li><p>两种技术</p>
<ul>
<li>JDBC 结果集的元数据：ResultSetMetaData<ul>
<li>获取列数：getColumnCount()</li>
<li>获取列的别名：getColumnLabel()</li>
</ul>
</li>
<li>通过反射，创建指定类的对象，获取指定的属性并赋值</li>
</ul>
</li>
</ul>
<h1 id="4、操作-BLOB-类型字段"><a href="#4、操作-BLOB-类型字段" class="headerlink" title="4、操作 BLOB 类型字段"></a>4、操作 BLOB 类型字段</h1><h2 id="4-1-MySQL-BLOB-类型"><a href="#4-1-MySQL-BLOB-类型" class="headerlink" title="4.1 MySQL BLOB 类型"></a>4.1 MySQL BLOB 类型</h2><ul>
<li><p>MySQL中，BLOB 是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p>
</li>
<li><p>插入 BLOB 类型的数据必须使用 PreparedStatement，因为 BLOB 类型的数据无法使用字符串拼接写的。</p>
</li>
<li><p>MySQL的四种 BLOB 类型(除了在存储的最大信息量上不同外，他们是等同的)</p>
<ul>
<li>TinyBlob：最大 255 字节</li>
<li>Blob：最大 65K </li>
<li>MediumBlob：最大 16M</li>
<li>LongBlob：最大 4G</li>
</ul>
</li>
<li><p>实际使用中根据需要存入的数据大小定义不同的 BLOB 类型。</p>
</li>
<li><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p>
</li>
<li><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet&#x3D;16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p>
</li>
</ul>
<h2 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();	</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">// 2.获取preparedStatement对象</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;徐海强&quot;</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">&quot;xhq@126.com&quot;</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 4.操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xhq.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">// 5.执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"><span class="comment">// 6.关闭资源	</span></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h2 id="4-3-修改数据表中的-Blob-类型字段"><a href="#4-3-修改数据表中的-Blob-类型字段" class="headerlink" title="4.3 修改数据表中的 Blob 类型字段"></a>4.3 修改数据表中的 Blob 类型字段</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update customers set photo = ? where id = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;coffee.png&quot;</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">ps.execute();</span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h2 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="number">2</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> rs.getString(<span class="number">3</span>);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> rs.getDate(<span class="number">4</span>);</span><br><span class="line">	<span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">	<span class="type">Blob</span> <span class="variable">photo</span> <span class="operator">=</span> rs.getBlob(<span class="number">5</span>);</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> photo.getBinaryStream();</span><br><span class="line">	<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;c.jpg&quot;</span>);</span><br><span class="line">	<span class="type">byte</span> [] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">		os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">	&#125;</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">	<span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">		is.close();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(os !=  <span class="literal">null</span>)&#123;</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、批量插入"><a href="#5、批量插入" class="headerlink" title="5、批量插入"></a>5、批量插入</h1><h2 id="5-1-批量执行-SQL-语句"><a href="#5-1-批量执行-SQL-语句" class="headerlink" title="5.1 批量执行 SQL 语句"></a>5.1 批量执行 SQL 语句</h2><p>当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p>
<p>JDBC的批量处理语句包括下面三个方法：</p>
<ul>
<li><code>addBatch(String)</code>：添加需要批量处理的SQL语句或是参数；</li>
<li><code>executeBatch()</code>：执行批量处理语句；</li>
<li><code>clearBatch()</code>：清空缓存的数据</li>
</ul>
<p>通常我们会遇到两种批量执行 SQL 语句的情况：</p>
<ul>
<li>多条SQL语句的批量处理；</li>
<li>一个SQL语句的批量传参；</li>
</ul>
<h2 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h2><p>举例：向数据表中插入20000条数据</p>
<ul>
<li>数据库中提供一个 goods 表。创建如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-1-实现层次一：使用-Statement"><a href="#5-2-1-实现层次一：使用-Statement" class="headerlink" title="5.2.1 实现层次一：使用 Statement"></a>5.2.1 实现层次一：使用 Statement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">st</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name) values(&#x27;name_&#x27; + &quot;</span>+ i +<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	st.executeUpdate(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-实现层次二：使用-PreparedStatement"><a href="#5-2-2-实现层次二：使用-PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用 PreparedStatement"></a>5.2.2 实现层次二：使用 PreparedStatement</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++)&#123;</span><br><span class="line">	ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1：使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> * 		 ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();	</span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">		<span class="comment">// 1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">// 3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">// 20000条：625 ，1000000条:14733</span></span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false) / commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">	<span class="comment">// 1.设置为不自动提交数据</span></span><br><span class="line">	conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into goods(name)values(?)&quot;</span>;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++)&#123;</span><br><span class="line">		ps.setString(<span class="number">1</span>, <span class="string">&quot;name_&quot;</span> + i);</span><br><span class="line">		<span class="comment">// 1.1.“攒”sql</span></span><br><span class="line">		ps.addBatch();</span><br><span class="line">		<span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">// 1.2.执行</span></span><br><span class="line">			ps.executeBatch();</span><br><span class="line">			<span class="comment">// 1.3.清空</span></span><br><span class="line">			ps.clearBatch();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.提交数据</span></span><br><span class="line">	conn.commit();	</span><br><span class="line">	<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">	System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">// 1000000条:4978 </span></span><br><span class="line">	JDBCUtils.closeResource(conn, ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、数据库事务"><a href="#6、数据库事务" class="headerlink" title="6、数据库事务"></a>6、数据库事务</h1><h2 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h2><ul>
<li><p>事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
</li>
<li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么<u>所有的事务都被提交(commit)</u>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，<u>整个事务回滚(rollback**)**到最初状态</u>。</p>
</li>
<li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p>
</li>
</ul>
<h2 id="6-2-JDBC-事务处理"><a href="#6-2-JDBC-事务处理" class="headerlink" title="6.2 JDBC 事务处理"></a>6.2 JDBC 事务处理</h2><ul>
<li><p>数据一旦提交，就不可回滚。</p>
</li>
<li><p>数据什么时候意味着提交？</p>
<ul>
<li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li>
<li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li>
</ul>
</li>
<li><p><strong>JDBC 程序中为了让多个 SQL 语句作为一个事务执行：</strong></p>
<ul>
<li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li>
<li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li>
<li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li>
</ul>
<blockquote>
<p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行 close() 方法前，建议恢复自动提交状态。</p>
</blockquote>
</li>
</ul>
<p>【案例：用户AA向用户BB转账100】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJDBCTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取数据库连接</span></span><br><span class="line">		conn = JDBCUtils.getConnection();</span><br><span class="line">		<span class="comment">// 2.开启事务</span></span><br><span class="line">		conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 3.进行数据库操作</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance - 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql1, <span class="string">&quot;AA&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 模拟网络异常</span></span><br><span class="line">		<span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = balance + 100 where user = ?&quot;</span>;</span><br><span class="line">		update(conn, sql2, <span class="string">&quot;BB&quot;</span>);</span><br><span class="line">		<span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">		conn.commit();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">		<span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			conn.rollback();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">			conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">		JDBCUtils.closeResource(conn, <span class="literal">null</span>, <span class="literal">null</span>); </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，对数据库操作的方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> &#123;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">		ps = conn.prepareStatement(sql);</span><br><span class="line">		<span class="comment">// 2.填充占位符</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.执行sql语句</span></span><br><span class="line">		ps.execute();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// 4.关闭资源</span></span><br><span class="line">		JDBCUtils.closeResource(<span class="literal">null</span>, ps);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-事务的-ACID-属性"><a href="#6-3-事务的-ACID-属性" class="headerlink" title="6.3 事务的 ACID 属性"></a>6.3 事务的 ACID 属性</h2><ol>
<li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p>
</li>
<li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p>
</li>
<li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
</li>
</ol>
<h3 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h3><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p>
</li>
</ul>
<h3 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED(读未提交数据)</td>
<td>允许事务读取未被其他事物提交的变更.脏读,不可重复读和幻读的问题都会出现</td>
</tr>
<tr>
<td>READ COMMITED(读已提交数据)</td>
<td>只允许事务读取已经被其它事务提交的变更.可以避免脏读,但不可重复读和幻读问题仍然可能出现</td>
</tr>
<tr>
<td>REPEATABLE READ可重复读)</td>
<td>确保事务可以多次从一个字段中读取相同的值.在这个事务持续期间,禁止其他事物对这个字段进行更新.可以避免脏读和不可重复读.但幻读的问题仍然存在</td>
</tr>
<tr>
<td>SERIALIZABLE(串行化)</td>
<td>确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表执行插入,更新和删除操作.所有并发问题都可以避免,但性能十分低下.</td>
</tr>
</tbody></table>
<ul>
<li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p>
</li>
<li><p>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></p>
</li>
</ul>
<h3 id="6-3-3-在-MySql-中设置隔离级别"><a href="#6-3-3-在-MySql-中设置隔离级别" class="headerlink" title="6.3.3 在 MySql 中设置隔离级别"></a>6.3.3 在 MySql 中设置隔离级别</h3><ul>
<li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p>
</li>
<li><p>查看当前的隔离级别: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置当前 mySQL 连接的隔离级别:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数据库系统的全局的隔离级别:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
</li>
<li><p>补充操作：</p>
<ul>
<li><p>创建mysql数据库用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user tom identified by &#x27;abc123&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@&#x27;%&#x27;  identified by &#x27;abc123&#x27;; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by &#x27;abc123&#x27;; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="7、数据库连接池"><a href="#7、数据库连接池" class="headerlink" title="7、数据库连接池"></a>7、数据库连接池</h1><h2 id="7-1-JDBC-数据库连接池的必要性"><a href="#7-1-JDBC-数据库连接池的必要性" class="headerlink" title="7.1 JDBC 数据库连接池的必要性"></a>7.1 JDBC 数据库连接池的必要性</h2><p>在使用开发基于数据库的 web 程序时，传统的模式基本是按以下步骤：　　</p>
<ul>
<li>在主程序（如 servlet、beans）中建立数据库连接</li>
<li>进行 sql 操作</li>
<li>断开数据库连接</li>
</ul>
<p>这种模式开发，存在的问题：</p>
<ul>
<li>普通的 JDBC 数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码（得花费 0.05s～1s 的时间）。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li>
<li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（创建的连接不再使用时，需要调用 <strong>close</strong> 方法关闭连接，只有连接被关闭后，GC 才会回收对应的对象（Connection，Statement，ResultSet，Session）。忘记关闭这些资源会导致持续占有内存，无法被 GC 回收）</li>
<li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。</li>
</ul>
<h2 id="7-2-数据库连接池技术"><a href="#7-2-数据库连接池技术" class="headerlink" title="7.2 数据库连接池技术"></a>7.2 数据库连接池技术</h2><ul>
<li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p>
</li>
<li><p><strong>数据库连接池的基本思想</strong>：<u>为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</u></p>
</li>
<li><p>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</p>
</li>
<li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<u>最小数据库连接数</u>来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<u>最大数据库连接数量</u>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142158.png" alt="1555593464033" style="zoom:67%;" />

<ul>
<li><strong>工作原理：</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JDBC/20220328142159.png" alt="1555593598606"></p>
<ul>
<li><p><strong>数据库连接池技术的优点</strong></p>
<p><strong>1. 资源重用</strong></p>
<p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p>
<p><strong>2. 更快的系统反应速度</strong></p>
<p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间。</p>
<p><strong>3. 新的资源分配手段</strong></p>
<p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源。</p>
<p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p>
<p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露。</p>
</li>
</ul>
<h3 id="7-3-多种开源的数据库连接池"><a href="#7-3-多种开源的数据库连接池" class="headerlink" title="7.3 多种开源的数据库连接池"></a>7.3 多种开源的数据库连接池</h3><ul>
<li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul>
<li><strong>DBCP</strong> 是 Apache 提供的数据库连接池。tomcat 服务器自带 dbcp 数据库连接池。速度相对 c3p0 较快，但因自身存在BUG，Hibernate3已不再提供支持。</li>
<li><strong>C3P0</strong> 是一个开源组织提供的数据库连接池，速度相对较慢，稳定性还可以。hibernate 官方推荐使用。</li>
<li>Proxool 是 sourceforge 下的一个开源数据库连接池，有监控连接池状态的功能，稳定性较 c3p0 差一点</li>
<li>BoneCP 是一个开源组织提供的数据库连接池，速度快。</li>
<li><code>Druid</code> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有 BoneCP 快</li>
</ul>
</li>
<li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池。</li>
<li><strong>DataSource 用来取代 DriverManager 来获取 Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li>
<li>特别注意：<ul>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但 conn.close() 并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
</ul>
</li>
</ul>
<h3 id="7-3-1-C3P0-数据库连接池"><a href="#7-3-1-C3P0-数据库连接池" class="headerlink" title="7.3.1 C3P0 数据库连接池"></a>7.3.1 C3P0 数据库连接池</h3><ul>
<li>获取连接方式一</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">	<span class="type">ComboPooledDataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">	cpds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>); </span><br><span class="line">	cpds.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">	cpds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	cpds.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//	cpds.setMaxPoolSize(100);</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">cpds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;helloc3p0&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException&#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> cpds.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【c3p0-config.xml】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">&quot;helloc3p0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireIncrement&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatements&quot;</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxStatementsPerConnection&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-2-DBCP-数据库连接池"><a href="#7-3-2-DBCP-数据库连接池" class="headerlink" title="7.3.2 DBCP 数据库连接池"></a>7.3.2 DBCP 数据库连接池</h3><ul>
<li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
</li>
<li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li>
<li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li>
<li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li>
<li>配置属性说明</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>initialSize</td>
<td>0</td>
<td>连接池启动时创建的初始化连接数量</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>连接池中可同时连接的最大的连接数</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td>
</tr>
<tr>
<td>minIdle</td>
<td>0</td>
<td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td>
</tr>
<tr>
<td>maxWait</td>
<td>无限制</td>
<td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>开启池的Statement是否prepared</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>无限制</td>
<td>开启池的prepared 后的同时最大连接数</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>300</td>
<td>超过时间限制，回收没有用(废弃)的连接</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>false</td>
<td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td>
</tr>
</tbody></table>
<ul>
<li>获取连接方式一：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">BasicDataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line">		</span><br><span class="line">	source.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	source.setUrl(<span class="string">&quot;jdbc:mysql:///test&quot;</span>);</span><br><span class="line">	source.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">	source.setPassword(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line"></span><br><span class="line">	source.setInitialSize(<span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取连接方式二：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DataSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;dbcp.properties&quot;</span>);</span><br><span class="line">			</span><br><span class="line">		pros.load(is);</span><br><span class="line">		<span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">		source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> source.getConnection();</span><br><span class="line">	<span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【dbcp.properties】</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-3-Druid（德鲁伊）数据库连接池"><a href="#7-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="7.3.3 Druid（德鲁伊）数据库连接池"></a>7.3.3 Druid（德鲁伊）数据库连接池</h3><p>Druid 是阿里巴巴开源平台上一个数据库连接池实现，它结合了 C3P0、DBCP、Proxool 等 DB 池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的 DB 连接池，可以说是目前最好的连接池之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDruid</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();		 pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>));</span><br><span class="line">		<span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">		<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ds.getConnection();</span><br><span class="line">		System.out.println(conn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，src下的配置文件为：【druid.properties】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure>

<ul>
<li>详细配置参数：</li>
</ul>
<table>
<thead>
<tr>
<th><strong>配置</strong></th>
<th><strong>缺省</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td></td>
<td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td>
</tr>
<tr>
<td>url</td>
<td></td>
<td>连接数据库的 url，不同数据库不一样。例如：mysql :   jdbc:mysql:&#x2F;&#x2F;10.20.153.104:3306&#x2F;druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td>
</tr>
<tr>
<td>username</td>
<td></td>
<td>连接数据库的用户名</td>
</tr>
<tr>
<td>password</td>
<td></td>
<td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td>
</tr>
<tr>
<td>driverClassName</td>
<td></td>
<td>根据url自动识别   这一项可配可不配，如果不配置 druid 会根据 url 自动识别dbType，然后选择相应的 driverClassName(建议配置下)</td>
</tr>
<tr>
<td>initialSize</td>
<td>0</td>
<td>初始化时建立物理连接的个数。初始化发生在显示调用 init 方法，或者第一次getConnection 时</td>
</tr>
<tr>
<td>maxActive</td>
<td>8</td>
<td>最大连接池数量</td>
</tr>
<tr>
<td>maxIdle</td>
<td>8</td>
<td>已经不再使用，配置了也没效果</td>
</tr>
<tr>
<td>minIdle</td>
<td></td>
<td>最小连接池数量</td>
</tr>
<tr>
<td>maxWait</td>
<td></td>
<td>获取连接时最大等待时间，单位毫秒。配置了 maxWait 之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>false</td>
<td>是否缓存 preparedStatement，也就是 PSCache。PSCache 对支持游标的数据库性能提升巨大，比如说 oracle。在 mysql 下建议关闭。</td>
</tr>
<tr>
<td>maxOpenPreparedStatements</td>
<td>-1</td>
<td>要启用 PSCache，必须配置大于 0，当大于0时，poolPreparedStatements自动触发修改为 true。在 Druid中，不会存在 Oracle 下 PSCache 占用内存过多的问题，可以把这个数值配置大一些，比如说 100</td>
</tr>
<tr>
<td>validationQuery</td>
<td></td>
<td>用来检测连接是否有效的sql，要求是一个查询语句。如果 validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle 都不会其作用。</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>true</td>
<td>申请连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能。</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>false</td>
<td>归还连接时执行 validationQuery 检测连接是否有效，做了这个配置会降低性能</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>false</td>
<td>建议配置为 true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis，执行 validationQuery 检测连接是否有效。</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td></td>
<td>有两个含义： 1)Destroy线程会检测连接的间隔时间 2)testWhileIdle的判断依据，详细看 testWhileIdle 属性的说明</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td></td>
<td>不再使用，一个 DruidDataSource 只支持一个 EvictionRun</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td></td>
<td></td>
</tr>
<tr>
<td>connectionInitSqls</td>
<td></td>
<td>物理连接初始化的时候执行的 sql</td>
</tr>
<tr>
<td>exceptionSorter</td>
<td></td>
<td>根据 dbType 自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td>
</tr>
<tr>
<td>filters</td>
<td></td>
<td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的 filter:stat 日志用的filter:log4j 防御 sql 注入的 filter:wall</td>
</tr>
<tr>
<td>proxyFilters</td>
<td></td>
<td>类型是 List，如果同时配置了 filters 和 proxyFilters，是组合关系，并非替换关系</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ基础知识</title>
    <url>/2022/03/10/RabbitMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h2><blockquote>
<p>消息队列简称 MQ，英文全称为 <code>Message Queue</code>，它是一种跨进程的通信机制，用于上下游传递消息。采取典型的生产者和消费者模型，生产者不断的向队列中发送消息，消费者不断的从队列中获取消息。</p>
</blockquote>
<span id="more"></span>

<p>MQ 的优点：</p>
<ul>
<li><p>任务<strong>异步处理</strong></p>
<p>在项目中，可将一些<strong>无需即时返回且耗时</strong>的操作提取出来，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高了系统的吞吐量</strong>。此时MQ 就类似于一个中转站，使得消息的发送和接收可以异步进行，而生产者无需同步等待消费者及时返回。</p>
<p>比如在商品购物业务中，用户支付完之后 ，支付业务直接将消息投递到 MQ 中，就直接可以返回用户结果，而无需再同步等待订单服务、短信服务等模块的响应，实现了任务的异步处理，从而实现了异步通信。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220247.png" alt="image-20220320164432393" style="zoom:50%;" />
</li>
<li><p>应用程序<strong>解耦合</strong></p>
<p>MQ 相当于一个中介，生产者只需要将消息投递到 MQ中，而无需直接调用消费者模块的相关接口，消费者只需要监听 MQ 即可，从而实现应用程序的解耦合。并且如果之后需要增加一些业务需求，无需改变生产者代码，只需让新的业务监听 MQ 消息即可。</p>
<p>比如在商品购物业务中，需要增加积分服务，那么只需要写完积分服务代码后，让其监听 MQ 即可，不需要再修改支付服务的代码，从而实现了解耦。而如果积分服务挂了，但并不会影响支付服务，从而实现了<strong>故障隔离</strong>（如果是同步调用，那么一个挂了，则相当于所有都挂了，消息队列机制则不会。）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220250.png" alt="image-20220320164619922" style="zoom:50%;" />
</li>
<li><p><strong>削峰填谷</strong></p>
<p>如果一时间有大量的消息涌入，使用 MQ 可以应对<strong>生产者的流量冲击</strong>(类似于流量控制)，消费者只需要按照自己的处理能力对消息进行处理即可。</p>
<p>比如在双十一秒杀时，有大量的订单消息，如果不对流量进行控制，那么订单服务可能会由于无法支撑那么大的并发量而挂掉。假设订单服务每秒只能处理10000次订单，而实际每秒有20000次订单，此时可以通过消息队列做一个缓冲作用，让订单服务分2秒处理掉这20000次订单。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220253.png" alt="image-20220320165734757" style="zoom:50%;" /></li>
</ul>
<p>MQ 的缺点：</p>
<ul>
<li><strong>系统可用性降低</strong>：系统依赖于MQ的可靠性、安全性、吞吐能力。比如若MQ宕机，整个系统都会崩溃。</li>
<li><strong>数据链路复杂性增加</strong>：本来生产者只需要直接将消息发送给消费者，而此时加入一个 MQ做中转，可能出现<strong>消息丢失</strong>，<strong>消息的转发顺序改变</strong>，<strong>消息重复调用</strong>等等问题。</li>
<li><strong>数据一致性问题</strong>：生产者发送消息需要MQ和消费者共同处理，如果MQ处理成功，而消费者处理失败，则可能会造成数据一致性问题。或者是多个消费者要处理修改同一条消息时，也可能会造成一致性问题。</li>
</ul>
<h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2. AMQP 和 JMS"></a>1.2. AMQP 和 JMS</h2><p>MQ 是消息通信的模型；实现 MQ 的大致有两种主流方式：AMQP、JMS。</p>
<h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1. AMQP"></a>1.2.1. AMQP</h3><p>AMQP 是一种协议，更准确的说是一种 binary wire-level protocol（链接协议）。这是其和 JMS 的本质差别，AMQP不从 API 层进行限定，而是直接定义网络交换的数据格式。</p>
<h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2. JMS"></a>1.2.2. JMS</h3><p>JMS 即 Java 消息服务（JavaMessage Service）应用程序接口，是一个 Java 平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h3 id="1-2-3-AMQP-与-JMS-区别"><a href="#1-2-3-AMQP-与-JMS-区别" class="headerlink" title="1.2.3. AMQP 与 JMS 区别"></a>1.2.3. AMQP 与 JMS 区别</h3><ul>
<li>JMS 是定义了统一的接口，来对消息操作进行统一；AMQP 是通过规定协议来统一数据交互的格式</li>
<li>JMS 限定了必须使用Java语言；AMQP 只是协议，不规定实现方式，因此是跨语言的。</li>
<li>JMS 规定了两种消息模式；而 AMQP 的消息模式更加丰富</li>
</ul>
<h2 id="1-3-消息队列产品"><a href="#1-3-消息队列产品" class="headerlink" title="1.3. 消息队列产品"></a>1.3. 消息队列产品</h2><p>市场上常见的消息队列有如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>开发语言</th>
<th>支持协议</th>
<th>可用性</th>
<th>单机吞吐量</th>
<th>消息延迟</th>
<th>可靠性</th>
</tr>
</thead>
<tbody><tr>
<td>ActiveMQ</td>
<td>Java</td>
<td>AMQP…</td>
<td>高（主从架构）</td>
<td>万级</td>
<td>毫秒级</td>
<td>一般</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>Erlang（并发强）</td>
<td>AMQP</td>
<td>高（主从架构）</td>
<td>万级</td>
<td><strong>微秒级</strong></td>
<td><strong>高</strong></td>
</tr>
<tr>
<td>RocketMQ</td>
<td>Java</td>
<td>自定义协议</td>
<td>非常高（分布式架构）</td>
<td>十万级</td>
<td>毫秒级</td>
<td>高</td>
</tr>
<tr>
<td>Kafka</td>
<td>Scala</td>
<td>自定义协议</td>
<td>非常高（分布式架构）</td>
<td>十万级</td>
<td>毫米级以内</td>
<td>一般</td>
</tr>
</tbody></table>
<ul>
<li>RabbitMQ的可靠性高，消息延迟最低，社区活跃。</li>
<li>Kafka的吞吐量极高，但可能会丢失数据，社区活跃。</li>
<li>如果是对可靠性要求较高的服务（如订单服务），可考虑使用 RabbitMQ&#x2F;RocketMQ，如果对可靠性要求不太高、追求高吞吐量的服务（如日志服务），可考虑使用 Kafka。</li>
</ul>
<h2 id="1-4-RabbitMQ"><a href="#1-4-RabbitMQ" class="headerlink" title="1.4. RabbitMQ"></a>1.4. RabbitMQ</h2><blockquote>
<p>RabbitMQ 是由 erlang 语言开发，基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。官方地址：<a href="http://www.rabbitmq.com/">http://www.rabbitmq.com/</a></p>
</blockquote>
<p>RabbitMQ 基本结构：</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220257.png" alt="image-20220320171238323" style="zoom: 67%;" />

<ul>
<li><code>publisher</code>：生产者，负责产生消息</li>
<li><code>exchange</code>：交换机，负责路由消息到队列中</li>
<li><code>queue</code>：队列，负责缓存消息</li>
<li><code>virtual host</code>：虚拟主机，是对queue、exchange等资源的逻辑分组</li>
<li><code>consumer</code>：消费者，负责处理消息。</li>
</ul>
<p>RabbitMQ 提供了 6 种模式：简单模式，work 模式，Publish&#x2F;Subscribe 发布与订阅模式，Routing 路由模式，Topics主题模式，RPC 远程调用模式（远程调用，不太算MQ）；官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220301.png" alt="1555988678324" style="zoom:50%;" />



<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>官方安装教程：<a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p>
<h2 id="2-1-CentOS7-安装"><a href="#2-1-CentOS7-安装" class="headerlink" title="2.1 CentOS7 安装"></a>2.1 CentOS7 安装</h2><p><strong>2.1.1 安装依赖环境</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y make gcc gcc-c++ m4 openssl openssl-devel ncurses-devel unixODBC unixODBC-devel java java-devel</span><br></pre></td></tr></table></figure>

<p><strong>2.1.2  安装 Erlang</strong></p>
<p>注意 Erlang 和 RabbitMQ 需要版本对应，详情见<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p>下载 Erlang，网址为 <a href="http://erlang.org/download/">http://erlang.org/download/</a> ，比如下载 otp_src_23.3.tar.gz，然后通过 ftp 工具传输到 linux 服务器中，也可以使用 wget 命令在线下载（此文件下载非常慢）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://erlang.org/download/otp_src_23.3.tar.gz <span class="comment"># wget在线下载erlang</span></span><br><span class="line">tar -zxvf otp_src_23.3.tar.gz  <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">cd</span> otp_src_23.3 <span class="comment"># 进入解压文件夹目录</span></span><br><span class="line">./configure --prefix=/usr/local/erlang <span class="comment"># 设置erlang的安装目录</span></span><br><span class="line">make &amp;&amp; make install  <span class="comment"># 编译安装erlang</span></span><br><span class="line">ll /usr/local/erlang/bin  <span class="comment"># 检查erlang是否安装</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/erlang/bin&#x27;</span> &gt;&gt; /etc/profile  <span class="comment"># 将erlang添加到环境变量中</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment"># 刷新环境变量，使配置生效</span></span><br><span class="line">erl  <span class="comment"># 输入erl，若出现下面信息，则erlang安装和配置成功。注意：使用halt().退出</span></span><br></pre></td></tr></table></figure>

<p><img src="/RabbitMQ.assets/image-20210511160105518.png" alt="image-20210511160105518"></p>
<p><strong>2.1.3 安装 RabbitMQ</strong></p>
<p>下载 RabbitMQ，网址为<a href="https://www.rabbitmq.com/install-generic-unix.html#downloads%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%90%8E%E9%80%9A%E8%BF%87">https://www.rabbitmq.com/install-generic-unix.html#downloads，下载后通过</a> ftp 工具传输到 linux 服务器中，也可以使用 wget 命令在线下载</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.16/rabbitmq-server-generic-unix-3.8.16.tar.xz  <span class="comment"># 下载RabbitMQ</span></span><br><span class="line">tar -xvf rabbitmq-server-generic-unix-3.8.16.tar.xz <span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">mv</span> rabbitmq_server-3.8.16/ /usr/local/ <span class="comment"># 将文件移动到/usr/local/目录下，其实可以直接解压到该目录。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/rabbitmq_server-3.8.16/sbin&#x27;</span> &gt;&gt; /etc/profile <span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment"># 刷新环境变量，使配置生效</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management <span class="comment"># 开启web管理插件，即开启管理界面</span></span><br><span class="line">rabbitmq-server -detached <span class="comment"># 启动mq</span></span><br></pre></td></tr></table></figure>

<p>此时如果在浏览器输入<a href="http://ip:15672/%E5%B0%B1%E4%BC%9A%E7%9C%8B%E5%88%B0web%E7%95%8C%E9%9D%A2%E7%9A%84%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81%E5%9D%87%E4%B8%BAguest%EF%BC%8C%E4%BD%86%E5%A6%82%E6%9E%9C%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E7%99%BB%E5%BD%95%EF%BC%8C%E4%BC%9A%E9%81%87%E5%88%B0">http://ip:15672/就会看到web界面的登录界面，默认用户名密码均为guest，但如果此时我们登录，会遇到</a> User can only log in via localhost 这个问题。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220304.png" alt="image-20210511163839251" style="zoom:67%;" />

<p>主要原因是 RabbitMQ 从 3.3.0 开始禁止使用 guest&#x2F;guest 权限通过除 localhost 外的访问，所以我们需要进行一定配置，以使得其他主机也能访问此 RabbitMQ（注意开放端口15672，或者关闭防火墙 systemctl stop firewalld.service）</p>
<ul>
<li><p><u>在3.8版本以前</u>，可以采取下面方法，然后就可以使用账号guest，密码guest进行登录了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim rabbitmq_server-3.7.8/ebin/rabbit.app </span><br><span class="line"></span><br><span class="line">将：&#123;loopback_users, [&lt;&lt;”guest”&gt;&gt;]&#125;，</span><br><span class="line">改为：&#123;loopback_users, [guest]&#125;，</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>在3.8版本以后</u>，就不能使用上述方法了，因为都没有 rabbit.app 文件了，这个时候可以通过新添加一个用户账号来解决。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rabbitmqctl list_users <span class="comment"># 查看所有用户</span></span><br><span class="line">rabbitmqctl add_user zhang 123 <span class="comment"># 新增加一个用户zhang，密码为123</span></span><br><span class="line">rabbitmqctl set_user_tags zhang administrator <span class="comment"># 设置用户zhang的标签为管理员</span></span><br><span class="line">rabbitmqctl set_permissions -p <span class="string">&quot;/&quot;</span> zhang <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="string">&quot;.*&quot;</span> <span class="comment"># 配置用户zhang的权限，指定允许访问的vhost以及write/read，该命令使用户user_admin具有/vhost1这个virtual host中所有资源的配置、写、读权限以便管理其中的资源</span></span><br><span class="line">rabbitmqctl list_user_permissions zhang <span class="comment"># 查看用户zhang的权限</span></span><br></pre></td></tr></table></figure>

<p>当配置好新用户后，就可以使用新用户的账号和密码进行管理界面的登录了，不需要重启服务</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220308.png" alt="image-20210511163536006"></p>
<p>RabbitMQ 的其他命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached <span class="comment"># 启动服务,rabbitmq-server start也可以启动，但并木有后台运行</span></span><br><span class="line">rabbitmqctl stop <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-Docker-安装"><a href="#2-2-Docker-安装" class="headerlink" title="2.2 Docker 安装"></a>2.2 Docker 安装</h2><ol>
<li><p>拉取 RabbitMQ 镜像（其中标签带 management 的，表示启动 Rabbitmq 后可以打开 web 管理界面，否则不行）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker pull rabbitmq:3.8.15-management</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建挂载（映射）目录（文件夹路径可自己选，后面对应上就行）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /home/zhang/rabbitmq</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器 rabbitmq</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name rabbitmq  --hostname mq1 -p 5672:5672 -p 15672:15672 -v /home/zhang/rabbitmq:/var/lib/rabbitmq -h myRabbit -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.8.15-management</span><br><span class="line"><span class="comment"># -p 5672:5672 -p 15672:15672：端口映射，（5672：应用访问端口；15672：控制台Web端口号）</span></span><br><span class="line"><span class="comment"># --name：容器名</span></span><br><span class="line"><span class="comment"># --hostname：设置主机名，注意用于集群部署时使用</span></span><br><span class="line"><span class="comment"># -v：映射目录，前表示主机部分，：后表示容器部分。</span></span><br><span class="line"><span class="comment"># -h 主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）</span></span><br><span class="line"><span class="comment"># -d：容器后台运行</span></span><br><span class="line"><span class="comment"># -e 指定环境变量：RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器输入<code>http://ip:15672</code>即可访问 Rabbitmq 的 web 管理页面，用户名密码是-e参数所指定的用户名和密码。</p>
</li>
</ol>
<h1 id="3-Java-操作-RabbitMQ"><a href="#3-Java-操作-RabbitMQ" class="headerlink" title="3. Java 操作 RabbitMQ"></a>3. Java 操作 RabbitMQ</h1><p>创建一个 maven 项目，并添加 rabbitmq 的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq java 客户端--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1-Hello-World"><a href="#3-1-Hello-World" class="headerlink" title="3.1. Hello World"></a>3.1. Hello World</h2><p>RabbitMQ 是消息代理：它接受并转发消息。可以将其视为邮局，将要发布的邮件放在邮箱中时，而邮局可以确保最终将邮件传递给相应收件人。</p>
<p>下面是 RabbitMQ 最简单的一种模式，“ P”表示生产者，“ C”是表示消费者。中间的框是一个队列 Queue，即保留的消息缓冲区。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220311.png" alt="image-20210513163253459" style="zoom: 80%;" />

<ul>
<li><em>生产</em>仅意味着发送。发送消息的程序是<em>生产者</em>：</li>
<li><em>消费</em>与接收具有相似的含义。一个<em>消费者</em>是一个程序，主要是等待接收信息：</li>
<li><em>队列</em>是 RabbitMQ 内部的邮政信箱的名称。尽管消息流经 RabbitMQ，但它只能存储在<em>队列中</em>。<em>队列</em>仅由主机的存储器＆磁盘限制约束，它本质上是一个大的消息缓冲器。许多<em>生产者</em>可以发送进入一个队列的消息，许多<em>消费者</em>可以尝试从一个<em>队列</em>接收数据。</li>
</ul>
<p>下面将将用Java编写两个程序。一个是生产者，用于发送消息；一个是消费者，用于接收消息。</p>
<p><strong>3.1.1. 编写生产者代码</strong></p>
<p>创建一个类 com.tju.producer.Producer_HelloWorld</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException,TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建队列 Queue</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名称(如果没有，则会自动创建)</span></span><br><span class="line"><span class="comment">            参数二：是否持久化</span></span><br><span class="line"><span class="comment">            参数三：是否独占，只能有一个消费者监听队列</span></span><br><span class="line"><span class="comment">            参数四：是否自动删除（当没有消费者时）</span></span><br><span class="line"><span class="comment">            参数五：一些其他参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello  World!&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称，简单模式下交换机会使用默认的&quot;&quot;，设置为空字符串即可</span></span><br><span class="line"><span class="comment">            参数2：路由key名称</span></span><br><span class="line"><span class="comment">            参数3：配置信息</span></span><br><span class="line"><span class="comment">            参数4：真实发送的消息数据（字节数组的形式byte[]）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.1.2. 编写消费者代码</strong></p>
<p>创建一个类 com.tjuconsumer.consumer_HelloWorld</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建队列 Queue（其实如果队列已经被生产者创建后，就无需再创建,但由于可能不知道生产者消费者的执行顺序，所以就双方都建立，避免队列不存在）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名称(如果没有，则会自动创建)</span></span><br><span class="line"><span class="comment">            参数二：是否持久化</span></span><br><span class="line"><span class="comment">            参数三：是否独占，只能有一个消费者监听队列</span></span><br><span class="line"><span class="comment">            参数四：是否自动删除（当没有消费者时）</span></span><br><span class="line"><span class="comment">            参数五：一些其他参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息（比如交换机，路由key...）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 真实数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag:&quot;</span> + consumerTag);</span><br><span class="line">                System.out.println(<span class="string">&quot;Exchange:&quot;</span> + envelope.getExchange());</span><br><span class="line">                System.out.println(<span class="string">&quot;RoutingKey:&quot;</span> + envelope.getRoutingKey());</span><br><span class="line">                System.out.println(<span class="string">&quot;properties:&quot;</span> + properties);</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名称</span></span><br><span class="line"><span class="comment">            参数2：是否自动确认</span></span><br><span class="line"><span class="comment">            参数3：回调函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">        <span class="comment">// 注意消费者不要关闭资源，一直监听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.1.3. 执行</strong></p>
<p>执行消费者和生产者两个代码（顺序无所谓），然后就会发现，生产者发送的消息，被消费者所接收了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220317.png" alt="image-20210513165036727"></p>
<h2 id="3-2-Work-Queues"><a href="#3-2-Work-Queues" class="headerlink" title="3.2. Work Queues"></a>3.2. Work Queues</h2><p>在 Hello World 模式下，一个队列只用于特定的一个生产者和一个消费者。在工作队列（Work queues）模式中，我们将创建一个<em>工作队列</em>，该<em>队列</em>将用于在多个工作人员之间分配耗时的任务。</p>
<p>在此模式下，生产者发送的多个消息，可以有多个消费者依次接收（但一个消息只有一个人能接收）。</p>
<p><strong>应用场景</strong>：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220321.png" alt="image-20210513165617572" style="zoom: 80%;" />

<p>下面将将用Java编写三个程序。一个是生产者，用于发送消息；两个是消费者，用于接收消息。</p>
<p><strong>3.2.1. 编写生产者代码</strong></p>
<p>创建一个类com.tju.producer.Producer_WorkQueues</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_WorkQueues</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建队列 Queue</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：队列名称(如果没有，则会自动创建)</span></span><br><span class="line"><span class="comment">            参数二：是否持久化</span></span><br><span class="line"><span class="comment">            参数三：是否独占，只能有一个消费者监听队列</span></span><br><span class="line"><span class="comment">            参数四：是否自动删除（当没有消费者时）</span></span><br><span class="line"><span class="comment">            参数五：一些其他参数设置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;【&quot;</span> + i + <span class="string">&quot;】 Hello  World!&quot;</span>;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">                参数1：交换机名称，简单模式下交换机会使用默认的&quot;&quot;，设置为空字符串即可</span></span><br><span class="line"><span class="comment">                参数2：路由名称</span></span><br><span class="line"><span class="comment">                参数3：配置信息</span></span><br><span class="line"><span class="comment">                参数4：真实发送的消息数据（字节数组的形式byte[]）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;work_queues&quot;</span>, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2.2. 编写消费者代码</strong></p>
<p>创建第一个类com.tjuconsumer.Consumer_WorkQueues1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_WorkQueues1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建队列 Queue (参数1：队列名称(如果没有，则会自动创建) 参数二：是否持久化 参数三：是否独占，只能有一个消费者监听队列 参数四：是否自动删除（当没有消费者时）参数五：一些其他参数设置)</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息（比如交换机，路由key...）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 真实数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意消费者不要关闭资源，一直监听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建第二个类com.tjuconsumer.Consumer_WorkQueues2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_WorkQueues2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建队列 Queue (参数1：队列名称(如果没有，则会自动创建) 参数二：是否持久化 参数三：是否独占，只能有一个消费者监听队列 参数四：是否自动删除（当没有消费者时）参数五：一些其他参数设置)</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 回调方法，当收到消息后，会自动执行该方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> consumerTag 标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> envelope 获取一些信息（比如交换机，路由key...）</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> properties 配置信息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 真实数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;work_queues&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">        <span class="comment">// 注意消费者不要关闭资源，一直监听</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.2.3. 执行</strong></p>
<p>首先执行两个消费者代码，接着执行生产者代码，然后就会发现，生产者发送的消息，被两个消费者所依次接收了。</p>
<ul>
<li><p>第一个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220326.png" alt="image-20210513175350936"></p>
</li>
<li><p>第二个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220328.png" alt="image-20210513175437273"></p>
</li>
</ul>
<h2 id="3-3-Publish-x2F-Subscribe"><a href="#3-3-Publish-x2F-Subscribe" class="headerlink" title="3.3. Publish&#x2F;Subscribe"></a>3.3. Publish&#x2F;Subscribe</h2><p>在 Work queues 模式下，每个消息都恰好交付给一个消费者。在发布&#x2F;订阅（Publish&#x2F;Subscribe）模式中，我们将同一个消息可以传达给多个消费者。</p>
<p>在此模式下，生产者发送的单个消息，可以有多个消费者进行接收。</p>
<p>相比于之前的模式，发布&#x2F;订阅模式多了一个交换机（Exchange），由下图中的X表示。生产者不再直接把消息发送给队列，而是发送给交换机。交换机可以通过与某个队列绑定，会把从生产者获得的消息传递给相应满足规则（路由key）的队列。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220332.png" alt="image-20210513180049284" style="zoom:80%;" />

<ul>
<li>生产者：也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>消费者：消息的接受者，会一直等待消息到来。</li>
<li>消息队列用于接收消息、缓存消息、发送消息。</li>
<li>交换机：图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：<ul>
<li><code>Fanout</code>：广播，将消息交给所有绑定到交换机的队列</li>
<li><code>Direct</code>：定向，把消息交给符合指定routing key 的队列</li>
<li><code>Topic</code>：通配符，把消息交给符合routing pattern（路由模式） 的队列</li>
</ul>
</li>
</ul>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给 broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p><strong>发布订阅模式与工作队列模式的区别</strong></p>
<p>1、工作队列模式不用定义交换机，而发布&#x2F;订阅模式需要定义交换机。 </p>
<p>2、发布&#x2F;订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。</p>
<p>3、发布&#x2F;订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑 定到默认的交换机 。</p>
<p>下面将将用Java编写三个程序。一个是生产者，用于发送消息；两个是消费者，用于接收消息。</p>
<p><strong>3.3.1. 编写生产者代码</strong></p>
<p>创建一个类com.tju.producer.Producer_PubSub</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_PubSub</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建交换机</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称</span></span><br><span class="line"><span class="comment">            参数2：交换机的类型（direct定向、fanout广播、topic通配符、headers参数匹配）</span></span><br><span class="line"><span class="comment">            参数3：是否持久化</span></span><br><span class="line"><span class="comment">            参数4：自动删除</span></span><br><span class="line"><span class="comment">            参数5：内部使用，一般false</span></span><br><span class="line"><span class="comment">            参数6：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_fanout&quot;</span>, BuiltinExchangeType.FANOUT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 创建队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_fanout_queue1&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_fanout_queue2&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 7. 绑定队列和交换机(参数：队列名称、交换机名称、路由key，即绑定规则（如果交换机类型为fanout，则只需设置为&quot;&quot;）)</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_fanout_queue1&quot;</span>,<span class="string">&quot;test_fanout&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_fanout_queue2&quot;</span>,<span class="string">&quot;test_fanout&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 8. 发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;这是日志信息【&quot;</span> + i + <span class="string">&quot;】&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;test_fanout&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 9. 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3.2. 编写消费者代码</strong></p>
<p>创建第一个类 com.tjuconsumer.Consumer_PubSub1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_PubSub1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"><span class="comment">//        // 5. 创建队列 Queue (参数1：队列名称(如果没有，则会自动创建) 参数二：是否持久化 参数三：是否独占，只能有一个消费者监听队列 参数四：是否自动删除（当没有消费者时）参数五：一些其他参数设置)</span></span><br><span class="line"><span class="comment">//        channel.queueDeclare(&quot;test_fanout_queue1&quot;, false, false, false, null);</span></span><br><span class="line">        <span class="comment">// 当创建过队列后，其实就没必要再重新创建了，直接根据队列名接收消息就可以了</span></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者1接收:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_fanout_queue1&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建第二个类 com.tjuconsumer.Consumer_PubSub2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_PubSub2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消费者2接收:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_fanout_queue2&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.3.3. 执行</strong></p>
<p>首先执行两个消费者代码，接着执行生产者代码，然后就会发现，生产者发送的消息，被两个消费者均接收了。</p>
<ul>
<li><p>第一个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220337.png" alt="image-20210513181738309"></p>
</li>
<li><p>第二个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220339.png" alt="image-20210513181750695"></p>
</li>
</ul>
<h2 id="3-4-Routing"><a href="#3-4-Routing" class="headerlink" title="3.4. Routing"></a>3.4. Routing</h2><p>路由模式特点：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220343.png" alt="image-20210513182141441" style="zoom:80%;" />

<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>
</ul>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给 broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p>下面将将用Java编写三个程序。一个是生产者，用于发送消息；两个是消费者，用于接收消息。</p>
<p>在编码上与 <code>Publish/Subscribe发布与订阅模式</code> 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。</p>
<p><strong>3.4.1. 编写生产者代码</strong></p>
<p>创建一个类com.tju.producer.Producer_Routing</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_Routing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建交换机</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称</span></span><br><span class="line"><span class="comment">            参数2：交换机的类型（direct定向、fanout广播、topic通配符、headers参数匹配）</span></span><br><span class="line"><span class="comment">            参数3：是否持久化</span></span><br><span class="line"><span class="comment">            参数4：自动删除</span></span><br><span class="line"><span class="comment">            参数5：内部使用，一般false</span></span><br><span class="line"><span class="comment">            参数6：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_direct&quot;</span>, BuiltinExchangeType.DIRECT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 创建队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_direct_queue1&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_direct_queue2&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 7. 绑定队列和交换机(参数：队列名称、交换机名称、路由key，即绑定规则（如果交换机类型为fanout，则只需设置为&quot;&quot;）)</span></span><br><span class="line">        <span class="comment">// 队列1与交换机绑定，,规则为error</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_direct_queue1&quot;</span>,<span class="string">&quot;test_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="comment">// 队列2与交换机绑定，,规则为error、info、warning</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_direct_queue2&quot;</span>,<span class="string">&quot;test_direct&quot;</span>,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_direct_queue2&quot;</span>,<span class="string">&quot;test_direct&quot;</span>,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_direct_queue2&quot;</span>,<span class="string">&quot;test_direct&quot;</span>,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        <span class="comment">// 8. 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;这是一条日志信息&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称</span></span><br><span class="line"><span class="comment">            参数2：Routing key，即绑定的规则</span></span><br><span class="line"><span class="comment">            参数3：配置信息</span></span><br><span class="line"><span class="comment">            参数4：要发送的消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_direct&quot;</span>,<span class="string">&quot;info&quot;</span>,<span class="literal">null</span>,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 9. 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.4.2. 编写消费者代码</strong></p>
<p>创建第一个类com.tjuconsumer.Consumer_Routing1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Routing1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;将日志信息打印到控制台...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_direct_queue1&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建第二个类com.tjuconsumer.Consumer_Routing2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Routing2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;将日志信息保存到磁盘...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_direct_queue2&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.4.3. 执行</strong></p>
<p>首先执行两个消费者代码，接着执行生产者代码，然后就会发现，由于我们发送消息时，绑定的规则为info，只与队列2的规则匹配，而与队列1的规则不匹配，从而消息只会发送到队列2，不会发送到队列1，因此消费者1不能收到消息，消费者2可以收到消息。</p>
<ul>
<li><p>第一个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220348.png" alt="image-20210513182938856"></p>
</li>
<li><p>第二个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220350.png" alt="image-20210513182900443"></p>
</li>
</ul>
<h2 id="3-5-Topics"><a href="#3-5-Topics" class="headerlink" title="3.5. Topics"></a>3.5. Topics</h2><p><code>Topic</code>类型与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<ul>
<li><p>路由格式必须以 <code>.</code> 分隔，比如 <code>user.email</code> 或者 <code>user.aaa.email</code></p>
</li>
<li><p><code>#</code>：匹配一个或多个词</p>
</li>
<li><p><code>*</code>：匹配不多不少恰好1个词</p>
</li>
</ul>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.insert.abc</code> 或者 <code>item.insert</code></p>
<p><code>item.*</code>：只能匹配<code>item.insert</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220354.png" alt="image-20210513183140138"></p>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p>下面将将用Java编写三个程序。一个是生产者，用于发送消息；两个是消费者，用于接收消息。</p>
<p><strong>3.4.1. 编写生产者代码</strong></p>
<p>创建一个类com.tju.producer.Producer_Topics</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer_Topics</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 创建交换机</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称</span></span><br><span class="line"><span class="comment">            参数2：交换机的类型（direct定向、fanout广播、topic通配符、headers参数匹配）</span></span><br><span class="line"><span class="comment">            参数3：是否持久化</span></span><br><span class="line"><span class="comment">            参数4：自动删除</span></span><br><span class="line"><span class="comment">            参数5：内部使用，一般false</span></span><br><span class="line"><span class="comment">            参数6：其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.exchangeDeclare(<span class="string">&quot;test_topic&quot;</span>, BuiltinExchangeType.TOPIC,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 创建队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_topic_queue1&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;test_topic_queue2&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 7. 绑定队列和交换机(参数：队列名称、交换机名称、路由key，即绑定规则（如果交换机类型为fanout，则只需设置为&quot;&quot;）)</span></span><br><span class="line">        <span class="comment">// 队列1与交换机绑定，规则为以order开头或者error结尾</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_topic_queue1&quot;</span>,<span class="string">&quot;test_topic&quot;</span>,<span class="string">&quot;#.error&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_topic_queue1&quot;</span>,<span class="string">&quot;test_topic&quot;</span>,<span class="string">&quot;order.#&quot;</span>);</span><br><span class="line">        <span class="comment">// 队列2与交换机绑定，规则为任意</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;test_topic_queue2&quot;</span>,<span class="string">&quot;test_topic&quot;</span>,<span class="string">&quot;#.#&quot;</span>);</span><br><span class="line">        <span class="comment">// 8. 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;这是一条日志信息&quot;</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            参数1：交换机名称</span></span><br><span class="line"><span class="comment">            参数2：Routing key，即绑定的规则</span></span><br><span class="line"><span class="comment">            参数3：配置信息</span></span><br><span class="line"><span class="comment">            参数4：要发送的消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;test_topic&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="literal">null</span>,message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 9. 释放资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.4.2. 编写消费者代码</strong></p>
<p>创建第一个类com.tjuconsumer.Consumer_Topics1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Topics1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;将日志信息打印到控制台...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_topic_queue1&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建第二个类com.tjuconsumer.Consumer_Topics2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer_Topics2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        <span class="comment">// 2. 设置参数</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">// ip,默认值&quot;localhost&quot;</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>); <span class="comment">// 端口，默认值5672</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;tju_virtual&quot;</span>); <span class="comment">// 虚拟机，默认值&quot;/&quot;</span></span><br><span class="line">        factory.setUsername(<span class="string">&quot;zhang&quot;</span>);  <span class="comment">// 用户名，默认值guest</span></span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);  <span class="comment">// 密码，默认值guest</span></span><br><span class="line">        <span class="comment">// 3. 创建连接 Connection</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">// 4. 创建 Channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">// 5. 接收消息</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;body:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;将日志信息保存到磁盘...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  参数1：队列名称 参数2：是否自动确认 参数3：回调函数</span></span><br><span class="line">        channel.basicConsume(<span class="string">&quot;test_topic_queue2&quot;</span>, <span class="literal">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.4.3. 执行</strong></p>
<p>首先执行两个消费者代码，接着执行生产者代码，然后就会发现，由于我们发送消息时，绑定的规则为x，只与队列2的规则匹配，而与队列1的规则不匹配，从而消息只会发送到队列2，不会发送到队列1，因此消费者1不能收到消息，消费者2可以收到消息。</p>
<ul>
<li><p>第一个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220401.png" alt="image-20210513182938856"></p>
</li>
<li><p>第二个消费者输出的内容</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220358.png" alt="image-20210513182900443"></p>
</li>
</ul>
<h1 id="4-SpringBoot-整合-RabbitMQ"><a href="#4-SpringBoot-整合-RabbitMQ" class="headerlink" title="4. SpringBoot 整合 RabbitMQ"></a>4. SpringBoot 整合 RabbitMQ</h1><p>前面已经介绍了 Java 代码如何操作 RabbitMQ了，但是可以发现，代码非常繁琐，可以利用 SpringBoot 直接整合 RabbitMQ 简化操作，提升开发效率。</p>
<h2 id="4-1-Hello-World"><a href="#4-1-Hello-World" class="headerlink" title="4.1 Hello World"></a>4.1 Hello World</h2><blockquote>
<p>一个生产者，一个消费者。</p>
</blockquote>
<p>Hello World 是 RabbitMQ 最简单的一种模式，“ P”表示生产者，“ C”是表示消费者。中间的框是一个队列 Queue，即保留的消息缓冲区。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220404.png" alt="image-20210513163253459" style="zoom: 80%;" />

<ul>
<li><em>生产</em>仅意味着发送。发送消息的程序是<em>生产者</em>：</li>
<li><em>消费</em>与接收具有相似的含义。一个<em>消费者</em>是一个程序，主要是等待接收信息：</li>
<li><em>队列</em>是 RabbitMQ 内部的邮政信箱的名称。尽管消息流经 RabbitMQ，但它只能存储在<em>队列中</em>。<em>队列</em>仅由主机的存储器＆磁盘限制约束，它本质上是一个大的消息缓冲器。许多<em>生产者</em>可以发送进入一个队列的消息，许多<em>消费者</em>可以尝试从一个<em>队列</em>接收数据。</li>
</ul>
<p><strong>生产者发送消息</strong></p>
<p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 application.properties 中配置 rabbitmq</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置rabbitmq连接信息</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>=<span class="string">tju_virtual</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">zhang</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>

<p>创建消息队列（也可以在rabbitmq web界面直接创建）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqConfig</span> &#123;</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLO_WORLD</span> <span class="operator">=</span> <span class="string">&quot;hello.world&quot;</span>;</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="meta">@Bean()</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">helloWorldQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(HELLO_WORLD).build();<span class="comment">// 创建一个名称为 hello.world的队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 springboot 提供的 RabbitmqTemplate 进行消息的发送与接收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hello World 模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHelloWorld</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="string">&quot;hello.world&quot;</span>; <span class="comment">// 注意队列应该提前创建好（配置类或直接在web界面创建）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitTemplate！&quot;</span>; <span class="comment">// 消息可以为任意类型，会自动转换</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queue,message);  <span class="comment">// 发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者接收消息</strong></p>
<p>引入依赖、在 application.properties 中配置 rabbitmq。</p>
<p>监听消息，新建一个类注入到 IOC 中，并使用 @RabbitListener 注解指定监听的队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitmqListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【 Hello World 模式】监听某个队列的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;hello.world&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloWorldListener</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者接收到的消息为：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 SpringBoot 服务即可。</p>
<p>注意：消息一旦消费就会从队列删除，RabbitMQ 没有消息回溯功能</p>
<h2 id="4-2-Work-Queues"><a href="#4-2-Work-Queues" class="headerlink" title="4.2 Work Queues"></a>4.2 Work Queues</h2><blockquote>
<p>一个生产者，多个消费者，且一条消息只能被一个消费者所消费。</p>
</blockquote>
<p>在 Hello World 模式下，一个队列只用于特定的一个生产者和一个消费者。在工作队列（Work queues）模式中，我们将创建一个<em>工作队列</em>，该<em>队列</em>将用于在多个工作人员之间分配耗时的任务。</p>
<p>在此模式下，生产者发送的多个消息，可以有多个消费者依次接收（但一个消息只有一个人能接收）。</p>
<p><strong>应用场景</strong>：对于 任务过重或任务较多情况，可能生产消息的速度会 远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理，此时使用工作队列可以提高任务处理的速度。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220409.png" alt="image-20210513165617572" style="zoom: 80%;" />

<p><strong>生产者发送消息</strong></p>
<p>在配置类中创建队列  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WORK_QUEUES</span> <span class="operator">=</span><span class="string">&quot;work.queues&quot;</span>;</span><br><span class="line"><span class="meta">@Bean()</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">workQueuesQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WORK_QUEUES).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 RabbitTemplate 发送消息【和 Hello World 模式一致】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Work Queues 模式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueues</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="string">&quot;work.queues&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitTemplate，Message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(queue,message + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者接收消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Work Queues 模式】监听某个队列的消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queues&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">workQueuesListener1</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者1接收到的消息为：&quot;</span> + message);</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);  <span class="comment">// 模拟不同消费者，有不同的消息处理能力</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Work Queues 模式】监听某个队列的消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queues&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">WorkQueuesListener2</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到的消息为：&quot;</span> + message);</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会发现，消费者 1 和消费者 2 的消息处理能力虽然不同，却消费同样多的消息，也就是说消息被『平均消费』了。</p>
<p>然而由于不同的消费者有不同的处理速度，处理速度快的应该处理更多的消息，我们可以通过添加以下配置达到这种『能者多劳』的效果，此时消费者 1 和消费者 2 处理的消息数量将不同。 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息（也可以实现限流的效果）</span></span><br><span class="line"><span class="attr">spring.rabbitmq.listener.simple.prefetch</span>=<span class="string">1</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-Publish-x2F-Subscribe"><a href="#4-3-Publish-x2F-Subscribe" class="headerlink" title="4.3 Publish&#x2F;Subscribe"></a>4.3 Publish&#x2F;Subscribe</h2><blockquote>
<p>生产者发送的单个消息，所有消费者都进行接收。</p>
</blockquote>
<p>在 Work queues 模式下，每个消息都恰好交付给一个消费者。在发布&#x2F;订阅（Publish&#x2F;Subscribe）模式中，我们将同一个消息可以传达给多个消费者。</p>
<p>相比于之前的模式，发布&#x2F;订阅模式多了一个交换机（Exchange），由下图中的X表示。生产者不再直接把消息发送给队列，而是发送给交换机。交换机可以通过与某个队列绑定，会把从生产者获得的消息传递给相应满足规则（路由key）的队列。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220413.png" alt="image-20210513180049284" style="zoom:80%;" />

<ul>
<li>生产者：也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li>
<li>消费者：消息的接受者，会一直等待消息到来。</li>
<li>消息队列用于接收消息、缓存消息、发送消息。</li>
<li>交换机：图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：<ul>
<li><code>Fanout</code>：广播，将消息交给所有绑定到交换机的队列</li>
<li><code>Direct</code>：定向，把消息交给符合指定 routing key 的队列</li>
<li><code>Topic</code>：通配符，把消息交给符合 routing pattern（路由模式） 的队列</li>
</ul>
</li>
</ul>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给 broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p><strong>消费者发送消息</strong></p>
<p>在配置类中创建队列和交换机，并进行绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_QUEUE1</span> <span class="operator">=</span><span class="string">&quot;fanout.queue1&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_QUEUE2</span> <span class="operator">=</span><span class="string">&quot;fanout.queue2&quot;</span>;</span><br><span class="line"><span class="comment">// 交换机名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FANOUT_EXCHANGE</span> <span class="operator">=</span><span class="string">&quot;fanout.exchange&quot;</span>;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line"><span class="meta">@Bean()</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(FANOUT_QUEUE1).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean()</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(FANOUT_QUEUE2).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明交换机（广播形式）</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 绑定队列和交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(<span class="meta">@Qualifier(&quot;fanoutQueue1&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(<span class="meta">@Qualifier(&quot;fanoutQueue2&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;fanoutExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 RabbitTemplate 发送消息【和 Hello World 模式一致】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Publish/Subscribe 模式,交换机使用 Fanout 广播</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;fanout.exchange&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RabbitTemplate！，Message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;&quot;</span>,message + i); <span class="comment">// 会将消息发送到交换机，而不是队列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者接收消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Publish/Subscribe 模式】监听某个队列的消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fanoutQueueListener1</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者1接收到的消息为：&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Publish/Subscribe 模式】监听某个队列的消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fanoutQueueListener2</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到的消息为：&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时消费者 1 和消费者 2 均接收到生产者发送的所有消息。</p>
<h2 id="4-4-Routing"><a href="#4-4-Routing" class="headerlink" title="4.4 Routing"></a>4.4 Routing</h2><blockquote>
<p>生产者发送的单个消息，可以绑定多个消费者进行接收。</p>
</blockquote>
<p>路由模式特点：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key），因此成为路由模式。</li>
<li>消息的发送方在向 Exchange 发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220417.png" alt="image-20210513182141441" style="zoom:80%;" />

<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>
</ul>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给 broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p>我们可以向之前那样，先在配置类中声明队列、交换机、绑定等信息，不过还有一种更简单的写法，直接在消费者的监听类中，在 @RabbitListener 注解中声明各种信息！</p>
<p><strong>消费者接收消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Routing 模式】监听某个队列的消息,交换机采用 direct定向方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;direct.queue1&quot;), // 队列名称</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT), // 交换机名称和类型</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;user&quot;&#125;)  // key 可以写多个，用逗号分隔开</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directQueueListener1</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户接收到的消息为：&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Routing 模式】监听某个队列的消息,交换机采用 direct定向方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;direct.queue2&quot;), // 队列名称</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;direct.exchange&quot;, type = ExchangeTypes.DIRECT), // 交换机名称和类型</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;admin&quot;&#125;)  // key 可以写多个，用逗号分隔开</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">directQueueListener2</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;管理员接收到的消息为：&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Routing 模式,交换机使用 direct 定向</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;direct.exchange&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message2User</span> <span class="operator">=</span> <span class="string">&quot;这条消息只有用户可以收到！&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message2Admin</span> <span class="operator">=</span> <span class="string">&quot;这条消息只有管理员可以收到！&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;user&quot;</span>,message2User); <span class="comment">// 会将消息发送到交换机，而不是队列</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;admin&quot;</span>,message2Admin); <span class="comment">// 会将消息发送到交换机，而不是队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时不同消费者只能接收到符合所绑定key的消息。</p>
<h2 id="4-5-Topics"><a href="#4-5-Topics" class="headerlink" title="4.5 Topics"></a>4.5 Topics</h2><blockquote>
<p>生产者发送的单个消息，可以绑定多个消费者（支持通配符）进行接收。</p>
</blockquote>
<p><code>Topic </code>类型与 <code>Direct </code>相比，都是可以根据 <code>RoutingKey</code> 把消息路由到不同的队列。只不过 <code>Topic</code> 类<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候<strong>使用通配符</strong>！</p>
<p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以点分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<ul>
<li><p>路由格式必须以 <code>.</code> 分隔，比如 <code>user.email</code> 或者 <code>user.aaa.email</code></p>
</li>
<li><p><code>#</code>：匹配一个或多个词</p>
</li>
<li><p><code>*</code>：匹配不多不少恰好1个词</p>
</li>
</ul>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.insert.abc</code> 或者 <code>item.insert</code></p>
<p><code>item.*</code>：只能匹配<code>item.insert</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220421.png" alt="image-20210513183140138"></p>
<p>具体流程为：</p>
<ul>
<li><p>每个消费者监听自己的队列。</p>
</li>
<li><p>生产者将消息发给broker（其实就是发给交换机），由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息</p>
</li>
</ul>
<p><strong>消费者接收消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Topics 模式】监听某个队列的消息,交换机采用 Topic 方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topic.queue1&quot;), // 队列名称</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC), // 交换机名称和类型</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;china.*&quot;&#125;)  // key 可以写多个，并且支持通配符写法！！用逗号分隔开</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topicQueueListener1</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;收到前缀为china的消息：&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 【 Topics 模式】监听某个队列的消息,交换机采用 Topic 方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 接收到的消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;topic.queue2&quot;), // 队列名称</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;topic.exchange&quot;, type = ExchangeTypes.TOPIC), // 交换机名称和类型</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;#.videos&quot;&#125;)  // key 可以写多个，并且支持通配符写法！！用逗号分隔开</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topicQueueListener2</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;收到后缀为videos的消息：&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者发送消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Topics 模式,交换机使用 topic 定向</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">exchange</span> <span class="operator">=</span> <span class="string">&quot;topic.exchange&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message1</span> <span class="operator">=</span> <span class="string">&quot;消息为：china.people&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> <span class="string">&quot;消息为：us.videos&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message3</span> <span class="operator">=</span> <span class="string">&quot;消息为：china.videos&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;china.people&quot;</span>,message1); </span><br><span class="line">    rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;us.videos&quot;</span>,message2); </span><br><span class="line">    rabbitTemplate.convertAndSend(exchange,<span class="string">&quot;china.videos&quot;</span>,message3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-模式总结"><a href="#4-6-模式总结" class="headerlink" title="4.6. 模式总结"></a>4.6. 模式总结</h2><p>RabbitMQ工作模式：</p>
<p><strong>1、简单模式 HelloWorld</strong><br>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p>
<p><strong>2、工作队列模式 Work Queue</strong><br>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p>
<p><strong>3、发布订阅模式 Publish&#x2F;Subscribe</strong><br>需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列</p>
<p><strong>4、路由模式 Routing</strong><br>需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key 将消息发送到对应的队列</p>
<p><strong>5、通配符模式 Topics</strong><br>需要设置类型为topic的交换机，交换机和队列进行绑定，并且指定<strong>通配符</strong>方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列</p>
<p>笼统的说，RabbitMQ工作模式分为两类</p>
<ul>
<li><p>一类是直接使用队列，包含Hello World 和 Work Queues 模式，不同的在于消费者数量而已。</p>
</li>
<li><p>另一类使用交换机，可以使得不同消费者消费相同或者不同的消息，包含 Publish&#x2F;Subscribe、Routing、Topics模式，不同的是交换机将消息发送到队列的方式不同，Pushlish&#x2F;Subscribe 采用广播形式，所有队列都存有消息；Routing 采用路由形式，会根据 routing key，将消息发送到指定的队列；Topics 和 Routing 基本一致，只不过 routing key支持通配符而已！</p>
</li>
</ul>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>Linux基础知识</title>
    <url>/2022/02/23/Linux/</url>
    <content><![CDATA[<h1 id="一-目录树结构（directory-tree）"><a href="#一-目录树结构（directory-tree）" class="headerlink" title="一. 目录树结构（directory tree）"></a>一. 目录树结构（directory tree）</h1><p><strong>Linux 世界里，一切皆文件。</strong></p>
<p>所谓的目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种档案架构。</p>
<ol>
<li><p>Linux 的目录中有且只有一个根目录。</p>
<span id="more"></span>
</li>
<li><p>Linux 的各个目录存放的内容是规划好，不用乱放文件。</p>
</li>
<li><p>Linux 是以文件的形式管理我们的设备，因此 linux 系统，一切皆为文件。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100856.png" style="zoom:80%;" />

<ul>
<li><code>/bin：</code> 是 Binary 的缩写，这个目录存放着最经常使用的<u>命令</u>。</li>
<li>&#x2F;sbin：s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><code>/home：</code>存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><code>/root：</code>该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li>&#x2F;lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><code>/etc</code>：所有的系统管理所需要的<u>配置文件</u>。</li>
<li><code>/usr/local</code>：这是一个非常重要的目录，用户的很多<u>应用程序</u>和文件都放在这个目录下，类似与 windows 下的 program files 目录。(usr是Unix System Resource&#x2F;Unix Software Resource的缩写)</li>
<li><code>/boot：</code>存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li>&#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</li>
<li>&#x2F;srv：service 的缩写，该目录存放一些服务启动之后需要提供的数据。</li>
<li>&#x2F;sys：这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs。</li>
<li>&#x2F;tmp：这个目录是用来存放一些临时文件的。</li>
<li>&#x2F;dev：类似 windows 的设备管理器，把所有的硬件用文件的形式存储。</li>
<li><code>/media：</code>linux 系统会自动识别一些设备，例如 U 盘光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下（系统默认挂载目录）。</li>
<li><code>/mnt：</code>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看里面的内容了（手动挂载目录）。</li>
<li><code>/opt：</code>这是给主机额外安装软件所摆放的目录，如安装 ORACLE 数据库就可放到该目录下。默认为空。</li>
<li>&#x2F;usr&#x2F;local：这是另一个给主机额外安装软件所安装的目录，一般是通过编译源码的方式安装的程序。</li>
<li><code>/var：</code>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件。</li>
<li>&#x2F;selinux：SELinux 是一种安全子系统，它能控制程序只能访问特定文件。</li>
</ul>
<h1 id="二-常用操作"><a href="#二-常用操作" class="headerlink" title="二. 常用操作"></a>二. 常用操作</h1><p>常见执行 Linux 命令的格式为：<strong>命令名称 [命令参数] [命令对象]</strong></p>
<p>可以把多个命令放在同一行上，命令之间用 “;” 分开。</p>
<p>linux严格区分大小写。</p>
<h2 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1. 快捷键"></a>1. 快捷键</h2><ul>
<li><p>TAB键可以用于命令补全和文件补全</p>
</li>
<li><p>Ctrl + c 可以中断当前程序</p>
</li>
<li><p>Ctrl + d 退出 shell，logout</p>
</li>
<li><p>Ctrl + l 清除屏幕内容，效果等同于 clear</p>
</li>
<li><p>Ctrl + Backspace（退格键）可以清除有时候由于使用退格键，屏幕出现^H的情况</p>
</li>
<li><p>Ctrl + a 光标移到最前面</p>
</li>
<li><p>Ctrl + e 光标移到最后面</p>
</li>
</ul>
<h2 id="2-关机重启"><a href="#2-关机重启" class="headerlink" title="2. 关机重启"></a>2. 关机重启</h2><p>（1）关机&amp;重启命令</p>
<ul>
<li><p>shutdown -h now：表示立即关机</p>
</li>
<li><p>shutdown -h 1：表示1分钟后关机（如果直接输入 shutdown，默认就是执行这条指令）</p>
</li>
<li><p>shutdown -r now：立即重启</p>
</li>
<li><p>halt：直接使用，关机</p>
</li>
<li><p>reboot 重启系统</p>
</li>
<li><p>sync：把内存的数据同步到磁盘上</p>
</li>
</ul>
<blockquote>
<p>当我们关机或者重启时，都应该先执行一下 sync，防止数据丢失。</p>
</blockquote>
<p>（2）用户登录注销</p>
<ul>
<li><p>登录时少用 root 账号登录，以避免操作失误的损失</p>
</li>
<li><p>平时可登录普通账户，再用“su - 用户名”切换成管理员登录</p>
</li>
<li><p>logout：注销用户</p>
</li>
</ul>
<blockquote>
<p>在图形运行级别无效，在运行级别3有效。</p>
</blockquote>
<h2 id="3-帮助指令"><a href="#3-帮助指令" class="headerlink" title="3. 帮助指令"></a>3. 帮助指令</h2><p>（1）man 指令（man 是 manual 手册的缩写）</p>
<blockquote>
<p>man [命令或配置文件]</p>
<p>举例:man ls</p>
</blockquote>
<p>（2）help 指令</p>
<blockquote>
<p>[命令或配置文件]  –help</p>
<p>举例：ls –help</p>
</blockquote>
<h1 id="三-vi-和-vim-编辑器"><a href="#三-vi-和-vim-编辑器" class="headerlink" title="三. vi 和 vim 编辑器"></a>三. vi 和 vim 编辑器</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><ul>
<li>所有 Linux 系统都会内置 vi 文本编辑器</li>
<li>vim 是 vi 的升级版，可以主动以字体颜色分辨语法的正确性，代码补完和编译，错误跳转等功能。</li>
<li>使用命令 vim [file1 file2 file3 …]  即可打开单个或多个文件</li>
</ul>
<h2 id="2-三种模式"><a href="#2-三种模式" class="headerlink" title="2. 三种模式"></a>2. 三种模式</h2><h3 id="（1）一般-x2F-正常模式"><a href="#（1）一般-x2F-正常模式" class="headerlink" title="（1）一般&#x2F;正常模式"></a>（1）一般&#x2F;正常模式</h3><ul>
<li><p>在正常模式下，我们可以使用快捷键对文本进行复制、粘贴、删除和查找等工作。</p>
</li>
<li><p>用 vim 打开一个文件就直接进入一般模式</p>
</li>
<li><p>常见指令</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>yy</td>
<td>拷贝当前行</td>
</tr>
<tr>
<td>5yy</td>
<td>拷贝当前5行</td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>5dd</td>
<td>删除当前行向下的5行</td>
</tr>
<tr>
<td>u</td>
<td>撤销上一步的操作（Undo）</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>重做（Redo），即撤销的撤销。</td>
</tr>
<tr>
<td>p</td>
<td>将之前删除（dd）或复制（yy）过的数据粘贴到光标下一行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文件头。 &#x3D; [[</td>
</tr>
<tr>
<td>G（shift + g）</td>
<td>移动到文件尾。 &#x3D; ]]</td>
</tr>
<tr>
<td>行号 + G</td>
<td>移动到第 n 行</td>
</tr>
<tr>
<td>0</td>
<td>移动到本行第一个字符上</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="（2）插入-x2F-编辑模式"><a href="#（2）插入-x2F-编辑模式" class="headerlink" title="（2）插入&#x2F;编辑模式"></a>（2）插入&#x2F;编辑模式</h3><ul>
<li>在编辑模式下，可以编辑文件内容。</li>
<li>在一般模式下，按下 i,I,o,O,a,A,r,R 等字母就可进入编辑模式（i 在当前位置前插入，a 在当前位置后插入，o 在当前行之后插入一行）</li>
</ul>
<h3 id="（3）命令行模式"><a href="#（3）命令行模式" class="headerlink" title="（3）命令行模式"></a>（3）命令行模式</h3><ul>
<li><p>在这个模式中，可以利用指令完成读取，存盘，替换，离开，显示行号的等动作。</p>
</li>
<li><p>在一般模式下，按下:或者&#x2F;可以进入命令模式</p>
</li>
<li><p>常见命令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存</td>
</tr>
<tr>
<td>:q</td>
<td>退出</td>
</tr>
<tr>
<td>:q！</td>
<td>强制退出（不保存）</td>
</tr>
<tr>
<td><strong>:wq</strong></td>
<td><strong>写入磁盘后离开</strong></td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出（等价于在一般模式下输入ZZ）</td>
</tr>
<tr>
<td><strong>:set nu</strong></td>
<td><strong>显示行号</strong></td>
</tr>
<tr>
<td>:set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>:数字</td>
<td>跳转到该行，比如跳到 240 行就是 :240 回车</td>
</tr>
<tr>
<td><strong>&#x2F; 字符串</strong></td>
<td><strong>在文本中从上至下搜索该字符串（按n查找下一个，N查找上一个）</strong></td>
</tr>
<tr>
<td>?字符串</td>
<td>在文本中从下至上搜索该字符串（按n查找下一个，N查找上一个）</td>
</tr>
<tr>
<td>:noh</td>
<td>取消文字高亮</td>
</tr>
<tr>
<td><strong>:%s&#x2F;one&#x2F;two&#x2F;g</strong></td>
<td><strong>将全文中的所有 one 替换成 two</strong>（:%s&#x2F;原文本&#x2F;替换文本&#x2F;g），最后的g是“全局”的意思，意味着对文本行中所有匹配的字符串，执行查找和替换操作。如果省略 g，则只替换每个文本行中第一个匹配的字符串。。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="（4）三种模式转换示意图"><a href="#（4）三种模式转换示意图" class="headerlink" title="（4）三种模式转换示意图"></a>（4）三种模式转换示意图</h3><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100857.png" style="zoom:80%;" />

<h1 id="四-账号管理"><a href="#四-账号管理" class="headerlink" title="四. 账号管理"></a>四. 账号管理</h1><h2 id="1-用户管理"><a href="#1-用户管理" class="headerlink" title="1. 用户管理"></a>1. 用户管理</h2><blockquote>
<ul>
<li><p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
</li>
<li><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
</li>
<li><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
</li>
<li><p>要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
</li>
<li><p>当提示符的最后一个字符是“#”，则说明是root用户，如果是“$”，则说明是普通用户</p>
<p>[root@localhost ~]#       root用户</p>
<p>[zhang@localhost root]$     其他用户</p>
</li>
</ul>
</blockquote>
<h3 id="（1）添加用户（useradd）"><a href="#（1）添加用户（useradd）" class="headerlink" title="（1）添加用户（useradd）"></a>（1）添加用户（useradd）</h3><blockquote>
<p>添加用户：useradd 【选项】 用户名。</p>
</blockquote>
<ul>
<li><p>选项:</p>
<ul>
<li>-d 指定用户的家目录（如果不指定，家目录默认为&#x2F;home&#x2F;用户名）</li>
<li>-g 指定一个初始的用户基本组（必须已存在）</li>
<li>-G 指定一个或多个扩展用户组。</li>
<li>-s 指定该用户的默认 Shell 解释器。</li>
<li>-u 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li>
<li>-e  指定帐号的有效期限；</li>
<li>-M：不要自动建立用户的登入目录；</li>
</ul>
</li>
<li><p>用户名:指定新账号的登录名。</p>
</li>
<li><p>举例：useradd –d &#x2F;home&#x2F;sam -m sam</p>
<p>此命令创建了一个用户 sam，其中-d 和-m 选项用来为登录名 sam 产生一个主目录 &#x2F;home&#x2F;sam。</p>
</li>
</ul>
<h3 id="（2）用户口令的管理（passwd）"><a href="#（2）用户口令的管理（passwd）" class="headerlink" title="（2）用户口令的管理（passwd）"></a>（2）用户口令的管理（passwd）</h3><blockquote>
<p>指定和修改用户口令: passwd 【选项】 【用户名】</p>
</blockquote>
<ul>
<li><p>选项：</p>
<ul>
<li>-l 锁定口令，即禁用账号。</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>普通用户只能使用 passwd 命令修改自身的系统密码。且会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则修改成功；</li>
<li>root 管理员有权限修改其他所有人的密码。且不需要验证旧密码。</li>
</ul>
</li>
<li><p>举例：passwd -l sam（用 -l 选项锁定 sam 用户，使其不能登录）</p>
</li>
</ul>
<h3 id="（3）删除帐号（userdel）"><a href="#（3）删除帐号（userdel）" class="headerlink" title="（3）删除帐号（userdel）"></a>（3）删除帐号（userdel）</h3><blockquote>
<p>删除帐号: userdel 【选项】 用户名</p>
<p>默认只会删除 &#x2F;etc&#x2F;passwd 文件中的用户信息，而不会删除系统中属于该账户的任何文件。</p>
</blockquote>
<ul>
<li><p>选项</p>
<ul>
<li>-f 强制删除用户</li>
<li>-r 同时删除用户及用户家目录</li>
</ul>
</li>
<li><p>举例：userdel -r sam</p>
</li>
</ul>
<h3 id="（4）修改帐号（usermod）"><a href="#（4）修改帐号（usermod）" class="headerlink" title="（4）修改帐号（usermod）"></a>（4）修改帐号（usermod）</h3><blockquote>
<p>修改已有用户的信息: usermod 【选项】 用户名</p>
</blockquote>
<ul>
<li>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与 useradd 命令中的选项一样，可以为用户指定新的资源值。</li>
</ul>
<h3 id="（5）查询用户信息（id）"><a href="#（5）查询用户信息（id）" class="headerlink" title="（5）查询用户信息（id）"></a>（5）查询用户信息（id）</h3><ul>
<li><p>查询用户信息: id 用户名</p>
<ul>
<li>用户不存在是返回“无此用户”</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ hostname   </span><br><span class="line">VM-0-13-centos</span><br><span class="line">➜  ~ <span class="built_in">id</span>      </span><br><span class="line">uid=1000(zhang) gid=1000(zhang) <span class="built_in">groups</span>=1000(zhang)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前用户&#x2F;登录用户：who am i（<strong>一般用于shell脚本，用于获取当前操作的用户名方便记录日志。</strong>）</p>
</li>
</ul>
<h3 id="（6）切换用户（su）"><a href="#（6）切换用户（su）" class="headerlink" title="（6）切换用户（su）"></a>（6）切换用户（su）</h3><ul>
<li>切换用户：su - 切换用户名<ul>
<li>从权限高切换到权限低的用户不需要输密码。</li>
<li>返回切换前的用户：exit</li>
</ul>
</li>
</ul>
<h3 id="（7）使用-root-权限（sudo）"><a href="#（7）使用-root-权限（sudo）" class="headerlink" title="（7）使用 root 权限（sudo）"></a>（7）使用 root 权限（sudo）</h3><p>有一些文件的操作只有 root 用户才有权限，如果想要普通用户也能够执行这些文件，就需要对&#x2F;etc&#x2F;sudoers进行设置。</p>
<ul>
<li><p>切换 root 用户</p>
</li>
<li><p>编辑 &#x2F;etc&#x2F;sudoers 文件，并添加下面一行指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户名 允许使用的主机=(以谁的身份)    可以执行的命令列表</span></span><br><span class="line">zhang  ALL=(ALL)        ALL  <span class="comment"># 表明用户zhang可以拥有所有文件的权限</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 sudo+指令 的方式执行某些命令。</p>
</li>
</ul>
<h3 id="（8）查询用户命令（who）"><a href="#（8）查询用户命令（who）" class="headerlink" title="（8）查询用户命令（who）"></a>（8）查询用户命令（who）</h3><ul>
<li><p>w：可显示开机多久，当前登录的所有用户，平均负载</p>
</li>
<li><p>who：显示当前登录的所有用户</p>
</li>
<li><p>last：显示每个用户最后的登录时间</p>
</li>
<li><p>lastlog：显示每个用户最后的登录时间）</p>
</li>
</ul>
<h2 id="2-用户组的管理"><a href="#2-用户组的管理" class="headerlink" title="2. 用户组的管理"></a>2. 用户组的管理</h2><blockquote>
<p><strong>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。组权限允许多个用户对系统中的对象共享一组共用的权限。</strong>不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 &#x2F;etc&#x2F;group 文件的更新。</p>
</blockquote>
<h3 id="（1）添加组（groupadd-）"><a href="#（1）添加组（groupadd-）" class="headerlink" title="（1）添加组（groupadd ）"></a>（1）添加组（groupadd ）</h3><blockquote>
<p>增加一个新的用户组: groupadd 【选项】 用户组</p>
</blockquote>
<ul>
<li>选项：<ul>
<li>-g GID 指定新用户组的组标识号（GID），如果不使用此选项，默认是在组号自增1。</li>
<li>-o 一般与-g选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同。</li>
</ul>
</li>
<li>举例：groupadd -g 101 group1（向系统中增加了一个新组 group1，同时指定新组的组标识号是 101）。</li>
</ul>
<h3 id="（2）删除组（groupdel）"><a href="#（2）删除组（groupdel）" class="headerlink" title="（2）删除组（groupdel）"></a>（2）删除组（groupdel）</h3><blockquote>
<p>删除用户组: groupdel 用户组</p>
</blockquote>
<ul>
<li>举例：groupdel group1（将group1这个组删除）</li>
</ul>
<h3 id="（3）修改组（groupmod）"><a href="#（3）修改组（groupmod）" class="headerlink" title="（3）修改组（groupmod）"></a>（3）修改组（groupmod）</h3><blockquote>
<p>修改用户组: groupmod 【选项】 用户组</p>
</blockquote>
<ul>
<li>选项：<ul>
<li>-g GID 为用户组指定新的组标识号。</li>
<li>-o 与-g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同。</li>
<li>-n 新用户组  将用户组的名字改为新名字</li>
</ul>
</li>
<li>举例：groupmod –g 10000 -n group2 group1（将组group1的标识号改为10000，组名修改为group2）</li>
</ul>
<h2 id="3-与用户账号有关的系统文件"><a href="#3-与用户账号有关的系统文件" class="headerlink" title="3. 与用户账号有关的系统文件"></a>3. 与用户账号有关的系统文件</h2><h3 id="（1）-x2F-etc-x2F-passwd-文件"><a href="#（1）-x2F-etc-x2F-passwd-文件" class="headerlink" title="（1）&#x2F;etc&#x2F;passwd 文件"></a>（1）&#x2F;etc&#x2F;passwd 文件</h3><blockquote>
<p>用户（user）的配置文件，记录用户的各种信息。可以将用户登录名匹配到对应的 UID 值，UID，即 User ID，每个用户有着唯一的 UID。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100858.png" alt="image-20210727202800745" style="zoom:67%;" />

<ul>
<li>每行的含义：<ol>
<li><p>“用户名”是代表用户账号的字符串。</p>
<ul>
<li>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</li>
<li>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</li>
</ul>
</li>
<li><p>“口令”一些系统中，存放着加密后的用户口令字。</p>
<ul>
<li>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到 &#x2F;etc&#x2F;shadow 文件中，而在 &#x2F;etc&#x2F;passwd 文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</li>
</ul>
</li>
<li><p>“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<ul>
<li>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录 Shell 等。</li>
<li>通常用户标识号的取值范围是 0～65535。0 是超级用户 root 的标识号，1～99 由系统保留，作为管理账号，普通用户的标识号从 100 开始。在 Linux 系统中，这个界限是 500。</li>
</ul>
</li>
<li><p>“组标识号”字段记录的是用户所属的用户组。</p>
<ul>
<li>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</li>
</ul>
</li>
<li><p>“注释性描述”字段记录着用户的一些个人情况。</p>
<ul>
<li>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</li>
</ul>
</li>
<li><p>“主目录”，也就是用户的起始工作目录。</p>
<ul>
<li>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</li>
</ul>
</li>
<li><p><u>用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</u></p>
<ul>
<li><strong>Shell 是用户与 Linux 系统之间的接口</strong>。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), <strong>bash</strong>(Bourne Again Shell)等。</li>
<li>系统管理员可以根据系统情况和用户习惯为用户指定某个 Shell。如果不指定 Shell，那么系统使用sh 为默认的登录 Shell，即这个字段的值为 &#x2F;bin&#x2F;sh。</li>
<li>用户的登录 Shell 也可以指定为某个特定的程序（此程序不是一个命令解释器）。</li>
<li>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些 Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</li>
</ul>
</li>
<li><p>系统中有一类用户称为伪用户（pseudo users）。</p>
<ul>
<li>这些用户在 &#x2F;etc&#x2F;passwd 文件中也占有一条记录，但是不能登录，因为它们的登录 Shell 为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="（2）-x2F-etc-x2F-shadow-文件"><a href="#（2）-x2F-etc-x2F-shadow-文件" class="headerlink" title="（2）&#x2F;etc&#x2F;shadow 文件"></a>（2）&#x2F;etc&#x2F;shadow 文件</h3><blockquote>
<p>口令配置文件</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100900.png" style="zoom: 70%;" />

<ul>
<li>每行的含义：<ol>
<li>“登录名”是与 &#x2F;etc&#x2F;passwd 文件中的登录名相一致的用户账号</li>
<li><strong>“口令”字段存放的是加密后的用户口令字，长度为13个字符。</strong>如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在 SCO Linux 中，这个时间起点是 1970 年 1 月 1 日。</li>
<li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li>
<li>“最大时间间隔”指的是口令保持有效的最大天数。</li>
<li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
</li>
</ul>
<p>查看某用户密码（没意义，由于 &#x2F;etc&#x2F;shadow 包含用户加密的密码，只有 root 用户才能查看此文件）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到root用户</span></span><br><span class="line">su root</span><br><span class="line"><span class="comment"># 查看密码加密方式</span></span><br><span class="line">authconfig --<span class="built_in">test</span>|grep hashing  <span class="comment"># 若输出password hashing algorithm is md5，即加密方式为md5</span></span><br><span class="line"><span class="comment"># 查看用户加密后的密码</span></span><br><span class="line"><span class="built_in">cat</span> /etc/shadow|grep 用户名</span><br><span class="line"><span class="comment"># 拿到密码后，直接找一个在线md5解密工具暴力破解，如https://www.somd5.com/</span></span><br></pre></td></tr></table></figure>


<h3 id="（3）-x2F-etc-x2F-group-文件"><a href="#（3）-x2F-etc-x2F-group-文件" class="headerlink" title="（3）&#x2F;etc&#x2F;group 文件"></a>（3）&#x2F;etc&#x2F;group 文件</h3><blockquote>
<p>组（group）的配置文件，用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。</p>
</blockquote>
<ul>
<li><p>每行含义：</p>
<ol>
<li>“组名”是用户组的名称，由字母或数字构成。与 &#x2F;etc&#x2F;passwd 中的登录名一样，组名不应重复。</li>
<li>“口令”字段存放的是用户组加密后的口令字。一般 Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
</li>
</ul>
<h1 id="五-文件与目录管理"><a href="#五-文件与目录管理" class="headerlink" title="五. 文件与目录管理"></a>五. 文件与目录管理</h1><h2 id="1-基本操作（touch、rm…）"><a href="#1-基本操作（touch、rm…）" class="headerlink" title="1. 基本操作（touch、rm…）"></a>1. 基本操作（touch、rm…）</h2><ul>
<li><p><u><code>pwd</code></u>：（Print Working Directory），显示当前工作目录的绝对路径，比如 &#x2F;home&#x2F;zhang</p>
</li>
<li><p><u><code>ls【选项】</code></u>：</p>
<ul>
<li>-a：显示当前目录所有的文件和目录，包括隐藏的；</li>
<li>-l：以列表（长格式）的方式显示信息。</li>
<li>-h：代表 human-readable，与-l 一起，以易于阅读的格式输出文件大小。</li>
<li>-i：会在第一列列出文件的 inode 号。</li>
<li>-F：这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是目录名，则会加上一个’&#x2F;’ 字符。</li>
<li>ll 其实是 ls -alF 的别名</li>
<li>lscpu：列出 cpu 信息</li>
<li>lsmem：列出内存信息</li>
<li>lsblk：列出磁盘信息</li>
</ul>
</li>
<li><p><u><code>cd</code></u>：更换当前目录。</p>
<p><strong>cd ~</strong> 或者直接cd：回到自己的家目录；</p>
<p><strong>cd ..</strong> ：回到当前目录的上一级目录；</p>
<p><strong>cd -</strong> ：回到上一次所在的目录</p>
</li>
<li><p><u><code>mkdir【选项】目录名</code></u>：创建目录（可以 一次性创建多个目录，只需要在多个目录用空格隔开）。</p>
<ul>
<li>-p：递归创建出具有嵌套叠层关系的文件目录，比如 mkdir -p  &#x2F;home&#x2F;zhang&#x2F;a&#x2F;b&#x2F;c&#x2F;d</li>
</ul>
</li>
<li><p><u>rmdir 目录名：删除空目录</u>。rmdir不能删除非空的目录。如果需要删除非空的目录，需要使用rm -rf。</p>
</li>
<li><p><u><code>cp 源文件 文件/目录</code></u> ：拷贝文件到指定目录（源文件可以是多个，中间用空格隔开）；</p>
<ul>
<li><strong>-r &#x2F; -R</strong>：递归复制整个文件夹。</li>
<li>强制覆盖不提示的方法：cp 命令改为 \cp</li>
<li>示例1：cp file1 file2 dir1 将文件 1 和 2 复制到目录 1 下，注意目录 1 必须存在</li>
<li>示例2：cp -r dir1 dir2 将目录 1 下所有文件递归的复制到目录 2 下，此时目录 2 可以不存在，会自动创建</li>
</ul>
</li>
<li><p><u><code>rm  源文件 目录</code></u>：移除文件或目录；（使用rm-rf删除非空的目录）</p>
<ul>
<li>-r：递归删除整个文件夹；</li>
<li>-f：强制删除不提示。</li>
<li>-i：会询问是否删除，需要输入 y&#x2F;n，降低误删除的可能性</li>
</ul>
</li>
<li><p><u><code>mv 源文件 目录</code></u>：移动文件与目录（mv 源文件 目标文件 ：重命名），注意 mv 命令只改变文件位置&#x2F;文件</p>
<p>名，inode 号和时间戳信息并未改变。</p>
</li>
<li><p><u><code>touch 【选项】 文件</code></u>：创建空文件或者更新文件最近修改时间。可以一次性创建多个文件</p>
<ul>
<li>-a 仅修改“读取时间”（atime），即访问时间</li>
<li>-m 仅修改“修改时间”（mtime）</li>
<li>-d 同时修改 atime 与 mtime</li>
<li>更新文件时间举例：touch -d “2017-05-04 15:44” anaconda-ks.cfg</li>
<li>源文件已经存在，直接 touch 源文件名，不会将源文件清空，而只会将最近修改时间变化为当前时间。</li>
</ul>
</li>
<li><p><u><code>ln</code></u>： 给文件创建一个软链接</p>
<ul>
<li><p>用法：ln -s [源文件或目录] [软链接名]</p>
</li>
<li><p>示例：ln -s a.txt a，此时就会出现 a -&gt; a.txt ，那么对 a 的操作就是对 a.txt 的操作。</p>
</li>
<li><p>软链接生效是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。<strong>如果往软链接里面写入东西，那么相关联的文件也被写入</strong>。<strong>不过当你删除软链接时，原文件并不会被删除</strong>。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。</p>
</li>
<li><p>注意：创建硬链接的格式为：<u>ln 源文件名 硬链接名</u>，但是硬链接具有以下两个局限性，因而被软链接所替代。（系统不会为硬链接创建新的 inode 号和文件，所以，<u>硬链接文件与原始文件其实是同一个文件</u>，只是名字不同。我们每添加一个硬链接，该文件的 inode 连接数就会增加 1。且只有当该文件的 inode 连接数为 0 时，才算彻底被将它删除。因此<u>即便删除原始文件，依然可以通过硬链接文件来访问</u>）</p>
<p>① 硬链接不能跨越物理设备，即只能对处于同一存储媒体的文件创建硬链接。</p>
<p>② 硬链接不能关联目录，只能是文件。</p>
</li>
<li><p><u>硬链接是别名，软链接是快捷方式</u></p>
</li>
</ul>
</li>
<li><p><code>wc</code>：统计文件内容信息（包含行数、单词数、字节数）</p>
<ul>
<li>用法：wc 【-lwc】 文件路径<ul>
<li>-l：表示 lines，行数</li>
<li>-w：表示 words，单词数  依照空格来判断单词数量</li>
<li>-c：表示 bytes，字节数</li>
</ul>
</li>
<li>如果不指定选项，默认是显示<u>行数、单词数、字节数</u></li>
</ul>
</li>
<li><p>file：确定文件类型</p>
<ul>
<li>用法：file 文件名</li>
</ul>
</li>
</ul>
<h2 id="2-文件属性"><a href="#2-文件属性" class="headerlink" title="2. 文件属性"></a>2. 文件属性</h2><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<h3 id="（1）ls-l"><a href="#（1）ls-l" class="headerlink" title="（1）ls -l"></a>（1）ls -l</h3><p>使用ls -l指令查看文件时，显示的内容如图所示<br><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100859.png" alt="image-20210727203219371" style="zoom:67%;" /></p>
<p>文件权限说明：</p>
<ul>
<li><p>第 1 个字符代表<u>文件类型</u>。</p>
<p>当为[ d ]则是<strong>目录</strong></p>
<p>当为[ - ]则是<strong>文件</strong>；</p>
<p>若是[ l ]则表示为链接文档(link file)，<strong>软链接</strong>；</p>
<p>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</p>
<p>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</p>
</li>
<li><p>第 2-10 个字符，以三个为一组， 每一组分别代表对文件拥有者、所属群组以及其它人的<u>文件权限</u>，均为『rwx』 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p>
</li>
</ul>
<p>连接数指的是文件的<u>硬链接数</u>。</p>
<h3 id="（2）rwx-权限详解"><a href="#（2）rwx-权限详解" class="headerlink" title="（2）rwx 权限详解"></a>（2）rwx 权限详解</h3><ul>
<li><p>rwx 作用到文件：</p>
<ul>
<li>r：read，可读取文件。</li>
<li>w：write，可修改文件。<strong>但不代表可以删除该文件。删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</strong></li>
<li>x：execute，可执行文件。可以被执行。</li>
</ul>
</li>
<li><p>rwx 作用到目录：</p>
<ul>
<li>r：可读取目录下文件，比如可以ls查看目录内容。</li>
<li>w：<strong>可修改目录内文件，<code>在本目录内:</code>创建+删除+重命名目录&#x2F;文件。</strong></li>
<li>x：可执行目录内文件，比如可以cd进入该目录。</li>
</ul>
</li>
<li><p>关于删除目录&#x2F;文件</p>
<ul>
<li>若想删除一个文件&#x2F;目录，只有拥有此文件&#x2F;目录的上级目录（父目录）的写权限后，才能删除此文件，并且与此文件&#x2F;目录的权限没有任何关系。</li>
<li>如果没有父目录的写权限，即使有文件&#x2F;目录的rwx权限，也不能删除；</li>
<li>如果有父目录的写权限，即使没有文件&#x2F;目录的任何权限，也可以删除。（对文件&#x2F;目录删除的操作，其实是对其父目录的写操作）</li>
</ul>
</li>
</ul>
<h3 id="（3）修改文件所属组（chgrp）"><a href="#（3）修改文件所属组（chgrp）" class="headerlink" title="（3）修改文件所属组（chgrp）"></a>（3）修改文件所属组（chgrp）</h3><blockquote>
<p>更改文件所属组群，这个可以被现在的 chown 所替代了：</p>
<p>chgrp [-R] 属组名 文件名</p>
</blockquote>
<ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h3 id="（4）修改文件拥有者（chown）"><a href="#（4）修改文件拥有者（chown）" class="headerlink" title="（4）修改文件拥有者（chown）"></a>（4）修改文件拥有者（chown）</h3><blockquote>
<p>更改文件拥有者，使用这个命令需要超级用户权限：</p>
<p><strong>chown [–R] 账号名 文件名</strong>，把文件所有者从当前属主更改为新的账号用户。                 </p>
<p><strong>chown [-R] 账号名:组名 文件名</strong> ，把文件所有者改为新的账号用户，文件用户组改为新的用户组。</p>
<p><strong>chown [-R] :组名 文件名</strong>，把文件用户组改为新的用户组，文件所有者不变。</p>
<p><strong>chown [-R] 账号名: 文件名</strong> ，把文件所有者改为新的账号用户，文件用户组改为新用户所在的组。</p>
</blockquote>
<h3 id="（5）修改文件属性（chmod）"><a href="#（5）修改文件属性（chmod）" class="headerlink" title="（5）修改文件属性（chmod）"></a>（5）修改文件属性（chmod）</h3><ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx</li>
</ul>
<blockquote>
<p>更改文件属性：chmod</p>
</blockquote>
<ul>
<li>Linux文件属性有两种设置方法，一种是数字，一种是符号。</li>
<li>可以使用数字来代表各个权限（r:4   w:2   x:1）</li>
<li>每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：<ul>
<li>owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7</li>
<li>others&#x3D; — &#x3D; 0+0+0 &#x3D; 0</li>
</ul>
</li>
</ul>
<p><u>使用数字修改权限</u></p>
<ul>
<li><code>chmod [-R] xyz 文件或目录</code><ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
<li>举例：chmod 741 abc.txt 表示文件所有者权限为rwx，所属组权限为r–，其他用户权限为–x</li>
</ul>
</li>
</ul>
<p><u>使用符号修改权限</u></p>
<ul>
<li><p><code>chmod [-R] u=xxx,g=xxx,o=xxx 文件或目录</code></p>
</li>
<li><p>u(user), g(group), o(others) ,</p>
</li>
<li><p>举例：chmod u&#x3D;rwx,g&#x3D;r–,o&#x3D;–x abc.txt 表示文件所有者权限为rwx，所属组权限为r–，其他用户权限为–x</p>
</li>
</ul>
<h2 id="3-文件查看（cat、more、less…）"><a href="#3-文件查看（cat、more、less…）" class="headerlink" title="3. 文件查看（cat、more、less…）"></a>3. 文件查看（cat、more、less…）</h2><ul>
<li><p><code>cat【-n】文件名</code>：查看文件内容。只能浏览文件，而不能修改文件。</p>
<ul>
<li><p>-n：显示行号。</p>
</li>
<li><p>cat 是连接文件，它的好处是可以同时读取多个文件，然后复制他们到标准输出。因而cat经常适用于显示多个<u>简短</u>的文本文件（如果文件较长，可以使用 less 命令分页查看）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost zhang]<span class="comment"># cat zhang.txt -n</span></span><br><span class="line">     1	zhang</span><br><span class="line">[root@localhost zhang]<span class="comment"># cat li.txt -n</span></span><br><span class="line">     1	li</span><br><span class="line">[root@localhost zhang]<span class="comment"># cat hu.txt -n</span></span><br><span class="line">     1	hu</span><br><span class="line">[root@localhost zhang]<span class="comment"># cat zhang.txt li.txt hu.txt -n</span></span><br><span class="line">     1	zhang</span><br><span class="line">     2	li</span><br><span class="line">     3	hu</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只使用 cat 命令，而没指定文件名，程序就会等待输入数据，然后让按下 Ctrl+D 后，就相当于告诉cat，在标准输入中，已经到达文件末尾，然后 cat 会把标准输入进行标准输出。也就是说，<u>如果没有文件名参数，cat 会复制标准输入到标准输出</u>，我们也可以通过重定向，利用 cat 的这种特性把标准输入重定向到一个文件中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost zhang]<span class="comment"># cat &gt; out.txt  （这条命令将标准输入重定向到out.txt中）</span></span><br><span class="line">这是我的标准输入！  (注意输入完后，需要按下ctrl+D/C)</span><br><span class="line">[root@localhost zhang]<span class="comment"># cat out.txt （这条命令是查看out.txt文件内容）</span></span><br><span class="line">这是我的标准输入！</span><br></pre></td></tr></table></figure>
</li>
<li><p>结尾加上 | more：分页显示，不会全部一下显示完。</p>
</li>
<li><p>如果想把多个文件合并为一个，就可以使用 cat 和重定向&gt;联合进行实现</p>
</li>
</ul>
</li>
<li><p><code>more</code>：是一个基于 VI 编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more 还内置了很多快捷键：</p>
<ul>
<li>空白键（Space）：向下翻一页</li>
<li>Enter：向下翻一行</li>
<li>q：立刻离开more，不再显示该文件内容</li>
<li>F：向下滚动一屏</li>
<li>B：返回上一屏</li>
<li>&#x3D; ：输出当前行的行号</li>
<li>:f 输出文件名和当前行的行号</li>
</ul>
</li>
<li><p><code>less</code>：用来分屏查看文件内容，与 more 相似，但是更强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容。对于显示大型文件具有较高的效率。<u>如果文件多于一页，我们可以上下滚动文件。如果想要退出 less 程序，只需要按下”q”键即可。如果想要快速定位到文件末尾，可以按“G”键</u></p>
</li>
<li><p><code>head【-n 行号】文件</code>：显示文件的开头部分。-n ：后面接数字，代表显示几行的意思（如果不指定，默认显示10行）</p>
</li>
<li><p><code>tail【-n 行号】文件</code>：输出文件中尾部的内容（如果不指定显示行号，默认显示最后10行）。</p>
<ul>
<li><strong>-f</strong>：实时追踪该文档的所有更新（即当新的内容添加到文件后，它们会立即出现在屏幕上，这样会一直继续下去直到你输入Ctrl+C）<strong>该命令一般用于查看系统的日志比较多。</strong></li>
</ul>
</li>
<li><p><code>&gt;</code> 指令：将标准输出重定向到一个文件中。如果不存在会创建文件，否则会将原来的文件内容覆盖。</p>
<ul>
<li><p>还可以通过命令<code>&gt; 文件名</code>用于清空一个已存在的文件或是创建一个新的空文件，因为重定向的内容为空（&gt; 前没有任何东西）</p>
</li>
<li><p><u>标准输出重定向默认不会把错误输出到文件中</u>，如果想要重定向标准输出和错误到同一个文件，可以在后面补上<code>2&gt;&amp;1</code>，或者使用一种更简单的方式，使用命令<code>&amp;&gt; 文件名</code>。在linux中，用文件描述符0,1,2分别表示标准输入、输出、错误。</p>
</li>
<li><p>举例1：python main.py &gt;a.txt 将程序的标准输出重定向到a.txt文件中；</p>
</li>
<li><p>举例2：python main.py  2&gt;a.txt  将程序的标准错误重定向到a.txt文件中；</p>
</li>
<li><p>举例3：python main.py &gt;a.txt  2&gt;&amp;1 将程序的标准输出以及错误都重定向到a.txt文件中。</p>
<p>另外一种简便写法：python main.py &amp;&gt;a.txt</p>
</li>
</ul>
</li>
<li><p><code>&gt;&gt;</code>指令：将标准输出重定向到一个文件中。如果不存在会创建文件，否则不会覆盖原来的文件内容，而是追加到文件的尾部。</p>
</li>
<li><p><code>echo</code>：输出内容到控制台。</p>
</li>
<li><p><code>history</code>：查看历史指令</p>
</li>
</ul>
<h2 id="4-搜索查找（find、locate、grep）"><a href="#4-搜索查找（find、locate、grep）" class="headerlink" title="4. 搜索查找（find、locate、grep）"></a>4. 搜索查找（find、locate、grep）</h2><ul>
<li><p>**<code>find</code>**：find 【查找路径】【选项】【操作】</p>
<p>从指定目录向下递归的遍历其各个子目录，将满足条件的文件或者目录显示在终端。</p>
<p>选项：</p>
<ul>
<li><code>-name </code>(文件名)：按照指定的文件名查找模式查找文件。</li>
<li><code>-user</code> (用户名)：按照指定的用户名查找模式查找文件。</li>
<li><code>-size</code> (+多少&#x2F;-多少&#x2F;多少)：按照指定的文件大小查找模式查找文件（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 50KB 的文件）</li>
<li>举例：查询 &#x2F;目录下所有.txt的文件：find &#x2F; -name *.txt</li>
</ul>
</li>
<li><p><strong>locate</strong>：locate (搜索文件)</p>
<ul>
<li>可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给定的文件。</li>
<li>locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate 时刻。</li>
<li>在第一次运行之前，必须使用 <u>updatedb</u> 指令创建locate数据库（使用updatedb可以更新数据库）。</li>
<li>一般在locate 搜索文件前，先 updatedb 更新数据</li>
<li>举例：locate txt | grep zhang（文件可以是任何字母，如果忘记了全称，也可以查找后缀等等缩小范围）</li>
</ul>
</li>
<li><p>**<code>grep</code>**：过滤查找，表示将前一个命令的处理结果输出传递给后面的命令处理。经常跟管道一起使用。</p>
<p>管道就是“|”，它可以将前一个命令的标准输出送至到后一个命令的标准输入。</p>
<ul>
<li>grep [选项] 查找内容 源文件</li>
<li>-n：显示匹配行及行号。</li>
<li>-i：忽略大小写字母。</li>
<li>举例：ps -aux | grep python 在所有运行的程序中，查找是python的程序。</li>
</ul>
</li>
<li><p>which：在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。比如想要把一个程序安装地址添加到环境变量，但又忘了程序安装目录，就可以使用 which 命令。比如：which python  ，输出&#x2F;usr&#x2F;bin&#x2F;python</p>
</li>
<li><p>whereis：用于程序名的搜索，只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p>
</li>
</ul>
<h2 id="5-压缩和解压"><a href="#5-压缩和解压" class="headerlink" title="5. 压缩和解压"></a>5. 压缩和解压</h2><ul>
<li><strong>gzip&#x2F;gunzip</strong>：压缩文件&#x2F;解压<ul>
<li>gzip (文件)：压缩为.gz文件，原来文件不保留，且不能压缩目录。</li>
<li>gunzip (文件)：解压缩，同样也不保留源文件。</li>
</ul>
</li>
<li><strong>zip&#x2F;unzip</strong>：压缩文件&#x2F;解压<ul>
<li>zip [选项] (压缩后文件xxx.zip) (将要压缩的文件)</li>
<li>unzip [选项] (要解压的文件xxx.zip)</li>
<li>zip -r：递归压缩，即压缩目录</li>
<li>unzip -d (目录)：指定解压后的文件的存放目录</li>
</ul>
</li>
<li><strong>tar</strong>：打包指令，要结合-z进行压缩，最后打包压缩是以.tar.gz结尾的文件（一个常见的，与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件，并把它们捆绑成一个大文件的过程。归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某种类型的长期存储设备中时，也会用到归档程序。）<ul>
<li>tar [选项] xxx.tar.gz (打包的内容)</li>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩（使用gzip压缩）</li>
<li></li>
<li>-x：解压.tar文件</li>
<li>压缩：<u>tar -zcvf (压缩后文件名) (要压缩的文件)</u><ul>
<li>可以使用*？等通配符，压缩文件可以包含多个，打包在一起后再进行压缩。</li>
</ul>
</li>
<li>解压：<u>tar -zxvf (要解压的文件)</u></li>
<li>解压到指定目录：<u>tar -zxvf (要解压的文件) -C (指定目录)</u>，指定解压到的目录要存在。</li>
</ul>
</li>
</ul>
<h2 id="6-环境变量"><a href="#6-环境变量" class="headerlink" title="6. 环境变量"></a>6. 环境变量</h2><p>可以通过<code>env</code>命令查看系统所有的环境变量。</p>
<p>应用于所有用户的全局配置脚本是 &#x2F;etc&#x2F;profile 。</p>
<p>用于个人的启动文件是 ~&#x2F;.bash_profile 可以用来扩展或重写全局配置脚本中的设置。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $是参数展开，$PATH表示原来的环境变量,:是环境变量之间的分隔符，$HOME/bin是要新增的环境变量</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin </span><br><span class="line"><span class="comment"># 使用exprort后，shell的子进程就可以使用环境变量的内容</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>

<p>当修改了环境变量时，文件修改并不会立即生效，直到我们关闭终端会话，再重新启动一个新的会话，因为这些文件只是在刚开始启动终端会话时读取。如果想要立即生效，我们可以使用<code>source 文件名</code>来激活文件修改。</p>
<h1 id="六-进程管理"><a href="#六-进程管理" class="headerlink" title="六. 进程管理"></a>六. 进程管理</h1><h2 id="1-进程概述"><a href="#1-进程概述" class="headerlink" title="1. 进程概述"></a>1. 进程概述</h2><ul>
<li>在 Linux 中，每个执行的<strong>程序（代码）</strong>都称为一个进程。每个进程都分配一个 ID 号</li>
<li>每一个进程，都会对应一个父进程。</li>
<li>每个进程都可能以两种方式存在。前台和后台。<ul>
<li>前台进程：用户目前的屏幕上可以进行操作的。</li>
<li>后台进程：实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li>
</ul>
</li>
<li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中，直到关机才结束。</li>
</ul>
<h2 id="2-显示进程（ps）"><a href="#2-显示进程（ps）" class="headerlink" title="2. 显示进程（ps）"></a>2. 显示进程（ps）</h2><blockquote>
<p>ps [选项]：查看目前系统中，有哪些正在执行，以及它们执行的状况（process status 进程状态），默认情况下（即不加选项参数），ps 不会显示很多进程信息，只会显示运行在当前控制台下的属于当前用户的进程。</p>
</blockquote>
<ul>
<li>ps -a：显示当前终端的所有进程信息。</li>
<li>ps -u：以用户的格式显示进程信息。</li>
<li>ps -x：显示后台进程运行的参数。</li>
<li><u>ps -axu</u>：查看所有进程信息。</li>
<li><u>ps -axu | grep xxx</u>：查看特定的进程</li>
<li>ps -e：等价于ps -a</li>
<li><u>ps -ef</u>：以全格式显示当前所有的进程，（可以查看进程的父进程，在进程方案中，一个程序可以发动另一个程序被表述为一个父进程可以产生一个子进程）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ ps -aux            </span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">...</span><br><span class="line">➜  ~ ps -ef              </span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100903.png" alt="image-20201210204558543" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>用户说明</td>
</tr>
<tr>
<td><strong>PID</strong></td>
<td><strong>进程识别号</strong></td>
</tr>
<tr>
<td>%CPU</td>
<td>进程占用 cpu 百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程占用物理内存百分比</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程占用虚拟内存大小(KB)</td>
</tr>
<tr>
<td>RSS</td>
<td>进程占用物理内存大小(KB)</td>
</tr>
<tr>
<td>TTY</td>
<td>终端机号（如果是？，则表示没有控制终端）</td>
</tr>
<tr>
<td>STAT</td>
<td>进程状态，<strong>S 睡眠，进程没有运行，而是，正在等待一个事件</strong>；<strong>R 正在运行或准备运行</strong>；Z 僵尸进程，即已经终止，但父进程没有清空它（父进程已不存在）；T 被跟踪或被停止；**&lt;表明是一个高级优先进程，会给与更多的 CPU 时间**。</td>
</tr>
<tr>
<td>STARTED</td>
<td>进程启动的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>此进程所消耗的CPU时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>正在执行的命令或进程名</td>
</tr>
<tr>
<td>PPID</td>
<td>该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）</td>
</tr>
</tbody></table>
<h2 id="3-查看进程树（pstree）"><a href="#3-查看进程树（pstree）" class="headerlink" title="3. 查看进程树（pstree）"></a>3. 查看进程树（pstree）</h2><ul>
<li>查看进程树：pstree [选项]<ul>
<li>-p：显示进程的PID</li>
<li>-u：显示进程的所属用户</li>
</ul>
</li>
</ul>
<h2 id="4-终止进程（kill）"><a href="#4-终止进程（kill）" class="headerlink" title="4. 终止进程（kill）"></a>4. 终止进程（kill）</h2><blockquote>
<p>若是某个进程执行一半需要停止时，或是消耗了很大的系统资源时，此时可以考虑停止该进程，使用kill命令来完成此任务</p>
</blockquote>
<ul>
<li>kill [选项] 进程号：通过进程号杀死进程<ul>
<li>-9：表示强迫进程立刻停止。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。</li>
</ul>
</li>
<li>killall 进程名称：通过<u>进程名称</u>杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用。</li>
<li>默认参数下，kill 发送SIGTERM（15）信号给进程，告诉进程，你需要被关闭，请自行停止运行并退出，也就是告诉进程可能的话就停止运行，但是如果有不服管教的进程，那它会忽略此请求（有时候系统会觉得某个进程正在执行，可能是误操作，所以不会真正杀死进程，比如强制关掉某个终端，就必须使用-9）。而kill -9 发送 SIGKILL 信号给进程，告诉进程，你被终结了，请立刻退出。TERM(或数字9）表示“无条件终止”；</li>
<li>总结就是：kill -9 无条件终止，kill -15 尽可能终止</li>
<li>案例：踢掉某个非法用户</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100901.png" style="zoom:70%;" />

<p>也可以直接使用ps -aux | grep sshd，找到非法用户名（sshd：xxx@pts&#x2F;x）</p>
<h2 id="5-服务-Service-管理"><a href="#5-服务-Service-管理" class="headerlink" title="5. 服务(Service)管理"></a>5. 服务(Service)管理</h2><blockquote>
<p>服务(Service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql,sshd 防火墙等)，因此我们又称为守护进程。</p>
</blockquote>
<h3 id="（1）service-管理指令（systemctl）"><a href="#（1）service-管理指令（systemctl）" class="headerlink" title="（1）service 管理指令（systemctl）"></a>（1）service 管理指令（systemctl）</h3><blockquote>
<p>service 管理指令：</p>
<p>在 CentOS7.0 之前：service 服务名 [命令] </p>
<p>在 CentOS7.0 之后：systemctl  [命令]  服务名</p>
</blockquote>
<ul>
<li><p>命令</p>
<ul>
<li><strong>start</strong> ：立即启动服务</li>
<li><strong>stop</strong>：立即关闭服务</li>
<li><strong>restart</strong>： 重新启动服务</li>
<li><strong>reload</strong> ：不关闭服务，但使得新配置文件生效</li>
<li>status：显示服务的状态（active（running）正在执行、inactive（dead）未在执行）</li>
<li>enable：设定服务开机自启</li>
<li>disable：设置服务开机不自启</li>
</ul>
</li>
<li><p>查看防火墙情况：</p>
<ul>
<li>service iptables status</li>
<li>systemctl status firewalld（7.0之后的版本）</li>
</ul>
</li>
<li><p>测试某个端口是否在监听：telnet</p>
</li>
</ul>
<h3 id="（2）查看所有服务开机自启情况"><a href="#（2）查看所有服务开机自启情况" class="headerlink" title="（2）查看所有服务开机自启情况"></a>（2）查看所有服务开机自启情况</h3><ul>
<li>方式1：setup 指令</li>
<li>方式2：ls -l &#x2F;etc&#x2F;init.d&#x2F;</li>
</ul>
<h3 id="（3）服务的运行级别（runlevel）"><a href="#（3）服务的运行级别（runlevel）" class="headerlink" title="（3）服务的运行级别（runlevel）"></a>（3）服务的运行级别（runlevel）</h3><ul>
<li>查看或修改默认级别：vim &#x2F;etc&#x2F;inittab</li>
<li>每个服务对应的每个运行级别都可以设置 </li>
<li>指定运行级别<ul>
<li>0.关机</li>
<li>1.单用户模式【可用于找回丢失密码】<ul>
<li>单用户模式下只启动基本的系统进以及一个控制台终端进程。</li>
<li>通常用来再系统有问题时进行紧急的文件系统维护，只有一个人（系统管理员）能登录到系统上操作数据。</li>
</ul>
</li>
<li>2.多用户状态没有网络服务</li>
<li><strong>3.多用户状态有网络服务</strong><ul>
<li>标准的启动运行级，大多数应用软件都会启动。</li>
</ul>
</li>
<li>4.系统未使用保留给用户</li>
<li><strong>5.图形界面</strong></li>
<li>6.系统重启</li>
<li>系统的运行级别配置文件：&#x2F;etc&#x2F;inittab </li>
<li>切换到指定运行级别的指令：init [012356]</li>
</ul>
</li>
</ul>
<h3 id="（4）开机流程"><a href="#（4）开机流程" class="headerlink" title="（4）开机流程"></a>（4）开机流程</h3><p>开机-&gt;BIOS-&gt;&#x2F;boot-&gt;init进程1-&gt;运行级别-&gt;运行级对应的服务</p>
<h3 id="（5）chkconfig指令"><a href="#（5）chkconfig指令" class="headerlink" title="（5）chkconfig指令"></a>（5）chkconfig指令</h3><blockquote>
<p>chkconfig：可以给每个服务的各个运行级别设置自启动&#x2F;关闭</p>
</blockquote>
<ul>
<li>查看xxx服务：chkconfig –list | grep xxx</li>
<li>查看服务的状态：chkconfig 服务名 –list</li>
<li>给服务的运行级别设置自启动：chkconfig –level 5 服务名 on&#x2F;off</li>
<li>要所有运行级别关闭或开启：chkconfig 服务名 on&#x2F;off</li>
<li><strong>chkconfig重新设置后需要重新启动才能生效</strong></li>
</ul>
<h2 id="6-动态监控进程（top）"><a href="#6-动态监控进程（top）" class="headerlink" title="6. 动态监控进程（top）"></a>6. 动态监控进程（top）</h2><blockquote>
<p>top 与 ps 相似，都是用来显示正在执行的进程，top 的不同之处在于 top 执行一段时间可以更新正在运行的进程，即查看服务器的进程占的资源（100%使用）。</p>
</blockquote>
<blockquote>
<p>top [选项]</p>
<ul>
<li>-d 秒数：指定top命令每隔几秒更新。默认是3秒。</li>
<li>-i：使top不显示任何闲置或者僵死进程。</li>
<li>-p：通过指定监控进程ID来仅仅监控某个进程的状态。</li>
</ul>
</blockquote>
<ul>
<li>交互操作说明：</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>以CPU使用率排序，默认就是此项</td>
</tr>
<tr>
<td>M</td>
<td>以内存的使用率排序</td>
</tr>
<tr>
<td>N</td>
<td>以PID排序</td>
</tr>
<tr>
<td>q</td>
<td>退出top</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100902.png"></p>
<p>使用<code>uptime</code>命令可以看到 top 第一行的内容，其中 load average 后面的三个数分别是<strong>最近1分钟、5分钟、15分钟的负载情况</strong>。load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。</p>
<h1 id="七-网络管理"><a href="#七-网络管理" class="headerlink" title="七. 网络管理"></a>七. 网络管理</h1><h2 id="1-IP地址（ipconfig）"><a href="#1-IP地址（ipconfig）" class="headerlink" title="1. IP地址（ipconfig）"></a>1. IP地址（ipconfig）</h2><blockquote>
<p>ifconfig</p>
</blockquote>
<h2 id="2-测试主机之间网络的连通性（ping）"><a href="#2-测试主机之间网络的连通性（ping）" class="headerlink" title="2. 测试主机之间网络的连通性（ping）"></a>2. 测试主机之间网络的连通性（ping）</h2><blockquote>
<p>ping命令用于测试主机之间网络的连通性。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c 次数</td>
<td>指定发送的ICMP报文的次数</td>
</tr>
<tr>
<td>-i 时间间隔</td>
<td>相邻两次发送报文的时间间隔，默认为1s</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="3-查看网络情况（netstat）"><a href="#3-查看网络情况（netstat）" class="headerlink" title="3. 查看网络情况（netstat）"></a>3. 查看网络情况（netstat）</h2><blockquote>
<p>netstat 用于查看占用端口的进程</p>
<p>netstat [选项]</p>
<ul>
<li>-an：按一定顺序排列输出</li>
<li>-n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示</li>
<li>-p：显示哪个进程在调用（表示显示发起连接的进程pid和进程名称）</li>
<li>-t ：显示TCP传输协议的连线状况</li>
<li>-u ：显示UDP传输协议的连线状况</li>
<li>-l：显示监听中的服务器的Socket</li>
</ul>
<p>常用：<strong>netstat -tunlp</strong></p>
</blockquote>
<ol>
<li><p>查看所有的网络服务</p>
<ul>
<li>netstat -anp | more</li>
</ul>
</li>
<li><p>查看sshd的服务的信息</p>
<ul>
<li>netstat -anp | grep sshd</li>
</ul>
</li>
<li><p><u>查看所有处于连接状态的端口信息</u></p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100905.png" alt="img"></p>
</li>
</ol>
<h2 id="4-防火墙（TODO）"><a href="#4-防火墙（TODO）" class="headerlink" title="4. 防火墙（TODO）"></a>4. 防火墙（TODO）</h2><p>对于 CentOS7 之前，防火墙为 iptables，CentOS7 之后，使用的是 firewall。</p>
<p><code>service iptables start/restart/stop</code> ：iptables 服务启动&#x2F;重启&#x2F;关闭</p>
<p><code>service iptables status</code>：查看 iptables 的状态</p>
<p>简单设置防火墙规则：</p>
<p>例如，需要允许80端口通过防火墙，则规则可以用以下的命令来设置</p>
<p><code>iptables -I INPUT -p tcp --dport 80 -j ACCEPT</code>  #允许访问80端口</p>
<ul>
<li>Iptables：主命令</li>
<li>-I：表示将规则放到最前面</li>
<li>-A：add，添加规则（最后）</li>
<li>INPUT：进站请求【出站output】</li>
<li>-p：protocol，指定协议（icmp&#x2F;tcp&#x2F;udp）</li>
<li>–dport：指定端口号</li>
<li>-j：指定行为结果，允许（accept）&#x2F;禁止（reject）&#x2F;丢弃（drop）</li>
</ul>
<p>开放某个端口</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent <span class="comment"># 开放命令</span></span><br><span class="line">firewall-cmd --reload <span class="comment"># 刷新防火墙</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件下载（wget）"><a href="#5-文件下载（wget）" class="headerlink" title="5. 文件下载（wget）"></a>5. 文件下载（wget）</h2><blockquote>
<p>wget 是 Linux 系统下载文件工具，<strong>用来从指定的 URL 下载文件</strong>。wget 非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget 会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<p>wget 支持 HTTP，HTTPS 和 FTP 协议，可以使用 HTTP 代理。所谓的自动下载是指，wget 可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个 wget 下载任务，然后退出系统，wget 将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。</p>
</blockquote>
<p>语法：<code>wget [参数] [URL地址]</code></p>
<ul>
<li>常规下载：<code> wget https://github.com/jaywcjlove/linux-command/archive/master.zip</code></li>
<li>自定义保存文件名：<code> wget -O 自定义名称 https://github.com/jaywcjlove/linux-command/archive/master.zip</code></li>
<li>后台下载： <code>wget -b  https://github.com/jaywcjlove/linux-command/archive/master.zip</code></li>
<li>自动断点下载：<code>wget -c http://www.gitnavi.com/index.html</code>  (使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件)</li>
<li>伪装代理名称下载：<code>wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; https://github.com/jaywcjlove/linux-command/archive/master.zip</code></li>
</ul>
<h1 id="八-软件安装"><a href="#八-软件安装" class="headerlink" title="八. 软件安装"></a>八. 软件安装</h1><h2 id="1-CentOS"><a href="#1-CentOS" class="headerlink" title="1. CentOS"></a>1. CentOS</h2><h3 id="（1）-RPM-包安装"><a href="#（1）-RPM-包安装" class="headerlink" title="（1） RPM 包安装"></a>（1） RPM 包安装</h3><blockquote>
<p>RPM：RedHat Package Manager，红帽软件包管理工具。 Linuxd分发版本都有采用（suse,redhat，centos等）</p>
</blockquote>
<p>（1）查看指令</p>
<ul>
<li>RPM 查询已安装的 rpm 列表：<u>rpm -qa | grep xx</u><ul>
<li>查看是否安装 firefox：rpm -qa |grep firefox </li>
<li>如果是 i686,i386 表示 32 位系统，noarch 表示通用</li>
</ul>
</li>
<li>rpm -qa：查询所安装的所有rpm软件包</li>
<li>rpm -q xx：查询xx软件包是否安装</li>
<li>rpm -qi xx：查询软件包信息</li>
<li>rpm -ql xx：查询软件包中的文件</li>
<li>rpm -qf 文件全路径名：查询文件所属的软件包</li>
</ul>
<p>（2）卸载指令</p>
<ul>
<li>卸载 rpm 包：<u>rpm -e 软件包名称</u></li>
<li>如果其他软件依赖于要卸载的包，删除时可能会发生依赖错误</li>
<li>忽视依赖强制删除的方法：rpm -e –nodeps 软件包名称 可以强制删除，但不建议这样做，否则会导致程序无法运行</li>
</ul>
<p>（3）安装指令</p>
<ul>
<li>安装 rpm 包：<u>rpm -ivh 软件包全路径名称</u><ul>
<li>i&#x3D;install：安装</li>
<li>v&#x3D;verbose：提示</li>
<li>h&#x3D;hash：进度条</li>
</ul>
</li>
</ul>
<h3 id="（2）-yum-在线安装"><a href="#（2）-yum-在线安装" class="headerlink" title="（2） yum 在线安装"></a>（2） yum 在线安装</h3><blockquote>
<p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。 基于 RPM 包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
</blockquote>
<ul>
<li>yum list | grep xx：查询yum服务器是否有需要安装的软件</li>
<li><code>yum install xx</code>：安装指定的yum包<ul>
<li>参数，-y（当安装过程提示选择全部为”yes”）</li>
</ul>
</li>
<li><code>yum -y remove xx / yum erase xx</code>：卸载指定的yum包</li>
<li><code>yum update</code>：更新系统软件包</li>
</ul>
<h2 id="2-Ubuntu"><a href="#2-Ubuntu" class="headerlink" title="2.Ubuntu"></a>2.Ubuntu</h2><h3 id="（1）deb-包安装"><a href="#（1）deb-包安装" class="headerlink" title="（1）deb 包安装"></a>（1）deb 包安装</h3><p>安装：先从网上下载 deb 包，然后使用命令 depk -i xxx.deb</p>
<p>删除：depk - r 名称</p>
<h3 id="（2）agt-get-在线安装"><a href="#（2）agt-get-在线安装" class="headerlink" title="（2）agt-get 在线安装"></a>（2）agt-get 在线安装</h3><blockquote>
<p>Advanced Package Tool，又名 apt-get，是一款适用于<a href="https://baike.baidu.com/item/Unix">Unix</a>和<a href="https://baike.baidu.com/item/Linux">Linux</a>系统的应用程序管理器。最初于1998年发布，用于检索应用程序并将其加载到 Debian Linux 系统（比如Ubuntu）。</p>
</blockquote>
<ul>
<li><code>apt-get install xx</code>：安装指定的软件包</li>
<li><code>apt-get remove xx</code>：卸载一个已安装的软件包（保留配置文档）</li>
<li><code>apt-get update; apt-get upgrade</code>：更新系统软件包（软件列表）</li>
</ul>
<h1 id="九-磁盘和内存管理"><a href="#九-磁盘和内存管理" class="headerlink" title="九. 磁盘和内存管理"></a>九. 磁盘和内存管理</h1><blockquote>
<p>对于磁盘的使用，首先找到磁盘所在分区（fdisk）、然后挂载（mount）</p>
</blockquote>
<h2 id="1-df-指令"><a href="#1-df-指令" class="headerlink" title="1. df 指令"></a>1. df 指令</h2><blockquote>
<p>用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。可以加上-h，以人类友好格式显示文件系统硬盘空间使用情况。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">df</span> -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">udev            7.8G     0  7.8G    0% /dev</span><br><span class="line">tmpfs           1.6G   10M  1.6G    1% /run</span><br><span class="line">/dev/sda2       3.6T  2.7T  812G   77% /</span><br><span class="line">tmpfs           7.8G  4.0K  7.8G    1% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M    1% /run/lock</span><br><span class="line">tmpfs           7.8G     0  7.8G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1       511M  3.5M  508M    1% /boot/efi</span><br><span class="line">tmpfs           1.6G     0  1.6G    0% /run/user/1000</span><br><span class="line">tmpfs           1.6G     0  1.6G    0% /run/user/1004</span><br></pre></td></tr></table></figure>

<h2 id="2-du-指令"><a href="#2-du-指令" class="headerlink" title="2. du 指令"></a>2. du 指令</h2><blockquote>
<p>显示每个文件和目录的磁盘使用空间文件的大小（df 是全部的文件系统磁盘）。</p>
<p>du [选项][文件]</p>
</blockquote>
<p>常见选项：</p>
<ul>
<li>-a或-all 显示目录中个别文件的大小，单位为KB。  </li>
<li>-b或-bytes 显示目录或文件大小时，以byte为单位。  </li>
<li>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 </li>
<li>-m或–megabytes 以MB为单位输出。  </li>
<li><strong>-s或–summarize 仅显示子目录的总值，而不会把子目录中所有文件大小都列出来</strong>，如果没有s选项，非目录大小不会列出来。</li>
<li><strong>-h或–human-readable 以K，M，G为单位，提高信息的可读性。</strong></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">//查看当前目录下各个文件及目录占用空间大小</span><br><span class="line"><span class="built_in">du</span> -sh *</span><br><span class="line"></span><br><span class="line">[zhang@VM-0-13-centos ~]$ <span class="built_in">du</span> -sh *</span><br><span class="line">4.0K	a.txt</span><br><span class="line">4.0K	cal.txt</span><br><span class="line">4.0K	date.txt</span><br><span class="line">12K		mydir</span><br></pre></td></tr></table></figure>

<h2 id="3-free指令"><a href="#3-free指令" class="headerlink" title="3. free指令"></a>3. free指令</h2><blockquote>
<p>free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            15G        7.8G        287M        676M        7.5G        6.7G</span><br><span class="line">Swap:          976M         38M        938M</span><br><span class="line"></span><br><span class="line">Mem 行(第二行)是内存的使用情况。</span><br><span class="line">Swap 行(第三行)是交换空间的使用情况。</span><br><span class="line">total 列显示系统总的可用物理内存和交换空间大小。</span><br><span class="line">used 列显示已经被使用的物理内存和交换空间。</span><br><span class="line">free 列显示还有多少物理内存和交换空间可用使用。</span><br><span class="line">shared 列显示被共享使用的物理内存大小。</span><br><span class="line">buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。</span><br><span class="line">available 列显示还可以被应用程序使用的物理内存大小。</span><br></pre></td></tr></table></figure>

<h2 id="4-mount-指令"><a href="#4-mount-指令" class="headerlink" title="4. mount 指令"></a>4. mount 指令</h2><blockquote>
<p>挂载：Linux 中的根目录以外的文件要想被访问，需要将其“关联”到根目录下的某个目录来实现，这种关联操作就是“挂载”，这个目录就是“挂载点”，解除次关联关系的过程称之为“卸载”。</p>
<p>注意：“挂载点”的目录需要以下几个要求：</p>
<p>（1）目录事先存在，可以用 mkdir 命令新建目录；</p>
<p>（2）挂载点目录不可被其他进程使用到；</p>
<p>（3）挂载点下原有文件将被隐藏。</p>
<p>挂载指令：mount [-t vfstype] [-o options] device dir</p>
</blockquote>
<ul>
<li>-t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<ul>
<li>光盘或光盘镜像：iso9660</li>
<li>DOS fat16文件系统：msdos</li>
<li>Windows 9x fat32文件系统：vfat</li>
<li>Windows NT ntfs文件系统：ntfs</li>
<li>Mount Windows文件网络共享：smbfs</li>
<li>UNIX(LINUX) 文件网络共享：nfs</li>
</ul>
</li>
<li>-o options 主要用来描述设备或档案的挂接方式。常用的参数有：<ul>
<li>loop：用来把一个文件当成硬盘分区挂接上系统</li>
<li>ro：采用只读方式挂接设备</li>
<li>rw：采用读写方式挂接设备</li>
<li>iocharset：指定访问文件系统所用字符集</li>
</ul>
</li>
<li>device 要挂接(mount)的设备。</li>
<li>dir设备在系统上的挂接点(mount point)。</li>
</ul>
<p>简单挂载：<strong>mount 设备原始地址 要挂载的位置路径</strong>，比如<code>sudo mount /dev/sdb1 /mnt</code></p>
<ul>
<li><p>设备原始地址：地址统一都在&#x2F;dev下，然后根据大小确定具体name值（使用lsblk&#x2F;fdisk指令），拼凑在一起组成原始地址，例如当前：“&#x2F;dev&#x2F;sr0”</p>
</li>
<li><p>要挂载的位置路径：挂载目录一般都在mnt下，也可以在mnt下建目录，此处以“&#x2F;mnt&#x2F;dvd”为例</p>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100904.jpg" style="zoom:70%;" />

<p>简单解挂：<strong>umount 当前设备的挂载点（即路径）</strong>，比如<code>umount /media/zhang/张李虎</code>，注意不要在挂载点去解除挂载（相当于要拆房子，自己却在房子中），不允许的操作。</p>
<h2 id="5-lsblk-指令"><a href="#5-lsblk-指令" class="headerlink" title="5. lsblk 指令"></a>5. lsblk 指令</h2><blockquote>
<p>lsblk 【选项】【设备文件名】：</p>
</blockquote>
<p>选项：</p>
<ul>
<li><strong>-d：</strong>仅列出磁盘本身，并不会列出该磁盘的分区信息</li>
<li>-f：同时列出该磁盘内的文件系统名称</li>
<li>-i：使用ASCII的字符输出，不要使用使用复杂的编码(在某些环境下有用)</li>
<li>-m：同时输出该设备在&#x2F;dev下面的权限信息(rwx的数据)</li>
<li><strong>-p：</strong>列出该设备的完整文件名（因为不加这个选项，显示的是最后的名字）</li>
<li>-t：列出该磁盘设备的详细数据，包括磁盘列阵机制、预读写的数据量大小等</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  3.7T  0 disk </span><br><span class="line">├─sda2   8:2    0  3.7T  0 part /</span><br><span class="line">├─sda3   8:3    0  977M  0 part [SWAP]</span><br><span class="line">└─sda1   8:1    0  512M  0 part /boot/efi</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><u>NAME</u></strong></td>
<td>设备的文件名，如果不加-p选项，会忽略&#x2F;dev等前导目录</td>
</tr>
<tr>
<td>MAJ:MIN</td>
<td>分别是主要与次要设备代码。内核识别的设备都是通过这两个代码来实现的</td>
</tr>
<tr>
<td>RM</td>
<td>是否为可卸载的设备，如光盘、USB磁盘等</td>
</tr>
<tr>
<td><strong><u>SIZE</u></strong></td>
<td>容量</td>
</tr>
<tr>
<td>RO</td>
<td>是否为只读设备的意思</td>
</tr>
<tr>
<td><strong><u>TYPE</u></strong></td>
<td>是磁盘(disk)、分区(partition)、只读存储器(rom)等输出</td>
</tr>
<tr>
<td><strong><u>MOUNTPOINT</u></strong></td>
<td>挂载点</td>
</tr>
</tbody></table>
<h2 id="6-fdisk-指令"><a href="#6-fdisk-指令" class="headerlink" title="6. fdisk 指令"></a>6. fdisk 指令</h2><blockquote>
<p>fdisk指令用于管理安装在系统上的任何存储设备上的分区。其可以在设备上编辑，删除，和创建分区，但必须要有管理员权限。</p>
<ul>
<li>-l 列出素所有分区表</li>
</ul>
<p>在挂载之前，首先要知道所要<strong>挂载U盘所在的分区</strong>，就需要使用sudo fdisk -l</p>
</blockquote>
<h1 id="十-其他指令"><a href="#十-其他指令" class="headerlink" title="十. 其他指令"></a>十. 其他指令</h1><h2 id="1-时间（data-x2F-cal）"><a href="#1-时间（data-x2F-cal）" class="headerlink" title="1. 时间（data&#x2F;cal）"></a>1. 时间（data&#x2F;cal）</h2><ul>
<li><p>date：显示当前日期和时间</p>
<ul>
<li><p>date “+%Y”：显示当前年份</p>
</li>
<li><p>date “+%d”：显示当前月份</p>
</li>
<li><p>date “+%F”：等价于date “+%Y-%m-%d” ，显示年月日</p>
</li>
<li><p>date “+%T”：等价于date “+%H:%M:%S” ，显示时分秒</p>
</li>
<li><p>date “+%Y-%m-%d %H:%M:%S”：显示年-月-日 时：分：秒</p>
</li>
<li><p>设置日期：date -s 字符串时间</p>
</li>
<li><p>date -d “**-1 day**” “+%Y-%m-%d %H:%M:%S”  ：获取之前或者之后的某个时间（备份）</p>
<p>符号的可选值：+（之后） 或者 - （之前）</p>
<p>单位的可选值：day（天）、month（月份）、year（年）</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">date</span>                     </span><br><span class="line">2020年 12月 21日 星期一 18:41:14 CST</span><br><span class="line">➜  ~ <span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>     <span class="comment"># 引号也可以不要，但+左边要有空格，右边没有空格 </span></span><br><span class="line">2020-12-21 18:42:39</span><br><span class="line">➜  ~ <span class="built_in">date</span> <span class="string">&quot;+%F&quot;</span>         </span><br><span class="line">2020-12-21</span><br><span class="line">➜  ~ <span class="built_in">date</span> -d <span class="string">&quot;-1 year&quot;</span> <span class="string">&quot;+%F&quot;</span></span><br><span class="line">2019-12-21</span><br></pre></td></tr></table></figure>
</li>
<li><p>cal：查看日历指令；</p>
<ul>
<li>cal [月] [年份]：显示某一年或月的日历</li>
</ul>
</li>
</ul>
<h2 id="2-定时任务"><a href="#2-定时任务" class="headerlink" title="2. 定时任务"></a>2. 定时任务</h2><h3 id="（1）周期性执行（crontab）"><a href="#（1）周期性执行（crontab）" class="headerlink" title="（1）周期性执行（crontab）"></a>（1）周期性执行（crontab）</h3><blockquote>
<p>默认情况下，linux 操作系统会自动启动 crond 进程（周期性的执行某种任务或等待处理某些事件的一个守护进程），此进程会每分钟定期检测是否有需要执行的任务，如果有，就会执行该任务（类似于闹钟，定点执行）。</p>
<p>而 crontab 就是所需要执行任务的表。</p>
<p>指令： crontab [-u user] [ -e | -l | -r ]  &#x2F;  crontab [-u user] file</p>
</blockquote>
<p>系统会默认运行 crond 进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zhang@VM-0-13-centos etc]$ ps -aux|grep crond</span><br><span class="line">root      1243  0.0  0.0 126420  1652 ?        Ss   13:44   0:00 /usr/sbin/crond -n</span><br><span class="line">zhang     2833  0.0  0.0 112812   972 pts/0    R+   19:07   0:00 grep --color=auto crond</span><br></pre></td></tr></table></figure>

<p>任务分类：</p>
<ul>
<li><p><u>系统任务调度</u>：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在 &#x2F;etc 目录下有一个crontab 文件，这个就是系统任务调度的配置文件</p>
</li>
<li><p><u>用户任务调度</u>：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在 &#x2F;var&#x2F;spool&#x2F;cron&#x2F; 文件名下，其文件名与用户名一致。（即当用户创建一个 crontab 任务后，就会在 var&#x2F;spool&#x2F;cron 目录下，创建一个与用户名一样的文件，该文件内容就是用户创建的 crontab 任务的内容）</p>
</li>
</ul>
<p>选项：</p>
<ul>
<li><strong>-u user</strong>：-u 用来指定某个用户的 crontab 服务，例如，“-u zhang”表示设定用户 zhang 的 crontab 服务，此参数一般由 root 用户来运行，如果不设置，默认为当前用户。</li>
<li>file：file 是命令文件的名字（通常是 shell 脚本），表示将 file 做为 crontab 的任务列表文件并载入 crontab。如果在命令行中没有指定这个文件，crontab 命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li><strong>-e</strong>：编辑用户的 crontab 文件内容。当用户编辑完文件内容后，会在&#x2F;var&#x2F;spool&#x2F;cron目录下，创建一个与用户名一样的文件，该文件内容就是用户创建的 crontab 任务的内容</li>
<li><strong>-l</strong>：显示某个用户的 crontab 文件内容</li>
<li><strong>-r</strong>：从 &#x2F;var&#x2F;spool&#x2F;cron 目录中删除某个用户的 crontab 文件</li>
</ul>
<p>crontab内容格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br><span class="line"><span class="comment"># 分钟 小时 天 月 周 所要定时执行的命令</span></span><br></pre></td></tr></table></figure>

<p>前五个时间设定段，可以含如下特殊字符：</p>
<ul>
<li>星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作；</li>
<li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”；</li>
<li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”；</li>
<li>正斜线（&#x2F;）：可以用正斜线指定时间的间隔频率，例如“0-23&#x2F;2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*&#x2F;10，如果用在 minute 字段，表示每十分钟执行一次。</li>
</ul>
<p>举例1：每隔一分钟，将当前日期追加到 &#x2F;home&#x2F;zhang&#x2F;date.txt 文本中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zhang@VM-0-13-centos ~]$ crontab -l</span><br><span class="line">no crontab <span class="keyword">for</span> zhang</span><br><span class="line">[zhang@VM-0-13-centos ~]$ crontab -e  <span class="comment"># 输入*/1 * * * * date +%F &gt;&gt; /home/zhang/date.txt</span></span><br><span class="line">no crontab <span class="keyword">for</span> zhang - using an empty one   </span><br><span class="line">crontab: installing new crontab</span><br><span class="line">[zhang@VM-0-13-centos ~]$ crontab -l</span><br><span class="line">*/1 * * * * <span class="built_in">date</span> &gt;&gt; /home/zhang/date.txt</span><br></pre></td></tr></table></figure>

<p>举例2：每天凌晨 4 点，将 mysql 的一个名叫 account 的数据库备份到 account_db.bak 中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0 4 * * * mysqldump -u root -p 密码 account &gt;/home/zhang/account_db.bak</span><br></pre></td></tr></table></figure>

<h3 id="（2）一次性执行（at）"><a href="#（2）一次性执行（at）" class="headerlink" title="（2）一次性执行（at）"></a>（2）一次性执行（at）</h3><blockquote>
<p>crontab 会循环执行任务，而如果只想在某个时间点执行一次，就可以使用 at 命令（一次性定时任务）。同样，linux 也会运行一个名叫 atd 的守护进程查看是否有任务需要定点执行（将任务时间与当前时间对比，如果相等即执行）。</p>
<p>指令：at 【选项】【时间】</p>
</blockquote>
<p>系统会默认运行atd进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zhang@VM-0-13-centos ~]$ ps -ef|grep atd</span><br><span class="line">root      1244     1  0 13:44 ?        00:00:00 /usr/sbin/atd -f</span><br><span class="line">zhang    14403  6861  0 20:07 pts/1    00:00:00 grep --color=auto atd</span><br></pre></td></tr></table></figure>

<p>选项：</p>
<ul>
<li>-l：列出当前用户的at任务列表，也可使用 atq </li>
<li>-d 任务编号：取消一个 at 任务，后面跟 at 任务编号，也可使用 atrm 任务编号代替 </li>
<li>-c 任务编号：显示该任务的实际内存，如：at -c 1 ,显示 1 号任务的详情</li>
<li>时间格式<ul>
<li><u>HH:MM</u> 如： at 02:30</li>
<li><u>HH:MM YYYY-MM-DD</u> 如：at 8:00 2020-01-01</li>
<li><u>HH:MM[am | pm] [month] [date]</u> 如：at 8:00 Oct 1 # 在十月一号的八点</li>
<li><u>HH:MM[am | pm] + number [minutes | hours | days | weeks]</u> 如：at 8:00 + 1days</li>
<li><u>now + 时间</u> 比如在十分钟后：at now + 10 minutes，在一天后：at now + 1 days</li>
</ul>
</li>
</ul>
<p>使用 ctrl+D 退出</p>
<p>举例：在一分钟后，将日历写入到 cal.txt 文本中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zhang@VM-0-13-centos ~]$ at now + 1 minutes</span><br><span class="line">at&gt; cal &gt;/home/zhang/cal.txt&lt;EOT&gt;  <span class="comment"># 输入结束后，按ctrl+D退出</span></span><br><span class="line">job 3 at Thu Apr 22 20:15:00 2021</span><br></pre></td></tr></table></figure>

<h2 id="3-找回-root-密码"><a href="#3-找回-root-密码" class="headerlink" title="3. 找回 root 密码"></a>3. 找回 root 密码</h2><p>必须在服务器机上找回 root 密码，不能远程修改。</p>
<p>一步：重启，按下”e”键，进入编辑模式</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100906.png" style="zoom:80%;" />

<p>第二步：在 linux16 这行的后面输入“rd.break“，按下 Ctrl+X，以单用户模式启动</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100907.png" style="zoom:78%;" />

<p>第三步：依次输入</p>
<p>#mount –o remount,rw &#x2F;sysroot</p>
<p>#chroot &#x2F;sysroot</p>
<p>#passwd           修改root密码</p>
<p>#touch &#x2F;.autorelabel</p>
<p>#exit</p>
<p>#reboot，重启后密码就修改成功了！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100908.png" style="zoom: 70%;" />

<h2 id="4-有趣的指令"><a href="#4-有趣的指令" class="headerlink" title="4. 有趣的指令"></a>4. 有趣的指令</h2><h3 id="（1）-火车（sl）"><a href="#（1）-火车（sl）" class="headerlink" title="（1） 火车（sl）"></a>（1） 火车（sl）</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现效果：一辆呼啸而过的火车。</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum install -y sl</span><br><span class="line"><span class="comment"># 运行指令</span></span><br><span class="line">sl</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100912.gif" alt="image-20210508144544722" style="zoom: 67%;" />

<h3 id="（2）一头牛（cowsay）"><a href="#（2）一头牛（cowsay）" class="headerlink" title="（2）一头牛（cowsay）"></a>（2）一头牛（cowsay）</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现效果：打印出来一头牛</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">yum install -y epel-release</span><br><span class="line">yum -y install cowsay</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">cowsay <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100909.png"></p>
<h2 id="5-Sed-指令"><a href="#5-Sed-指令" class="headerlink" title="5. Sed 指令"></a>5. Sed 指令</h2><blockquote>
<p>sed 是 stream editor（流编辑器）的简称。它对文本流，即一系列指定的文件或标准输入进行编辑。</p>
</blockquote>
<p>常用指令：</p>
<ul>
<li><p><code>sed &#39;s/regexp/replacement/&#39; 文件名</code>。这个命令类似于 vim 中的替换命令，只要找到一个 regexp （正则表达式）匹配项，就将替换为 replacement 的内容。</p>
<p>举例： </p>
<ul>
<li>sed ‘s&#x2F;aaa&#x2F;bbb&#x2F;‘ a.txt  将 a.txt 文本中所有的 aaa 替换成 bbb</li>
</ul>
</li>
</ul>
<h2 id="6-排序数据（sort）"><a href="#6-排序数据（sort）" class="headerlink" title="6. 排序数据（sort）"></a>6. 排序数据（sort）</h2><blockquote>
<p>顾名思义，sort 是对数据进行排序的命令。默认情况下，sort 命令按照会话指定的默认语言的排序规则对文本文件中的数据行排序。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[zhang@VM-0-13-centos ~]$ <span class="built_in">cat</span> test.txt </span><br><span class="line">cc</span><br><span class="line">bb</span><br><span class="line"><span class="built_in">dd</span></span><br><span class="line">aa</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">[zhang@VM-0-13-centos ~]$ <span class="built_in">sort</span> test.txt </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line"><span class="built_in">dd</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，sort 会把数字当做字符来执行标准的字符排序，会使得 10 排在 2 的前面，如果想要按照数字排序的方式，需要添加 -n 参数。</p>
<h1 id="十一-Shell脚本"><a href="#十一-Shell脚本" class="headerlink" title="十一. Shell脚本"></a>十一. Shell脚本</h1><blockquote>
<p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，通过按顺序一行行的执行命令（解释型，不需要编译），实现相应的功能。</p>
</blockquote>
<h2 id="1-第一个-shell-脚本"><a href="#1-第一个-shell-脚本" class="headerlink" title="1. 第一个 shell 脚本"></a>1. 第一个 shell 脚本</h2><ul>
<li><p>① 编写脚本文件（创建一个helloword.sh文件，输入下面内容）。</p>
<p>注意：脚本文件需具有<strong>执行权限</strong>，代码第一行是指定脚本要使用的shell解释器（可省略）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">这是我的第一个脚本</span></span><br><span class="line">echo &#x27;Hello World!&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>② 执行脚本文件。</p>
<p>注意：不能直接使用 helloworld.sh，因为这样会去环境变量中找有没有叫helloworld.sh的，找不到就会执行不了，因而需要使用文件路径（绝对&#x2F;相对）来执行脚本文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./helloworld.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><p>变量定义：<code>变量名=变量值</code>，不需要指定变量的类型（默认会当成字符串）。</p>
<p>定义有类型的变量(declare)：declare -i 变量名&#x3D;变量值（将变量看成整数）</p>
<p>变量定义规则：</p>
<ul>
<li>变量名区分大小写。所有的环境变量名均使用大写字母，如果是自己创建的局部变量或shell脚本，尽量使用小写字母。</li>
<li>命名中只能含有字母，数字和下划线，且首个字符不能以数字开头。</li>
<li><strong>变量名后面等号两边不能有空格，即变量名、等号、值之间不能有空格</strong>。如果在赋值表达式中加上了空格，shell会把值当成一个单独的命令。</li>
<li>不能使用bash中的关键字。</li>
</ul>
<p>变量名的使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$变量名 / <span class="variable">$&#123;变量名&#125;</span></span><br><span class="line"><span class="comment"># 相同点：都可以调用变量。</span></span><br><span class="line"><span class="comment"># 不同点：$&#123;变量名&#125;可以只截取变量的一部分（如$&#123;变量名:1:3&#125;表示截取变量的(1,3]字符），而$变量名不可以。</span></span><br></pre></td></tr></table></figure>

<p>举例：    </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 输出当前时间</span></span><br><span class="line">current=`<span class="built_in">date</span> +%F`  <span class="comment"># 注意外面的不是单引号，而是“飘号”</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$current</span></span><br></pre></td></tr></table></figure>

<p>用户输入：<strong>read【选项】 变量名</strong></p>
<table>
<thead>
<tr>
<th>常见选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>定义提示用户的信息</td>
</tr>
<tr>
<td>-n</td>
<td>定义字符数（限制变量值的长度）</td>
</tr>
<tr>
<td>-s</td>
<td>不显示（不显示用户输入的内容）</td>
</tr>
<tr>
<td>-t</td>
<td>定义超时时间，默认单位为秒（限制用户输入变量值的超时时间）</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 用户输入自己的名字，然后在屏幕上显示其名字</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入你的名字：&quot;</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;你的名字是：&quot;</span>+<span class="variable">$name</span>   <span class="comment"># 可以替换为echo &quot;你的名字是：$name&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：shell脚本中单引号与双引号的区别：</p>
<ul>
<li><p>单引号中的内容会原样输出</p>
</li>
<li><p>双引号中的内容会进行变量替换</p>
</li>
<li><p>举例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">name=<span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$name</span>&quot;</span>    <span class="comment"># 会输出张三</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$name&#x27;</span>    <span class="comment"># 会输出$name</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><p><strong>1）算术运算符</strong></p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left"><code>expr $a + $b</code></td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left"><code>expr $a - $b</code></td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left"><code>expr $a \* $b</code></td>
</tr>
<tr>
<td align="left">&#x2F;</td>
<td align="left">除法</td>
<td align="left"><code>expr $b / $a</code></td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left"><code>expr $b % $a</code></td>
</tr>
<tr>
<td align="left">&#x3D;</td>
<td align="left">赋值</td>
<td align="left">a&#x3D;$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;</td>
<td align="left">相等。用于比较两个数字，相同则返回 true。</td>
<td align="left">[ $a &#x3D;&#x3D; $b ]</td>
</tr>
<tr>
<td align="left">!&#x3D;</td>
<td align="left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td align="left">[ $a !&#x3D; $b ]</td>
</tr>
</tbody></table>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr</p>
<p>举例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 让用户输入两个数，然后计算这两个数的四则运算，并输出在屏幕上。</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入第一个数：&quot;</span> a</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入第二个数：&quot;</span> b</span><br><span class="line">val1=`<span class="built_in">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span>`</span><br><span class="line">val2=`<span class="built_in">expr</span> <span class="variable">$a</span> - <span class="variable">$b</span>`</span><br><span class="line">val3=`<span class="built_in">expr</span> <span class="variable">$a</span> \* <span class="variable">$b</span>`</span><br><span class="line">val4=`<span class="built_in">expr</span> <span class="variable">$a</span> / <span class="variable">$b</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="variable">$val1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> - <span class="variable">$b</span> = <span class="variable">$val2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> * <span class="variable">$b</span> = <span class="variable">$val3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> / <span class="variable">$b</span> = <span class="variable">$val4</span>&quot;</span>  <span class="comment"># 注意：两个整数相除结果为整除</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">请输入第一个数：8</span><br><span class="line">请输入第二个数：3</span><br><span class="line">8 + 3 = 11</span><br><span class="line">8 - 3 = 5</span><br><span class="line">8 * 3 = 24</span><br><span class="line">8 / 3 = 2</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><p>运算符左右两边都需要有空格，如果没有空格表示是字符串连接.</p>
</li>
<li><p>计算乘法时，需使用&#x2F;*，因为shell可能会误解星号含义.</p>
</li>
<li><p>expr 只能进行整数之间的四则运算，如果计算的时非整数，会出现错误.</p>
</li>
<li><p>expr 默认是直接把运算结果输出到控制台，如果需要赋值，则需要使用飘符号&#96;.</p>
</li>
<li><p>对于四则运算，最好用$(())代替expr，效率更高，而且运算符两边不用空格.（<u>但也只能计算整数</u>）</p>
<p>$((expression))是linux的一种字符展开（更具体来说是算术表达式展开），在括号里面输入表达式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入第一个数：&quot;</span> a</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入第二个数：&quot;</span> b</span><br><span class="line">val1=$((<span class="variable">$a</span>+<span class="variable">$b</span>))</span><br><span class="line">val2=$((<span class="variable">$a</span>-<span class="variable">$b</span>))</span><br><span class="line">val3=$((a\*<span class="variable">$b</span>))</span><br><span class="line">val4=$((<span class="variable">$a</span>/ <span class="variable">$b</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> + <span class="variable">$b</span> = <span class="variable">$val1</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> - <span class="variable">$b</span> = <span class="variable">$val2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> * <span class="variable">$b</span> = <span class="variable">$val3</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> / <span class="variable">$b</span> = <span class="variable">$val4</span>&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于四则运算，也可以使用$[]，运算符两边也不用空格.</p>
</li>
<li><p>bash 不支持浮点运算，如果需要进行浮点运算，需要借助bc &#x2F; awk 处理</p>
</li>
</ul>
<p><strong>2) 关系运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ]</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true。</td>
<td>[ $a -ne $b ]</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ]</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ]</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ]</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ]</td>
</tr>
</tbody></table>
<p><strong>3) 逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ]</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ]</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ]</td>
</tr>
</tbody></table>
<h1 id="十二-软件安装"><a href="#十二-软件安装" class="headerlink" title="十二. 软件安装"></a>十二. 软件安装</h1><h2 id="1-JDK-安装"><a href="#1-JDK-安装" class="headerlink" title="1. JDK 安装"></a>1. JDK 安装</h2><ul>
<li><p>默认 CentOS 安装了 openJDK，首先将其卸载掉，首先查看默认安装的 openJDK</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep openjdk</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有四个openjdk</span></span><br><span class="line">java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64</span><br><span class="line">java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64</span><br><span class="line">java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64</span><br></pre></td></tr></table></figure>
</li>
<li><p>将查出来的openjdk通通卸载掉</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -e --nodeps java-1.8.0-openjdk </span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless  </span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-headless </span><br><span class="line">rpm -qa|grep openjdk</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面开始正式安装 jdk8，在官网下载 jdk 安装压缩包（以 .tar.gz 结尾）</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100910.png" alt="image-20201216222717629"></p>
</li>
<li><p>在 &#x2F;usr 目录下建一个 java 文件夹，把下载的安装包放到此文件夹中，并解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/java</span><br><span class="line"><span class="comment"># 通过ftp工具将下载的安装包放入/usr/java文件夹中</span></span><br><span class="line"><span class="built_in">cd</span> /usr/java</span><br><span class="line">tar -zxvf jdk-8u291-linux-x64.tar.gz </span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量，编辑 &#x2F;etc&#x2F;profile 文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在文件最后加入下面内容，保存退出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># JDK的环境变量</span></span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_291</span><br><span class="line">PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新配置使文件生效</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 jdk 是否安装成功</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line"><span class="comment"># 若屏幕输出以下内容，即安装成功</span></span><br><span class="line">java version <span class="string">&quot;1.8.0_291&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_291-b10)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.291-b10, mixed mode)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十三-虚拟机安装"><a href="#十三-虚拟机安装" class="headerlink" title="十三. 虚拟机安装"></a>十三. 虚拟机安装</h1><h2 id="1-安装-CentOS"><a href="#1-安装-CentOS" class="headerlink" title="1. 安装 CentOS"></a>1. 安装 CentOS</h2><ul>
<li><p>点击创建新的虚拟机</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100911.png" alt="image-20210508140557675"></p>
</li>
<li><p>选择自定义(高级)，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100913.png" alt="image-20210508144632653" style="zoom: 67%;" />
</li>
<li><p>点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100914.png" alt="image-20210508151647091" style="zoom:67%;" />
</li>
<li><p>选择稍后安装操作系统，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100915.png" alt="image-20210508151707358" style="zoom:67%;" />
</li>
<li><p>选择操作系统为 linux，版本为 CentOS 7 64 位，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100916.png" alt="image-20210508151750786" style="zoom:67%;" />
</li>
<li><p>设置虚拟机名称和位置，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100917.png" alt="image-20210508151952271" style="zoom:67%;" />
</li>
<li><p>设置虚拟机的 CPU 数量与内核数量，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100919.png" alt="image-20210508152030682" style="zoom:67%;" />
</li>
<li><p>设置虚拟机的内存大小，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100918.png" alt="image-20210508152009611" style="zoom:67%;" />
</li>
<li><p>设置虚拟机的网络连接类型，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100920.png" alt="image-20210508152040538" style="zoom:67%;" />
</li>
<li><p>后面三步，直接点击下一步</p>
</li>
<li><p>设置虚拟机的磁盘大小，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100921.png" alt="image-20210508152109019" style="zoom:67%;" />
</li>
<li><p>点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100922.png" alt="image-20210508152149592" style="zoom:67%;" />
</li>
<li><p>点击完成，等待安装</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100923.png" alt="image-20210508152136578" style="zoom:67%;" />
</li>
<li><p>设置虚拟机镜像</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100925.png" alt="image-20210508153112368" style="zoom:67%;" />
</li>
<li><p>点击开启此虚拟机</p>
</li>
<li><p>使用上下键，选择第一项 Insatll CentOS 7，然后按回车</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100924.png" alt="image-20210508152611793" style="zoom: 50%;" />
</li>
<li><p>选择语言为简体中文，然后点击继续</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100926.png" alt="image-20210508153303801" style="zoom:67%;" />
</li>
<li><p>点击软件安装</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100927.png" alt="image-20210508153349358" style="zoom:67%;" />
</li>
<li><p>选择 GNOME 桌面，然后勾选开发工具，接着点击完成</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100928.png" alt="image-20210508153506973" style="zoom:67%;" />
</li>
<li><p>点击安装位置</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100929.png" alt="image-20210508153553811" style="zoom:67%;" />
</li>
<li><p>选择我要配置分区，然后点击完成</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100930.png" alt="image-20210508153650481" style="zoom:67%;" />
</li>
<li><p>点击＋号，依次配置分区</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100932.png" alt="image-20210508153924316" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100931.png" alt="image-20210508153837224" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100933.png" alt="image-20210508154016360" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100934.png" alt="image-20210508154407703" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100935.png" alt="image-20210508154142104" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100936.png" alt="image-20210508154257662" style="zoom:67%;" />
</li>
<li><p>点击完成，然后在弹出窗口点击接受更改</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100939.png" alt="image-20210508154756623" style="zoom:67%;" />
</li>
<li><p>点击 Kdump，将其禁用</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100937.png" alt="image-20210508154612785" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100938.png" alt="image-20210508154651615" style="zoom:67%;" />
</li>
<li><p>点击网络与主机名，将网络打开</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100941.png" alt="image-20210508155240649" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100940.png" alt="image-20210508154843040" style="zoom:67%;" />
</li>
<li><p>点击开始安装</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100942.png" alt="image-20210508155258056" style="zoom:67%;" />
</li>
<li><p>点击 ROOT 密码，然后给 Root 设置一个密码，</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100944.png" alt="image-20210508155435164" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100943.png" alt="image-20210508155333256" style="zoom:67%;" />
</li>
<li><p>点击创建用户</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100945.png" alt="image-20210508155558900" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100946.png" alt="image-20210508155633032" style="zoom:67%;" />
</li>
<li><p>安装完毕后，点击重启即可</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100948.png" alt="image-20210508160721784" style="zoom:67%;" /></li>
</ul>
<h2 id="2-快速克隆-CentOS"><a href="#2-快速克隆-CentOS" class="headerlink" title="2. 快速克隆 CentOS"></a>2. 快速克隆 CentOS</h2><p>注意：被克隆的操作系统需要先关机</p>
<ul>
<li><p>选择要被克隆的系统，右键选择管理–&gt;克隆</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100947.png" alt="image-20210508155942780" style="zoom:67%;" />
</li>
<li><p>点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100949.png" alt="image-20210508160807699" style="zoom:67%;" />
</li>
<li><p>点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100950.png" alt="image-20210508160840429" style="zoom:67%;" />
</li>
<li><p>选择创建完整克隆，然后点击下一步</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100951.png" alt="image-20210508160915487" style="zoom:67%;" />
</li>
<li><p>设置要克隆虚拟机名称和位置，然后点击完成即可</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Linux/20220329100952.png" alt="image-20210508161048484" style="zoom:67%;" /></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>JavaWeb知识（包含前端基础）</title>
    <url>/2022/02/21/JavaWeb/</url>
    <content><![CDATA[<h1 id="一-JavaWeb概述"><a href="#一-JavaWeb概述" class="headerlink" title="一. JavaWeb概述"></a>一. JavaWeb概述</h1><blockquote>
<p>JavaWeb：使用 Java 语言开发基于互联网的项目</p>
</blockquote>
<span id="more"></span>

<p>软件架构：</p>
<ul>
<li><code>C/S</code>: Client&#x2F;Server 客户端&#x2F;服务器端<ul>
<li>在用户本地有一个客户端程序，在远程有一个服务器端程序</li>
<li>如：QQ，迅雷…</li>
<li>优点：用户体验好</li>
<li>缺点：开发、安装，部署，维护麻烦</li>
</ul>
</li>
<li><code>B/S</code>: Browser&#x2F;Server 浏览器&#x2F;服务器端<ul>
<li>只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序</li>
<li>优点：开发、安装，部署，维护简单</li>
<li>缺点：如果应用过大，用户的体验可能会受到影响、对硬件要求过高</li>
</ul>
</li>
</ul>
<p>B&#x2F;S 架构资源分类</p>
<ul>
<li><u>静态资源</u>（使用静态网页开发技术发布的资源。）<ul>
<li>所有用户访问，得到的结果是一样的。</li>
<li>如：文本，图片，音频、视频、HTML、CSS、JavaScript</li>
<li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源.</li>
<li>HTML：用于搭建基础网页，展示页面的内容（结构标准：结构用于对网页元素进行整理和分类）</li>
<li>CSS：用于美化页面，布局页面（表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式）</li>
<li>JavaScript：控制页面的元素，让页面有一些动态的效果（行为标准：行为是指网页模型的定义及交互的编）</li>
</ul>
</li>
</ul>
<ul>
<li><u>动态资源</u>（使用动态网页及时发布的资源。）<ul>
<li>不同用户访问，得到的结果可能不一样。</li>
<li>如：jsp&#x2F;servlet、php、asp…</li>
<li>如果用户请求的是动态资源，那么<u>服务器会执行动态资源，将其转换为静态资源，再发送给浏览器。</u></li>
</ul>
</li>
</ul>
<h1 id="二-HTML"><a href="#二-HTML" class="headerlink" title="二. HTML"></a>二. HTML</h1><h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><blockquote>
<p><u>HTML</u> 是用来描述网页的一种语言。</p>
<ul>
<li>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，超文本是指用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。标记语言是指由标签构成的语言。标记语言不是编程语言。</li>
<li>标记语言是一套<em>标记标签</em> (markup tag)</li>
<li>HTML 使用<em>标记标签</em>来描述网页</li>
</ul>
</blockquote>
<p><u>HTML 标记标签</u> 通常被称为 HTML 标签 (HTML tag)。</p>
<ul>
<li><p>HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;</p>
</li>
<li><p>HTML 标签通常是成对出现的</p>
</li>
<li><p>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em></p>
</li>
<li><p>开始和结束标签也被称为<em>开放标签</em> 和 <em>闭合标签</em></p>
</li>
<li><p>标签的相互关系分为两种：</p>
<ul>
<li><p>嵌套关系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并列关系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><u>HTML 文档</u> &#x3D; 网页</p>
<ul>
<li>HTML 文档<em>描述网页</em></li>
<li>HTML 文档<em>包含 HTML 标签</em>  和 纯文本</li>
<li>HTML 文档也被称为<em>网页</em></li>
</ul>
<p>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容，下面是一个简单的 HTML 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的网页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">DOCTYPE 声明了文档的类型；</span></span><br><span class="line"><span class="comment">&lt;html&gt; 标签是 HTML 页面的根元素，该标签的结束标志为 &lt;/html&gt;；</span></span><br><span class="line"><span class="comment">&lt;head&gt; 标签包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式；&lt;title&gt; 标签定义文档的标题；</span></span><br><span class="line"><span class="comment">&lt;body&gt; 标签定义文档的主体，即网页可见的页面内容，该标签的结束标志为 &lt;/body&gt;；</span></span><br><span class="line"><span class="comment">&lt;h1&gt; 标签作为一个标题使用，该标签的结束标志为 &lt;/h1&gt;；</span></span><br><span class="line"><span class="comment">&lt;p&gt; 标签作为一个段落显示，该标签的结束标志为 &lt;/p&gt;。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-常用标签"><a href="#2-常用标签" class="headerlink" title="2. 常用标签"></a>2. 常用标签</h2><h3 id="（1）换行"><a href="#（1）换行" class="headerlink" title="（1）换行"></a>（1）换行</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">单词缩写： break 打断 ,换行</span></span><br><span class="line"><span class="comment">在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签&lt;br/&gt;这时如果还像在word中直接敲回车键换行就不起作用了。</span></span><br><span class="line"><span class="comment">建议使用&lt;br/&gt;，而不是&lt;br&gt;，单标签应该在标签中关闭，方法就是在开始标签中添加斜杠</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）标题"><a href="#（2）标题" class="headerlink" title="（2）标题"></a>（2）标题</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">HTML提供了6个等级的标题，即&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt;  h1 最大，h6 最小</span></span><br><span class="line"><span class="comment">align 属性是对齐属性</span></span><br><span class="line"><span class="comment">	left 左对齐 ( 默认 )</span></span><br><span class="line"><span class="comment">	center 居中</span></span><br><span class="line"><span class="comment">	right 右对齐</span></span><br><span class="line"><span class="comment">浏览器会自动地在标题的前后添加空行。</span></span><br><span class="line"><span class="comment">默认情况下，HTML 会自动地在块级元素前后添加一个额外的空行，比如段落、标题元素前后。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span> = <span class="string">&quot;center&quot;</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）段落"><a href="#（3）段落" class="headerlink" title="（3）段落"></a>（3）段落</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">单词缩写： paragraph 段落 [ˈpærəgræf] </span></span><br><span class="line"><span class="comment">浏览器会自动地在段落的前后添加空行。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）水平线"><a href="#（4）水平线" class="headerlink" title="（4）水平线"></a>（4）水平线</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">单词缩写： horizontal 横线 [ˌhɔrəˈzɑntl] </span></span><br><span class="line"><span class="comment">hr 元素可用于分隔内容，使用该元素产生的水平线可以在视觉上将文档分隔成各个部分。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）文本格式化"><a href="#（5）文本格式化" class="headerlink" title="（5）文本格式化"></a>（5）文本格式化</h3><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p>
<table>
<thead>
<tr>
<th align="center"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;b&gt;</code></td>
<td align="center">粗体</td>
<td align="center"><code>&lt;sub&gt;</code></td>
<td align="center">下标</td>
</tr>
<tr>
<td align="center"><code>&lt;i&gt;</code></td>
<td align="center">斜体</td>
<td align="center"><code>&lt;sup&gt;</code></td>
<td align="center">上标</td>
</tr>
<tr>
<td align="center"><code>&lt;strong&gt;</code></td>
<td align="center">粗体</td>
<td align="center"><code>&lt;ins&gt;</code>&#x2F;<code>&lt;u&gt;</code></td>
<td align="center">下划线</td>
</tr>
<tr>
<td align="center"><code>&lt;em&gt;</code></td>
<td align="center">斜体</td>
<td align="center"><code>&lt;del&gt;</code></td>
<td align="center">删除线</td>
</tr>
<tr>
<td align="center"><code>&lt;small&gt;</code></td>
<td align="center">小号字</td>
<td align="center"><code>&lt;big&gt;</code></td>
<td align="center">大号字</td>
</tr>
</tbody></table>
<h3 id="（6）超链接"><a href="#（6）超链接" class="headerlink" title="（6）超链接"></a>（6）超链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">语法格式：&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;</span></span><br><span class="line"><span class="comment">href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接功能。 超文本引用（Hypertext Reference）的缩写。</span></span><br><span class="line"><span class="comment">target：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值，blank为在新窗口中打开方式。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--打开链接时会不会重写打开一个网页，而是在本网页跳转--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!--打开链接时会重新打开一个网页--&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>外部链接（互联网上的 url 网址）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部链接（内部之间的相互链接）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;index.html&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>空链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>空链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载链接（href中地址是一个文件或压缩包，点击会下载，图片点击后会在页面显示）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test.rar&quot;</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>网页元素链接（href中地址是文本、图像、音视频等）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.png&quot;</span>&gt;</span>点击图片去往百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>锚点链接（点击链接后会快速定位到页面中某个位置）</p>
<ul>
<li>第一步：在链接文本中的 href 属性值为”#名字”的形式，比如 &lt;a href&#x3D;”#info”&gt; 个人信息 &lt;&#x2F;a&gt;</li>
<li>第二步：找到目标位置标签，添加一个id属性&#x3D;刚才的名字，比如 &lt;h3 id&#x3D;”info”&gt; 个人信息介绍 &lt;&#x2F;h3&gt;</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#info&quot;</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span>&gt;</span>个人信息介绍<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（7）图像"><a href="#（7）图像" class="headerlink" title="（7）图像"></a>（7）图像</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">img 标签是图片标签 , 用来显示图片</span></span><br><span class="line"><span class="comment">	src 属性可以设置图片的路径（必须属性）</span></span><br><span class="line"><span class="comment">	width 属性设置图片的宽度</span></span><br><span class="line"><span class="comment">	height 属性设置图片的高度（宽度和高度若只设置一个，会等比例缩放）</span></span><br><span class="line"><span class="comment">	border 属性设置图片边框</span></span><br><span class="line"><span class="comment">	alt 属性设置当指定路径找不到图片时 , 用来代替显示的文本内容，会有一个裂开的图片</span></span><br><span class="line"><span class="comment">	title 鼠标放到图像上，提示的文本</span></span><br><span class="line"><span class="comment">在 web 中路径分为相对路径和绝对路径两种</span></span><br><span class="line"><span class="comment">相对路径 :</span></span><br><span class="line"><span class="comment">	. 表示当前文件所在的目录</span></span><br><span class="line"><span class="comment">	.. 表示当前文件所在的上一级目录</span></span><br><span class="line"><span class="comment">	文件名 表示当前文件所在目录的文件 , 相当于 ./ 文件名 ./ 可以省略</span></span><br><span class="line"><span class="comment">绝对路径 :</span></span><br><span class="line"><span class="comment">	正确格式是 : http://ip:port/ 工程名 / 资源路径</span></span><br><span class="line"><span class="comment">	错误格式是 : 盘符 :/ 目录 / 文件名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（8）列表"><a href="#（8）列表" class="headerlink" title="（8）列表"></a>（8）列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">无序列表 ul （unorderd list）  li(list item)</span></span><br><span class="line"><span class="comment">无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</span></span><br><span class="line"><span class="comment">	&lt;ul&gt;</span></span><br><span class="line"><span class="comment"> 	 &lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> 	 &lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">	  &lt;li&gt;列表项3&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> 	 ......</span></span><br><span class="line"><span class="comment">	&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment"> 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。</span></span><br><span class="line"><span class="comment"> 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。</span></span><br><span class="line"><span class="comment"> 3. 无序列表会带有自己样式属性，但一般不用使用，通过css更好（可以使用list-style-type:none;/list-styl:none样式去除无序列表前的黑点）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有序列表 ol （orderd list）</span></span><br><span class="line"><span class="comment">有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</span></span><br><span class="line"><span class="comment">    &lt;ol&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      &lt;li&gt;列表项3&lt;/li&gt;</span></span><br><span class="line"><span class="comment">      ......</span></span><br><span class="line"><span class="comment">    &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有序列表 unorderd list--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--无序列表 orderd list--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三列<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--自定义列表 description list--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（9）表格"><a href="#（9）表格" class="headerlink" title="（9）表格"></a>（9）表格</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">创建表格的基本语法格式如下：</span></span><br><span class="line"><span class="comment">    &lt;table&gt;</span></span><br><span class="line"><span class="comment">      &lt;tr&gt;</span></span><br><span class="line"><span class="comment">        &lt;td&gt;单元格内的文字&lt;/td&gt;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">      &lt;/tr&gt;</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">    &lt;/table&gt;</span></span><br><span class="line"><span class="comment">table 标签是表格标签</span></span><br><span class="line"><span class="comment">	border 设置表格标签</span></span><br><span class="line"><span class="comment">	width 设置表格宽度</span></span><br><span class="line"><span class="comment">	height 设置表格高度</span></span><br><span class="line"><span class="comment">	align 设置表格相对于页面的对齐方式（left、center、right）</span></span><br><span class="line"><span class="comment">	cellspacing 设置单元格之间的间距（默认为2像素）,如果指定为0，则单元格的线会合为一条</span></span><br><span class="line"><span class="comment">	cellpadding 设置单元格与文字内容之间的间距</span></span><br><span class="line"><span class="comment">tr 是行标签，在 table中包含几对 tr，就有几行表格。</span></span><br><span class="line"><span class="comment">th 是表头标签（文字加粗且居中）</span></span><br><span class="line"><span class="comment">td 是单元格标签，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">合并单元格</span></span><br><span class="line"><span class="comment">跨行合并：rowspan 跨列合并：colspan</span></span><br><span class="line"><span class="comment">注意：将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。</span></span><br><span class="line"><span class="comment">&lt;td colspan=&quot;2&quot;&gt;内容&lt;td&gt;：表示内容跨两列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;1&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>这是第一行第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>这是第一行第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>这是第二行第一列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>这是第二行第二列<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（10）表单"><a href="#（10）表单" class="headerlink" title="（10）表单"></a>（10）表单</h3><table>
<thead>
<tr>
<th align="center"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;form&gt;</code></td>
<td align="center">供用户输入的表单</td>
</tr>
<tr>
<td align="center"><code>&lt;input&gt;</code></td>
<td align="center">输入域</td>
</tr>
<tr>
<td align="center"><code>&lt;select&gt;</code></td>
<td align="center">下拉选项列表</td>
</tr>
<tr>
<td align="center"><code>&lt;option&gt;</code></td>
<td align="center">下拉列表中的选项</td>
</tr>
<tr>
<td align="center"><code>&lt;textarea&gt;</code></td>
<td align="center">文本域（一个多行的输入控件）</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">HTML表单用于收集不同类型的用户输入，然后把这些信息发送给服务器.为了使得表单更加好看，可以配合着表格使用.</span></span><br><span class="line"><span class="comment">在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</span></span><br><span class="line"><span class="comment">	① 表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</span></span><br><span class="line"><span class="comment">	② 提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</span></span><br><span class="line"><span class="comment">	③ 表单域：它相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">form 标签就是表单</span></span><br><span class="line"><span class="comment">★输入标签&lt;input&gt;</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;text&quot;&gt; 是文件输入框(type的默认值) 可以使用value设置默认显示内容，也可以使用placeholder属性设置默认显示内容，此时内容是灰颜色的（一般用于设置提示信息），自己输入内容后就消失了，而使用value设置的显示内容需要自己手动删除。</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;password&quot;&gt; 是密码输入框（密码字段字符不会明文显示，而是以圆点替代），可以使用value设置默认显示内容</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;radio&quot;&gt; 是单选框，要想实现单选，name属性必须都一样，加上属性checked=&quot;checked&quot;表示默认选中，使用value属性可以使得请求参数中有值，比如gender=male，如果没有使用value，会显示gender=on</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;checkbox&quot;&gt;是复选框， 使用属性checked=&quot;checked&quot;表示默认选中，使用value属性效果同radio，复选框要有相同的name值。</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;reset&quot;&gt; 是重置按钮，可以使用value属性修改按钮上显示的文本</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;submit&quot;&gt; 是提交按钮，可以使用value属性修改按钮上显示的文本</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 是图片提交按钮，可以使用src指定图片的路径，点击图片，表单也会被提交。</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;button&quot;&gt; 是按钮，可与使用value属性修改按钮上显示的文本</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;file&quot;&gt; 是文件上传域，用户可以上传文件,其属性accept定义了文件 input 应该接受的文件类型，这个字符串是一个以逗号为分隔的唯一文件类型说明符列表，比如accept=&quot;image/jpg,image/jpeg,image/png,image/PNG&quot;，详细信息见https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input/file</span></span><br><span class="line"><span class="comment">	&lt;input type=&quot;hidden&quot;&gt; 是隐藏域 当我们要发送某些信息，而这些信息，不需要用户参与，就可以使用隐藏域（提交的时候同时发送给服务器）</span></span><br><span class="line"><span class="comment">★下拉菜单&lt;select&gt;</span></span><br><span class="line"><span class="comment">使用select控件定义下拉菜单的基本语法格式如下</span></span><br><span class="line"><span class="comment">    &lt;select&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;选项1&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;选项2&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      &lt;option&gt;选项3&lt;/option&gt;</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">    &lt;/select&gt;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	1、select&lt;/select中至少应包含一对option&gt;&lt;/option。</span></span><br><span class="line"><span class="comment">	2、在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">★文本域&lt;textarea&gt;</span></span><br><span class="line"><span class="comment">	如果需要输入大量的信息，就需要用到textarea标签。通过textarea控件可以创建多行文本输入框，格式如下：</span></span><br><span class="line"><span class="comment">    &lt;textarea cols=&quot;每行中的字符数&quot; rows=&quot;显示的行数&quot;&gt;</span></span><br><span class="line"><span class="comment">      文本内容</span></span><br><span class="line"><span class="comment">    &lt;/textarea&gt;  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">★表单域</span></span><br><span class="line"><span class="comment">在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下：</span></span><br><span class="line"><span class="comment">    &lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;</span></span><br><span class="line"><span class="comment">      各种表单控件</span></span><br><span class="line"><span class="comment">    &lt;/form&gt;</span></span><br><span class="line"><span class="comment">        action属性用于指定接收并处理表单数据的服务器程序的url地址。</span></span><br><span class="line"><span class="comment">        method用于设置表单数据的提交方式，其取值为GET(默认值)或 POST。</span></span><br><span class="line"><span class="comment">        name用于指定表单的名称，以区分同一个页面中的多个表单。</span></span><br><span class="line"><span class="comment">	表单提交的时候，数据没有发送给服务器的三种情况：</span></span><br><span class="line"><span class="comment">		1、表单项没有 name 属性值（也就是说，表单项（比如用户名、密码）中必须制定其name属性才能提交给服务器）</span></span><br><span class="line"><span class="comment">		2、单选、复选（下拉列表中的 option 标签）都需要添加 value 属性，以便发送给服务器</span></span><br><span class="line"><span class="comment">		3、表单项不在提交的 form 标签中</span></span><br><span class="line"><span class="comment">    GET 请求的特点是：</span></span><br><span class="line"><span class="comment">        1、浏览器地址栏中的地址是：action 属性[+?+请求参数] 请求参数的格式是：name=value&amp;name=value</span></span><br><span class="line"><span class="comment">        2、不安全</span></span><br><span class="line"><span class="comment">        3、它有数据长度的限制</span></span><br><span class="line"><span class="comment">    POST 请求的特点是：</span></span><br><span class="line"><span class="comment">        1、浏览器地址栏中只有 action 属性值</span></span><br><span class="line"><span class="comment">        2、相对于 GET 请求更安全</span></span><br><span class="line"><span class="comment">        3、理论上没有数据长度的限制</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">name</span>=<span class="string">&quot;我的表单&quot;</span>&gt;</span></span><br><span class="line">    用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    国籍：<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> &gt;</span>--中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>--日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot; gender&quot;</span>&gt;</span>男</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot; gender&quot;</span>&gt;</span>女 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    兴趣爱好<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>java</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>c++</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>python</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>其他 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    自我介绍<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;label&gt; 标签为 input 元素定义标注（标记）。</span></span><br><span class="line"><span class="comment">label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</span></span><br><span class="line"><span class="comment">&lt;label&gt; 标签的 for 属性应当与相关元素的 id 属性相同。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--当点击用户名这三个字时，会自动将光标转到input输入框中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153442.png"></p>
<h3 id="（11）div-span-标签"><a href="#（11）div-span-标签" class="headerlink" title="（11）div span 标签"></a>（11）div span 标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">div就是 ,可以把文档分割为独立的、不同的部分。其默认独占一行</span></span><br><span class="line"><span class="comment">div:（division 的缩写）每一个div占满一整行。块级标签。div占用的位置是一行</span></span><br><span class="line"><span class="comment">span：文本信息在一行展示，行内标签 内联标签。span占用的是内容有多宽就占用多宽的空间距离</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（12）iframe-框架"><a href="#（12）iframe-框架" class="headerlink" title="（12）iframe 框架"></a>（12）iframe 框架</h3><table>
<thead>
<tr>
<th align="left"><strong>属性</strong></th>
<th><strong>值</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">src</td>
<td><em>URL</em></td>
<td align="left">规定在 iframe 中显示的文档的 URL。</td>
</tr>
<tr>
<td align="left">name</td>
<td><em>frame_name</em></td>
<td align="left">规定 iframe 的名称。</td>
</tr>
<tr>
<td align="left">height</td>
<td><em>pixels&#x2F;%</em></td>
<td align="left">规定 iframe 的高度。</td>
</tr>
<tr>
<td align="left">width</td>
<td><em>pixels&#x2F;%</em></td>
<td align="left">定义 iframe 的宽度。</td>
</tr>
<tr>
<td align="left">align</td>
<td>left&#x2F;right&#x2F;top&#x2F;middle&#x2F;bottom</td>
<td align="left">不赞成使用。请使用样式代替。规定如何根据周围的元素来对齐此框架。</td>
</tr>
<tr>
<td align="left">frameborder</td>
<td>10</td>
<td align="left">规定是否显示框架周围的边框。不赞成使用，请使用 CSS 属性 border代替。</td>
</tr>
<tr>
<td align="left">longdesc</td>
<td><em>URL</em></td>
<td align="left">规定一个页面，该页面包含了有关 iframe 的较长描述。</td>
</tr>
<tr>
<td align="left">marginheight</td>
<td><em>pixels</em></td>
<td align="left">定义 iframe 的顶部和底部的边距。</td>
</tr>
<tr>
<td align="left">marginwidth</td>
<td><em>pixels</em></td>
<td align="left">定义 iframe 的左侧和右侧的边距。</td>
</tr>
<tr>
<td align="left">sandbox</td>
<td>“”allow-formsallow-same-originallow-scriptsallow-top-navigation</td>
<td align="left">启用一系列对 <iframe> 中内容的额外限制。</td>
</tr>
<tr>
<td align="left">scrolling</td>
<td>yes&#x2F;no&#x2F;auto</td>
<td align="left">规定是否在 iframe 中显示滚动条。</td>
</tr>
<tr>
<td align="left">seamless</td>
<td>seamless</td>
<td align="left">规定 <iframe> 看上去像是包含文档的一部分。</td>
</tr>
<tr>
<td align="left">srcdoc</td>
<td><em>HTML_code</em></td>
<td align="left">规定在 <iframe> 中显示的页面的 HTML 内容。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">iframe 标签它可以在一个html页面上,打开一个小窗口,去加载另一个单独的页面，即将另一个HTML页面嵌入到当前页面中。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在页面创建一个小窗口，宽高均为400，名字为iframe框架，默认为百度--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe框架&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.bilibili.com/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe框架&quot;</span>&gt;</span>跳转到b站页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!--可以将哔哩哔哩页面在这个小窗口内显示--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-HTML5常用新增标签"><a href="#3-HTML5常用新增标签" class="headerlink" title="3. HTML5常用新增标签"></a>3. HTML5常用新增标签</h2><p>新特性一般都存在兼容性问题，基本是IE9+以上版本的浏览器才支持，如果不考虑兼容性问题，才可以大量使用这些新特性。</p>
<h3 id="（1）语义化标签"><a href="#（1）语义化标签" class="headerlink" title="（1）语义化标签"></a>（1）语义化标签</h3><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153443.png" alt="image-20210830221834836" style="zoom:50%;" />

<ul>
<li><p>&lt;header&gt; ：头部标签</p>
</li>
<li><p>&lt;nav&gt; ：导航标签</p>
</li>
<li><p>&lt;article&gt; ：内容标签</p>
</li>
<li><p>&lt;section&gt; ：定义文档某个区域</p>
</li>
<li><p>&lt;aside&gt;：侧边栏标签</p>
</li>
<li><p>&lt;footer&gt; ：尾部标签</p>
</li>
</ul>
<h3 id="（2）视频"><a href="#（2）视频" class="headerlink" title="（2）视频"></a>（2）视频</h3><p>使用 video 标签可以很方便的在页面中嵌入视频，而不再去使用 flash 和其他浏览器插件。</p>
<p>当前 video 元素仅支持三种视频格式：MP4、WebM、Ogg（尽量使用 MP4 格式，其他两个格式在某些浏览器中不兼容） </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;文件地址&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>属性</strong></th>
<th align="left"><strong>值</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">src</td>
<td align="left"><em>url</em></td>
<td align="left">要播放的视频的 URL。</td>
</tr>
<tr>
<td align="left">autoplay</td>
<td align="left">autoplay</td>
<td align="left">如果出现该属性，则视频在就绪后马上播放【谷歌浏览器需要添加muted来解决自动播放问题（静音播放）】。</td>
</tr>
<tr>
<td align="left">controls</td>
<td align="left">controls</td>
<td align="left">如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td align="left">height</td>
<td align="left"><em>pixels</em></td>
<td align="left">设置视频播放器的高度。</td>
</tr>
<tr>
<td align="left">width</td>
<td align="left"><em>pixels</em></td>
<td align="left">设置视频播放器的宽度。</td>
</tr>
<tr>
<td align="left">loop</td>
<td align="left">loop</td>
<td align="left">如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td align="left">muted</td>
<td align="left">muted</td>
<td align="left">规定视频的音频输出应该被静音。</td>
</tr>
<tr>
<td align="left">poster</td>
<td align="left"><em>URL</em></td>
<td align="left">规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</td>
</tr>
<tr>
<td align="left">preload</td>
<td align="left">preload</td>
<td align="left">如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
</tbody></table>
<h3 id="（3）音频"><a href="#（3）音频" class="headerlink" title="（3）音频"></a>（3）音频</h3><p>当前 audio 元素仅支持三种音频格式：MP3、Wav、Ogg（尽量使用MP3格式，其他两个格式在某些浏览器中不兼容）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">audio</span> <span class="attribute">src</span>=&quot;文件地址&quot;&gt;&lt;/<span class="selector-tag">audio</span>&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放【谷歌浏览器不能自动播放问题，使用muted不能解决此问题，以后使用JS解决 】。</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td>muted</td>
<td>muted</td>
<td>规定视频输出应该被静音。</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td><em>url</em></td>
<td>要播放的音频的 URL。</td>
</tr>
</tbody></table>
<h3 id="（4）新增-input-类型"><a href="#（4）新增-input-类型" class="headerlink" title="（4）新增 input 类型"></a>（4）新增 input 类型</h3><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>type&#x3D;”email”</td>
<td>限制用户输入必须为Email类型</td>
</tr>
<tr>
<td>type&#x3D;”url”</td>
<td>限制用户输入必须为URL类型</td>
</tr>
<tr>
<td>type&#x3D;”date”</td>
<td>限制用户输入必须为日期类型</td>
</tr>
<tr>
<td>type&#x3D;”time”</td>
<td>限制用户输入必须为时间类型</td>
</tr>
<tr>
<td>type&#x3D;”month”</td>
<td>限制用户输入必须为月类型</td>
</tr>
<tr>
<td>type&#x3D;”week”</td>
<td>限制用户输入必须为周类型</td>
</tr>
<tr>
<td>type&#x3D;”number”</td>
<td>限制用户输入必须为数字类型</td>
</tr>
<tr>
<td>type&#x3D;”tel”</td>
<td>手机号码</td>
</tr>
<tr>
<td>type&#x3D;”search”</td>
<td>搜索框</td>
</tr>
<tr>
<td>type&#x3D;”color”</td>
<td>生成一个颜色选择表单</td>
</tr>
</tbody></table>
<p>注意：必须添加form表单域，当点击提交按钮时，就可以验证表单。</p>
<h3 id="（5）新增表单属性"><a href="#（5）新增表单属性" class="headerlink" title="（5）新增表单属性"></a>（5）新增表单属性</h3> <img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153444.png" alt="image-20210830225354316" style="zoom: 50%;" />

<h1 id="三-CSS"><a href="#三-CSS" class="headerlink" title="三. CSS"></a>三. CSS</h1><h2 id="1-名词解释-1"><a href="#1-名词解释-1" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><blockquote>
<p><u>CSS</u> 是用于设置网页的样式及布局的一种 样式表 语言</p>
<ul>
<li>CSS 指层叠样式表 (Cascading Style Sheets)</li>
<li>样式定义<em>如何显示</em> HTML 元素</li>
<li>样式通常存储在<em>样式表</em> 中</li>
<li>把样式添加到 HTML 中，是为了<em>解决内容与表现分离的问题</em></li>
<li>外部样式表通常存储在 <em>CSS 文件</em> 中</li>
<li>多个样式定义可<em>层叠</em>为一个，即多个样式可以作用在同一个html的元素上，同时生效。</li>
</ul>
</blockquote>
<p>好处：</p>
<ul>
<li>功能更为强大</li>
<li>将内容展示和样式控制分离<ul>
<li>降低耦合度。解耦，使得让分工协作更容易</li>
<li>提高开发效率，多个样式可以应用一个内容，多个内容也可以应用一个样式。</li>
</ul>
</li>
</ul>
<h2 id="2-CSS-样式规则"><a href="#2-CSS-样式规则" class="headerlink" title="2. CSS 样式规则"></a>2. CSS 样式规则</h2><p>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明:</p>
<p>​    <strong>选择器 {<br>​        属性名1:属性值1;<br>​        属性名2:属性值2;<br>​        …<br>​    }</strong></p>
<ul>
<li><u>选择器</u>：用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。</li>
<li><u>声明</u>：一个单独的规则，用来指定添加样式元素的属性，属性和属性值以“键值对”的形式出现，之间用英文“:”连接。多个“键值对”之间用英文“;”进行区分。</li>
<li><u>属性</u>：对指定的对象设置的样式属性，例如字体大小、文本颜色等。</li>
<li><u>属性的值</u>：对某个属性赋予特定的值，比如颜色设为红色。</li>
</ul>
<h2 id="3-HTML-引入-CSS-样式表"><a href="#3-HTML-引入-CSS-样式表" class="headerlink" title="3. HTML 引入 CSS 样式表"></a>3. HTML 引入 CSS 样式表</h2><h3 id="（1）方式一：内联样式表"><a href="#（1）方式一：内联样式表" class="headerlink" title="（1）方式一：内联样式表"></a>（1）方式一：内联样式表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">内联样式表是通过标签的style属性来设置元素的样式，其基本语法格式如下：</span></span><br><span class="line"><span class="comment">	&lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&gt; 内容 &lt;/标签名&gt;</span></span><br><span class="line"><span class="comment">语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; width: 100px; height: 20px;border: 1px solid black;&quot;</span>&gt;</span>一条语句<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）方式二：内部样式表"><a href="#（2）方式二：内部样式表" class="headerlink" title="（2）方式二：内部样式表"></a>（2）方式二：内部样式表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">内部样式表是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下：</span></span><br><span class="line"><span class="comment">    &lt;head&gt;</span></span><br><span class="line"><span class="comment">    	&lt;style type=&quot;text/CSS&quot;&gt;</span></span><br><span class="line"><span class="comment">    		选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;</span></span><br><span class="line"><span class="comment">   	    &lt;/style&gt;</span></span><br><span class="line"><span class="comment">    &lt;/head&gt;</span></span><br><span class="line"><span class="comment">语法中，style标签一般位于head标签中title标签之后，也可以把它放在HTML文档的任何地方。</span></span><br><span class="line"><span class="comment">type=&quot;text/CSS&quot; 在html5中可以省略， 写上也比较符合规范， 即这个地方可以写也可以省略。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）方式三：外部样式表"><a href="#（3）方式三：外部样式表" class="headerlink" title="（3）方式三：外部样式表"></a>（3）方式三：外部样式表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    </span></span><br><span class="line"><span class="comment">外部样式表是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下：</span></span><br><span class="line"><span class="comment">    &lt;head&gt;</span></span><br><span class="line"><span class="comment">        &lt;link href=&quot;CSS文件的路径&quot;  rel=&quot;stylesheet&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;/head&gt;</span></span><br><span class="line"><span class="comment">注意： link 是个单标签哦!!!</span></span><br><span class="line"><span class="comment">该语法中，link标签需要放在的三个属性head头部标签中，并且必须指定link标签，具体如下：</span></span><br><span class="line"><span class="comment">href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span></span><br><span class="line"><span class="comment">type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。</span></span><br><span class="line"><span class="comment">rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;test.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">test.css文件中内容为：</span><br><span class="line">div &#123;</span><br><span class="line">	color: red;</span><br><span class="line">	width: 100px;</span><br><span class="line">	height: 20px;</span><br><span class="line">	border: 1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>优点</strong></th>
<th align="center"><strong>缺点</strong></th>
<th align="center"><strong>使用情况</strong></th>
<th align="center"><strong>控制范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">内联样式表</td>
<td align="center">书写简单</td>
<td align="center">当标签和样式较多时，代码量庞大。</td>
<td align="center">较少</td>
<td align="center">控制一个标签（小）</td>
</tr>
<tr>
<td align="center">内部样式表</td>
<td align="center">部分实现结构与样式相分离</td>
<td align="center">不能在多个页面中复用 css 代码。</td>
<td align="center">较多</td>
<td align="center">控制一个页面（中）</td>
</tr>
<tr>
<td align="center">外部样式表</td>
<td align="center">完全实现结构与样式相分离</td>
<td align="center">需要引入</td>
<td align="center">最多</td>
<td align="center">控制整个站点（大）</td>
</tr>
</tbody></table>
<h2 id="4-元素显示模式"><a href="#4-元素显示模式" class="headerlink" title="4. 元素显示模式"></a>4. 元素显示模式</h2><p>HTML 元素一般分为块元素和行内元素两种类型</p>
<h3 id="（1）块元素"><a href="#（1）块元素" class="headerlink" title="（1）块元素"></a>（1）块元素</h3><blockquote>
<p>常见的块元素<h1><p><div><ul><ol><li></p>
</blockquote>
<p>特点：</p>
<ul>
<li>比较霸道，自己独占一行</li>
<li>高度、宽度、外边距以及内边距都可以控制</li>
<li>宽度默认是容器（父级宽度）的100%</li>
<li>是一个容器及盒子，里面可以放行内或者块级元素</li>
</ul>
<p>注意：文字类的元素内不能使用块级元素，比如<p>,<h1>–<h6></p>
<h3 id="（2）行内元素"><a href="#（2）行内元素" class="headerlink" title="（2）行内元素"></a>（2）行内元素</h3><blockquote>
<p>常见的行内元素有<a> <strong> <span>，有的地方也将行内元素称为内联元素。</p>
</blockquote>
<p>特点：</p>
<ul>
<li>相邻行内元素在一行上，一行可以显示多个</li>
<li>宽、高直接设置是无效的</li>
<li>默认宽度就是它本身内容的宽度</li>
<li>行内元素只能容纳文本或其它行内元素</li>
</ul>
<p>注意：链接里面不能再放链接。特殊情况链接<a>里面可以放块级元素，但是给<a>转换一下块级模式最安全</p>
<h3 id="（3）行内块元素"><a href="#（3）行内块元素" class="headerlink" title="（3）行内块元素"></a>（3）行内块元素</h3><blockquote>
<p>在行内元素中有几个特殊的标签，<img><input><td>，它们同时具有块元素和行内元素的特点。有些资料称它们为行内块元素。</p>
</blockquote>
<p>特点</p>
<ul>
<li>和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）</li>
<li>默认宽度是它本身内容的宽度（行内元素特定）</li>
<li>高度、行高、外边距以及内边距都可以控制（块级元素特点）</li>
</ul>
<h3 id="（4）元素显示模式转换"><a href="#（4）元素显示模式转换" class="headerlink" title="（4）元素显示模式转换"></a>（4）元素显示模式转换</h3><p>一个模式的元素需要另外一种模式的特点</p>
<ul>
<li><p>转换为块级元素</p>
<p><code>display:block</code></p>
</li>
<li><p>转换为行内元素</p>
<p><code>display:inline</code></p>
</li>
<li><p>转换为行内块元素　</p>
<p><code>display:inline-block</code></p>
</li>
</ul>
<h2 id="5-属性"><a href="#5-属性" class="headerlink" title="5. 属性"></a>5. 属性</h2><p>CSS属性书写顺序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153445.png" alt="image-20210825224927721"></p>
<h3 id="（1）文本"><a href="#（1）文本" class="headerlink" title="（1）文本"></a>（1）文本</h3><ul>
<li><p><u>font-size</u>：字体大小，一般使用像素px为单位（谷歌浏览器默认的文字大小为16px）</p>
</li>
<li><p><u>font-family</u>：字体类型。常用的字体有宋体、微软雅黑(Microsoft YaHei)等，尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</p>
</li>
<li><p><u>font-weight</u>：字体粗细（normal&#x2F;bold&#x2F;bolder&#x2F;lighter&#x2F;100&#x2F;200&#x2F;…&#x2F;900）,normal相当于400，bold相当于700</p>
</li>
<li><p><u>text-align</u>：对齐方式（left（默认），right，center）</p>
</li>
<li><p><u>text-decoration</u> : 文本修饰（none（默认） ||  underline（下划线） || blink（闪烁） || overline（上划线） || line-through（删除线）），此属性可用于去掉超链接中的下划线。</p>
</li>
<li><p><u>text-indent</u>：用来指定文本的首行缩进，常用于段落的首行缩进，比如text-indent: 10px;可以使用单位em，表示一个字的距离，text-index: 2em;</p>
</li>
<li><p><u>line-height</u>：行高，用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。一般使用像素px为单位。</p>
</li>
<li><p>text-shadow：文字阴影（CSS3新加），语法：text-shadow: h-shadow v-shadow blur color;</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153447.png" alt="image-20210816220306501" style="zoom:50%;" />

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>文本属性<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div01</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div02</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-family</span>: <span class="string">&quot;楷体&quot;</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div03</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div04</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#div05</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: underline;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 取消a连接的下划线和颜色 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div01&quot;</span>&gt;</span>设置文字大小<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div02&quot;</span>&gt;</span>设置文字类型<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div03&quot;</span>&gt;</span>设置文字粗细<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div04&quot;</span>&gt;</span>设置文字对齐方式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div05&quot;</span>&gt;</span>设置文字装饰（比如下划线）<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>取消a连接下划线和颜色<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）边框"><a href="#（2）边框" class="headerlink" title="（2）边框"></a>（2）边框</h3><ul>
<li><u>border</u>：设置边框，复合属性【下面三个属性复合而成，简便写法】</li>
<li><u>border-width</u>：边框的宽度</li>
<li><u>border-color</u>：边框颜色</li>
<li><u>border-style</u>：边框类型<ul>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线  </li>
<li>dotted：边框为点线</li>
<li>double：边框为双实线</li>
</ul>
</li>
<li><u>border-radius: length</u>：圆角边框（CSS3新加）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--边框的简写（一条红色的、宽度为1px的实线框）--&gt;</span></span><br><span class="line">border-width:1px;</span><br><span class="line">border-color:red;</span><br><span class="line">border-style:solid;</span><br><span class="line"><span class="comment">&lt;!--等价于--&gt;</span></span><br><span class="line">border:1px red solid;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--表格的细线边框：以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 table&#123; border-collapse:collapse; &#125; collapse 单词是合并的意思，表示相邻的边框会合并到一起。--&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：也可以单独修改边框某一特定边的属性，只需要将border改写border-top | border-bottom | border-left | border-right即可。</p>
<h3 id="（3）背景"><a href="#（3）背景" class="headerlink" title="（3）背景"></a>（3）背景</h3><ul>
<li><u>background-image</u> ：背景图片（ none | url (url)）给某元素设置背景图像时，元素要有一定的宽度和高度，图片才会显示出来。举例<code>background-image: url(images/text.png)</code>，若背景图片小于所设置的高度和宽度，默认 会进行背景平铺，如果想要修改背景平铺，可以使用background-repeat属性（repeat | no-repeat | repeat-x | repeat-y）</li>
<li><u>background-color</u> ：背景颜色（默认为transparent透明） </li>
<li><u>background-position</u>：背景位置属性用于设置背景图像的位置，这个属性只能应用于块级元素和替换元素。其中替换元素包括<code>img</code>、<code>input</code>、<code>textarea</code>、<code>select</code>和<code>object</code>。position 后面是x坐标和y坐标。可以使用方位名词（top|center|bottom|left|right）或者精确单位（百分比(比如5%) | 数字+单位(比如20px)）。最常用的为background-position：center center；</li>
<li><u>background-attachment</u>：背景固定（附着），默认是scroll，背景图片随对象内容滚动，另外一个取值是fixed，表示背景图像固定。</li>
<li>背景色透明：background: rgba(0,0,0,0.3),前三个是RGB值，最后一个是不透明度。</li>
</ul>
<h3 id="（4）盒子模型：控制布局"><a href="#（4）盒子模型：控制布局" class="headerlink" title="（4）盒子模型：控制布局"></a>（4）盒子模型：控制布局</h3><blockquote>
<p>所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容（content）、边框（border）、内边距（padding）、和外边距（margin）组成。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153446.png" alt="image-20210824194453707" style="zoom:50%;" />

<ul>
<li><p><u><code>content</code></u>：内容，盒子的内容，显示文本和图像。使用宽度属性width和高度属性height可以对盒子的大小进行控制。</p>
<ul>
<li><u>width</u>：宽度</li>
<li><u>height</u>：高度</li>
<li>注意：当您指定一个 CSS 元素的宽度和高度属性时，你只是设置内容区域的宽度和高度。要知道完整大小的元素，你还必须添加内边距，边框和边距。</li>
</ul>
</li>
<li><p><u><code>border</code></u>：边框，围绕在内边距和内容外的边框。</p>
</li>
<li><p><u><code>padding</code></u>：内边距 ， 是指边框与内容之间的距离。四个边距也可以单独设置，padding-top | padding-bottom | padding-left | padding-right。如果盒子设置了width和height，使用padding会时盒子变大，但如果未指定width&#x2F;height，盒子便不会撑大。</p>
<ul>
<li>使用padding: 5px， 表示所有边距都为5px</li>
<li>使用padding: 2px 4px，表示上下边距2px，左右边距4px</li>
<li>使用padding: 1px 2px 3px 4px，表示上边距1px，右边距2px，下边距3px，左边距4px（顺时针）</li>
</ul>
</li>
<li><p><u><code>margin</code></u>：外边距， 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。盒子与盒子之间距离通常用这个设置。</p>
<p>外边距设置块级盒子水平居中，需要以下两步： </p>
<ul>
<li>盒子必须指定宽度（width）</li>
<li>盒子左右外边距设置为auto，以下三种方式均可以：<ul>
<li>margin-left: auto; margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;  &#x2F;  margin: 0px auto;</li>
</ul>
</li>
</ul>
<p>以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加text-align: center即可。</p>
<p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并，主要有两种情况：</p>
<ul>
<li><p>相邻块元素垂直外边距的合并 </p>
<p>当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和。而是取两个值中的较大者，这种现象被称为相邻块元素垂直外边距的合并。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153448.png" alt="image-20210822205237987" style="zoom:50%;" />
</li>
<li><p>嵌套块元素垂直外边距的塌陷</p>
<p>对于两个嵌套关系(父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153450.png" alt="image-20210824204452926" style="zoom:50%;" />

<p>解决方案：</p>
<ul>
<li>可以为父元素定义上边框</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow: hidden</li>
</ul>
</li>
</ul>
</li>
<li><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;  <span class="comment">/* 清除内边距 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;	<span class="comment">/* 清除外边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>box-shadow</u>：盒子阴影（CSS3新加）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: h-shadow v-shadow blur spread color inset</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必需。水平阴影的位置。允许负值。</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必需。垂直阴影的位置。允许负值。</td>
</tr>
<tr>
<td>blur</td>
<td>可选。模糊距离。</td>
</tr>
<tr>
<td>spread</td>
<td>可选。阴影的尺寸。</td>
</tr>
<tr>
<td>color</td>
<td>可选。阴影的颜色。</td>
</tr>
<tr>
<td>inset</td>
<td>可选。可将外部阴影(ourset)改为内部阴影。</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>默认的是外阴影(outset)，但是不可以写这个单词，否则导致阴影无效。</li>
<li>盒子阴影不占用空间，不会影响其他盒子排列。</li>
</ul>
</li>
</ul>
<h3 id="（5）浮动"><a href="#（5）浮动" class="headerlink" title="（5）浮动"></a>（5）浮动</h3><blockquote>
<p>网页布局的本质——用CSS来摆放盒子。把盒子摆放到相应位置；CSS提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)∶</p>
<ul>
<li>普通流（标准流)</li>
<li>浮动</li>
<li>定位</li>
</ul>
<p>有很多的布局效果，标准流（标签按照默认方式排列）没有办法完成，此时就可以利用浮动完成布局。因为浮动可以改变元素标签默认的排列方式。</p>
<p>浮动最典型的应用:可以让多个块级元素一行内排列显示。</p>
<p>网页布局第一准则︰多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</p>
<p>网页布局第二准则：先设置盒子大小,之后设置盒子的位置.</p>
</blockquote>
<p><u>语法</u>：<u>float</u> : none | left |  right  </p>
<ul>
<li>none : 默认值。元素不浮动</li>
<li>left :元素向左浮动。</li>
<li>right :元素向右浮动。</li>
</ul>
<p><u>浮动特性</u>：</p>
<ul>
<li><p>浮动元素会脱离标准流(脱标) </p>
<ul>
<li>脱离标准普通流的控制(浮）移动到指定位置(动)，(俗称脱标)</li>
<li>浮动的盒子不再保留原先的位置</li>
<li>貌似似乎好像是置于顶层，加了个图层的感觉…</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153449.png" alt="image-20210822205450985" style="zoom:50%;" />
</li>
<li><p>浮动的元素会一行内显示并且元素顶部对齐</p>
<ul>
<li>如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且页端对齐排列。</li>
</ul>
</li>
<li><p>浮动的元素会具有行内块元素的特性</p>
<ul>
<li>任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。</li>
</ul>
</li>
</ul>
<p><u>注意</u>：为了约束浮动元素位置,我们网页布局一般采取的策略是：先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置.符合网页布局第一准侧.</p>
<p><u>清除浮动</u>：</p>
<ul>
<li><p>清除浮动原因：由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子（由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响）。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153451.png" alt="image-20210825221719202" style="zoom:50%;" />
</li>
<li><p>清除浮动本质：清除浮动元素脱离标准流造成的影响。如果父盒子本身有高度，则不需要清除浮动。清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>: 属性值;&#125;</span><br><span class="line">属性值可取为：</span><br><span class="line">	<span class="attribute">left</span>,即不允许左侧有浮动元素（清除左侧浮动的影响）</span><br><span class="line">	<span class="attribute">right</span>,即不允许右侧有浮动元素（清除右侧浮动的影响）</span><br><span class="line">	both,即不允许左右两侧有浮动元素（同时清除左右两侧浮动的影响）</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除浮动的方法：</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153452.png" alt="image-20210825221654970" style="zoom:80%;" />

<ul>
<li><p>额外标签法（隔墙法）</p>
<ul>
<li>额外标签法会在最后一个浮动元素末尾添加一个空的标签。例如<code>&lt;div style=&quot;clear:both”&gt;&lt;/div&gt;</code>，或者其他标签(如&lt;br&#x2F;&gt;等），不过要求空标签必须是块级元素。</li>
</ul>
</li>
<li><p>父级添加overflow</p>
<ul>
<li>可以给父级添加overflow属性，将其属性值设置为hidden、auto或scroll 。</li>
</ul>
</li>
<li><p>:after 伪元素法 </p>
<ul>
<li>:after方式是额外标签法的升级版。也是给父元素添加</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">	<span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;  <span class="comment">/*IE6、7专有*/</span></span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父元素的类名为.clearfix  */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>双伪元素清除浮动，也是给父元素添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span>: after &#123;</span><br><span class="line">	<span class="attribute">content</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">	<span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">	*zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*父元素的类名为.clearfix  */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="（6）定位"><a href="#（6）定位" class="headerlink" title="（6）定位"></a>（6）定位</h3><blockquote>
<p>1．标准流通常用于竖列摆放盒子。</p>
<p>2．浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子。</p>
<p>3．定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。</p>
</blockquote>
<p><code>定位 = 定位模式 + 边偏移</code>，定位模式用于指定一个元素在文档中的定位方式。边偏移则决定了该元素的最终位置。</p>
<ul>
<li><p>定位模式： </p>
<p>定位模式决定元素的定位方式，它通过 CSS 的 position 属性来设置，其值可以分为以下几个:</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153455.png" alt="image-20210829224513734" style="zoom:50%;" />

<ul>
<li><p><code>static</code>：静态定位 （了解），静态定位是元素的默认定位方式，无定位的意思。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">position</span>: static; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>relative</code>：相对定位（重要），相对定位是元素在移动位置的时候，是相对于它<u>原来的位置</u>来说的。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">position</span>: relative; &#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>它是相对于自己原来的位置来移动的(移动位置的时候参照点是自己原来的位置)。</li>
<li>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。(<u>不脱标</u>，继续保留原来位置)</li>
</ul>
</li>
<li><p><code>absolute</code>：绝对定位（重要），绝对定位是元素在移动位置的时候，是相对于它<u>祖先元素</u>来说的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">position</span>: absolute; &#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位(Document文档)。</li>
<li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li>
<li>绝对定位不再占有原先的位置。(<u>脱标</u>)</li>
</ul>
</li>
<li><p><code>fixed</code>：固定定位（重要），固定定位是元素固定于浏览器可视区的位置。主要使用场景∶可以在浏览器页面<u>滚动时元素的位置不会改变</u>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">position</span>: fixed; &#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>以浏览器的可视窗口为参照点移动元素。和父元素无关，不会随着滚动条滚动。</li>
<li>固定定位不在占有原先的位置。即固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。</li>
</ul>
<p>小技巧：使用固定定位，将盒子固定在版心右侧位置。</p>
<ul>
<li>让固定定位的盒子left: 50%.走到浏览器可视区（也可以看做版心）的一半位置。</li>
<li>让固定定位的盒子margin-left:版心宽度的一半距离。多走版心宽度的一半位置</li>
</ul>
</li>
<li><p><code>sticky</code>：粘性定位（了解） ，粘性定位可以被认为是相对定位和固定定位的混合。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">position</span> : sticky; <span class="attribute">top</span>: <span class="number">10px</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点)</li>
<li>粘性定位占有原先的位置（相对定位特点)</li>
<li>必须添加top . left、right、bottom其中一个才有效</li>
</ul>
</li>
</ul>
</li>
<li><p>边偏移：</p>
<p>边偏移就是定位的盒子移动到最终位置。一共有4个属性。</p>
<ul>
<li><code>top</code>：顶端偏移量，定义元素相对于其父元素上边线的距离。比如top: 80px</li>
<li><code>bottom</code>：底部偏移量，定义元素相对于其父元素下边线的距离。比如bottom: 80px</li>
<li><code>left</code>：左侧偏移量，定义元素相对于其父元素左边线的距离。比如left: 80px</li>
<li><code>right </code>：右侧偏移量，定义元素相对于其父元素右边线的距离。比如left: 80px</li>
</ul>
</li>
<li><p>定位叠放次序：z-index</p>
<p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用z-index来控制盒子的前后次序(z轴)。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器&#123; <span class="attribute">z-index</span>: <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数值可以是正整数、负整数或0,默认是auto，数值越大，盒子越靠上。 </li>
<li>如果属性值相同，则按照书写顺序，后来居上。 </li>
<li>数字后面不能加单位。</li>
<li>只有定位的盒子才有z-index属性。</li>
</ul>
</li>
<li><p>小技巧：<strong>子绝父相</strong>：子级使用绝对定位，父级则需要相对定位</p>
<ol>
<li>子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</li>
<li>父盒子需要加定位限制子盒子在父盒子内显示。</li>
<li>父盒子布局时，需要占有位置，因此父亲只能是相对定位。</li>
</ol>
</li>
<li><p>小技巧：绝对定位的盒子水平居中（垂直居中类似），相对定位可以直接用(margin: 0 auto;)，因为其不脱标。</p>
<ul>
<li>先设置 left: 50%</li>
<li>再设置 margin-left: -盒子宽度的一半</li>
</ul>
</li>
<li><p>定位特殊特性</p>
<ul>
<li><p>绝对定位和固定定位也和浮动类似。</p>
<ul>
<li>行内元素添加绝对或者固定定位后，可以直接设置高度和宽度。不需要再转换元素显示模式。</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li>
</ul>
</li>
<li><p>脱标的盒子不会触发外边距塌陷。浮动元素、绝对定位(固定定位)元素的都不会触发外边距合并的问题。</p>
</li>
<li><p>绝对定位(固定定位）会完全压住盒子。</p>
<ul>
<li>浮动元素，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字(图片)</li>
<li>但是绝对定位(固定定位）会压住下面标准流所有的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（7）元素显示与隐藏"><a href="#（7）元素显示与隐藏" class="headerlink" title="（7）元素显示与隐藏"></a>（7）元素显示与隐藏</h3><ul>
<li><p><code>display </code>属性</p>
<ul>
<li>display: none; 隐藏对象，而且<u>原来位置不再保留</u>。</li>
<li>display : block; 除了转换为块级元素之外，同时还有显示元素的意思</li>
</ul>
</li>
<li><p><code>visibility</code> 属性</p>
<ul>
<li>visibility : visible; 元素可视</li>
<li>visibility : hidden;  元素隐藏，但<u>原来位置会保留</u>。</li>
</ul>
</li>
<li><p><code>overflow</code> 溢出</p>
<p>overflow属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度)时，会发生什么。</p>
<ul>
<li>overflow: visible; 默认，溢出的内容默认会显示。</li>
<li><u>overflow: hidden</u>; 溢出的内容会隐藏，未溢出的内容照常显示。</li>
<li>overflow: scroll; 溢出的部分显示滚动条（无论溢不溢出，都会有一个滚动条）。</li>
<li><u>overflow: auto</u>; 只有在有溢出时，才会显示滚动条，不溢出就不会显示滚动条  。</li>
</ul>
<p>一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。但是如果有定位的盒子，请慎用 overflow:hidden，因为它会隐藏多余的部分。</p>
</li>
</ul>
<h2 id="6-选择器"><a href="#6-选择器" class="headerlink" title="6. 选择器"></a>6. 选择器</h2><blockquote>
<p>选择器：筛选具有相似特征的元素。如果多个选择器作用于同一标签，优先级别为：id选择器 &gt; 类选择器 &gt; 标签选择器（范围越小，优先级越高）</p>
</blockquote>
<h3 id="（1）标签选择器"><a href="#（1）标签选择器" class="headerlink" title="（1）标签选择器"></a>（1）标签选择器</h3><p>标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。其基本语法格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">标签名 <span class="punctuation">&#123;</span></span><br><span class="line">	属性<span class="number">1</span><span class="punctuation">:</span> 属性值<span class="number">1</span>;</span><br><span class="line">	属性<span class="number">2</span><span class="punctuation">:</span> 属性值<span class="number">2</span>; </span><br><span class="line">	属性<span class="number">3</span><span class="punctuation">:</span> 属性值<span class="number">3</span>; </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure>

<p>标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。</p>
<p>标签选择器可以把某一类标签全部选择出来比如，div span</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置所有div标签边框为红色、实线、宽1px，字体颜色为蓝色，字体大小为30px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）id-选择器【重要】"><a href="#（2）id-选择器【重要】" class="headerlink" title="（2）id 选择器【重要】"></a>（2）id 选择器【重要】</h3><p>id 选择器使用『#』进行标识，后面紧跟id名，其基本语法格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#id名 <span class="punctuation">&#123;</span></span><br><span class="line">	属性<span class="number">1</span><span class="punctuation">:</span> 属性值<span class="number">1</span>; </span><br><span class="line">	属性<span class="number">2</span><span class="punctuation">:</span> 属性值<span class="number">2</span>; </span><br><span class="line">	属性<span class="number">3</span><span class="punctuation">:</span> 属性值<span class="number">3</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>该语法中，id 名即为 HTML 元素的 id 属性值，大多数 HTML 元素都可以定义 id 属性，元素的 id 值是唯一的，只能对应于文档中某一个具体的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改id属性值为id01的div标签：红色、实线、宽1px，字体颜色为蓝色，字体大小为30px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-id">#id01</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）类选择器【重要】"><a href="#（3）类选择器【重要】" class="headerlink" title="（3）类选择器【重要】"></a>（3）类选择器【重要】</h3><p>类选择器使用『.』（英文点号）进行标识，后面紧跟类名，其基本语法格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">.类名 <span class="punctuation">&#123;</span></span><br><span class="line">	属性<span class="number">1</span><span class="punctuation">:</span> 属性值<span class="number">1</span>;</span><br><span class="line">	属性<span class="number">2</span><span class="punctuation">:</span> 属性值<span class="number">2</span>;</span><br><span class="line">	属性<span class="number">3</span><span class="punctuation">:</span> 属性值<span class="number">3</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>标签调用的时候用 class&#x3D;“类名”  即可。</p>
<p>类选择器最大的优势是可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签。</p>
<p>我们可以给标签指定多个类名，从而达到更多的选择目的。</p>
<ol>
<li>样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。</li>
<li>各个类名中间用空格隔开。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改class属性值为class01的div标签：红色、实线、宽1px，字体颜色为蓝色，字体大小为30px--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-class">.class01</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id 选择器和类选择器区别</p>
<ul>
<li>W3C 标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。</li>
<li>类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜</li>
<li>id 选择器 好比人的身份证号码 ，全中国是唯一的， 不得重复。 只能使用一次。</li>
<li>id 选择器和类选择器最大的不同在于使用次数上。</li>
</ul>
<h3 id="（4）组合选择器（并集选择器）【重要】"><a href="#（4）组合选择器（并集选择器）【重要】" class="headerlink" title="（4）组合选择器（并集选择器）【重要】"></a>（4）组合选择器（并集选择器）【重要】</h3><p>组合选择器的格式是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">选择器 <span class="number">1</span>，选择器 <span class="number">2</span>，选择器 n <span class="punctuation">&#123;</span></span><br><span class="line">	属性：值;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>组合选择器可以让多个选择器共用同一个 css 样式代码。</p>
<h3 id="（5）通配符选择器"><a href="#（5）通配符选择器" class="headerlink" title="（5）通配符选择器"></a>（5）通配符选择器</h3><p>通配符选择器的格式是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	属性：值;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>通配符选择器表示选取页面中所有元素（标签）。</p>
<h3 id="（6）子元素选择器【重要】"><a href="#（6）子元素选择器【重要】" class="headerlink" title="（6）子元素选择器【重要】"></a>（6）子元素选择器【重要】</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">父元素&gt;子元素 <span class="punctuation">&#123;</span></span><br><span class="line">	属性：值;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>子元素选择器是选择所有包含在父元素之中的子元素。比如选择所有被div标签包裹的span 标签。</p>
<h3 id="（7）后代选择器（包含选择器）【重要】"><a href="#（7）后代选择器（包含选择器）【重要】" class="headerlink" title="（7）后代选择器（包含选择器）【重要】"></a>（7）后代选择器（包含选择器）【重要】</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">祖先元素  子元素 <span class="punctuation">&#123;</span></span><br><span class="line">	属性：值;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在给定的祖先元素下匹配所有后代元素。(不受层级限制)，与子元素选择器的不同之处在于，后代选择器中，两个元素之间只要存在包含关系即可，不一定非要是父子关系（比如也可能跨两层，是爷孙关系）</p>
<h3 id="（8）伪类选择器"><a href="#（8）伪类选择器" class="headerlink" title="（8）伪类选择器"></a>（8）伪类选择器</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>伪类选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 链接伪类选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* a:link是选择所有未被访问的链接 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: gray;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">ho</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* a:hover是选择所有鼠标指针位于其上的链接 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* a:active是选择所有活动链接（鼠标按下未弹起的链接） */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* focus伪类选择器 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* input:focus是选取获得焦点的表单元素 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>:green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example1.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>学习使用伪类选择器-1<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example2.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>学习使用伪类选择器-2<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>学习使用伪类选择器-3<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.example.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>学习使用伪类选择器-4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    输入1：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输入2：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输入3：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153453.png" alt="image-20210829191628092" style="zoom:50%;" />

<h2 id="7-CSS高级技巧"><a href="#7-CSS高级技巧" class="headerlink" title="7. CSS高级技巧"></a>7. CSS高级技巧</h2><h3 id="（1）精灵图"><a href="#（1）精灵图" class="headerlink" title="（1）精灵图"></a>（1）精灵图</h3><p>精灵图的出现是为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，其核心原理是将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了。</p>
<ul>
<li>精灵技术主要针对于小背景图片使用。就是把多个小背景图片整合到一张大图片中，这个大图片也称为sprites精灵图或者雪碧图</li>
<li>移动背景图片位置，此时可以使用<code>background-position</code>。移动的距离就是这个目标图片的x和y坐标。注意网页中的坐标有所不同。因为一般情况下都是往上往左移动，所以数值是负值。（大背景是有多个小背景组成的，我们实际需要的是小背景，那么也就是需要从大背景中找到小背景的位置，然后给相应盒子添加此背景，大背景肯定比盒子大，但实际上只显示小背景那一部分）</li>
<li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。</li>
<li>实际上就是多个小背景图片合成一张大背景图片，向后端请求时，只需要请求一次，得到大背景图片，所有需要小背景的地方都使用此大背景，但是通过background-position可以显示大背景图片中指定的区域。</li>
</ul>
<h3 id="（2）字体图标（iconfont）"><a href="#（2）字体图标（iconfont）" class="headerlink" title="（2）字体图标（iconfont）"></a>（2）字体图标（iconfont）</h3><p>字体图标使用场景∶主要用于显示网页中通用、常用、简单的一些小图标。字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。</p>
<p>精灵图也可以显示小图标，但其缺点很明显。1．图片文件还是比较大的。2.图片本身放大和缩小会失真。3.一旦图片制作完毕想要更换非常复杂。4.只有固定的颜色。</p>
<p>字体图标的优点：</p>
<ul>
<li>轻量级∶一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求</li>
<li>灵活性∶本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等</li>
<li>兼容性:几乎支持所有的浏览器，请放心使用</li>
</ul>
<p>注意:字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。</p>
<p>总结:</p>
<ul>
<li>如果遇到一些结构和样式比较简单的小图标，用字体图标。</li>
<li>如果遇到一些结构和样式复杂一点的小图片，用精灵图。</li>
</ul>
<p>字体图标是一些网页常见的小图标，我们直接网上下载即可。使用步骤如下︰ </p>
<ul>
<li><p>字体图标的下载</p>
<ul>
<li>icomoon字库 <a href="http://icomoon.io/">http://icomoon.io</a><ul>
<li>点击右上角IcoMoon App</li>
<li>选择自己想要的图标（如果不够，可以点击Add Icons From Library…寻找更多，还可以点击Import Icons将自己的svg图片生成为字体图标）</li>
<li>点击Generate Font生成图标</li>
<li>点击Download下载，得到zip文件，解压即可</li>
</ul>
</li>
<li>阿里iconfont字库 <a href="https://www.iconfont.cn/">https://www.iconfont.cn</a><ul>
<li>选择自己想要的图标，将其添加到购物车</li>
<li>点击购物车，选择下载代码，得到zip文件，解压即可</li>
</ul>
</li>
</ul>
</li>
<li><p>字体图标的引入（引入到我们html页面中)</p>
<ul>
<li><p>icomoon字库 <a href="http://icomoon.io/">http://icomoon.io</a></p>
<ul>
<li><p>将下载包里面的fonts文件夹放入页面根目录下</p>
</li>
<li><p>在CSS样式中声明字体</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;icomoon&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.eot?7kkyc2&#x27;</span>);</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.eot?7kkyc2#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.ttf?7kkyc2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.woff?7kkyc2&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;fonts/icomoon.svg?7kkyc2#icomoon&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开下载包中的demo.html，复制所需图标下面的</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153454.png" alt="image-20210810160555835"></p>
</li>
<li><p>在页面中使用span标签(或者其他标签)，内容为刚才复制的，然后将其样式中添加<code>font-family: &#39;icomoon&#39;</code>就会出现图标了，可以使用font-size设置图标大小，color设置图标颜色。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>字体图标的追加</p>
<p>如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标到原来的字体文件中。</p>
<p>点击Import Icons，把压缩包里面的selection.json 重新上传，然后选中自己想要新的图标，重新download 下载压缩包，并替换原来的文件即可。</p>
</li>
</ul>
<h3 id="（3）CSS三角形"><a href="#（3）CSS三角形" class="headerlink" title="（3）CSS三角形"></a>（3）CSS三角形</h3><p>网页中常见一些三角形，使用CSS直接画出来就可以，不必做成图片或者字体图标。</p>
<ul>
<li><p>等腰直角三角形</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153456.png" alt="image-20210829230247702" style="zoom:50%;" />

<p>比如制作上述三角形，只需要准备一个div盒子，然后将div的样式设置为如下内容即可，其中边框的像素越大，三角形就越大 ：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">10px</span> solid black;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br></pre></td></tr></table></figure>

<p>下面是上面代码的简化版：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</span><br><span class="line"><span class="comment">/* border-top: 10px solid black; */</span></span><br><span class="line"><span class="attribute">border-top-color</span>: blue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非等腰直角三角形【进一步就可以做梯形】</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153457.png" alt="image-20210830215901559" style="zoom:50%;" />

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 两个边框为0，两个不为0，且不一样大 */</span></span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">20px</span> solid black;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">0px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">0px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">10px</span> solid transparent;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（4）CSS用户界面样式（鼠标样式等）"><a href="#（4）CSS用户界面样式（鼠标样式等）" class="headerlink" title="（4）CSS用户界面样式（鼠标样式等）"></a>（4）CSS用户界面样式（鼠标样式等）</h3><ul>
<li><p>更改用户鼠标样式 <code>cursor</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cursor</span>: 属性值;</span><br></pre></td></tr></table></figure>

<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<p>可选属性值：</p>
<ul>
<li>default：默认，箭头</li>
<li>pointer：小手</li>
<li>move：移动，十字箭头 </li>
<li>text：文本</li>
<li>not-allowed：禁止</li>
</ul>
</li>
<li><p>表单轮廓线 <code>outline</code></p>
<p>当鼠标点击边框后，会默认出现蓝色边框，如果想要去掉此蓝色边框，只需要给表单添加以下样式即可。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方式1 */</span></span><br><span class="line"><span class="attribute">outline</span>:<span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 方式2 */</span></span><br><span class="line"><span class="attribute">outline</span>: none;</span><br></pre></td></tr></table></figure>
</li>
<li><p>防止拖拽文本域 <code>resize</code></p>
<p>真正开发中，不能允许用户拖拽文本域，否则会影响页面布局。防止拖拽的方法是给文本域加入以下样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">resize</span>: none;  <span class="comment">/* 防止拖拽 */</span></span><br><span class="line"><span class="attribute">outline</span>:<span class="number">0</span>;	<span class="comment">/* 去除表单轮廓线 */</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（5）vertical-aline-元素对齐"><a href="#（5）vertical-aline-元素对齐" class="headerlink" title="（5）vertical-aline 元素对齐"></a>（5）vertical-aline 元素对齐</h3><p>CSS的vertical-align属性使用场景∶经常用于设置图片或者表单(行内块元素)和文字垂直对齐。</p>
<p>用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: baseline | top | middle | bottom</span><br></pre></td></tr></table></figure>

<ul>
<li><code>baseline</code> 默认。元素放置在父元素的基线上。</li>
<li><code>top</code> 把元素的顶端与行中最高元素的顶端对齐。</li>
<li><code>middle</code> 把此元素放置在父元素的中部。  </li>
<li><code>bottom</code> 把元素的顶端与行中最低的元素的顶端对齐。</li>
</ul>
<p>解决图片底部默认空白缝隙问题</p>
<p>bug：图片底侧会有一个空白，原因是行内块元素会和文字的基线对齐。主要解决方法有两种</p>
<ul>
<li>给图片添加vertical-align:middle | top| bottom等。（提倡使用的)</li>
<li>把图片转换为块级元素display: block;</li>
</ul>
<h3 id="（6）溢出文字省略号显示"><a href="#（6）溢出文字省略号显示" class="headerlink" title="（6）溢出文字省略号显示"></a>（6）溢出文字省略号显示</h3><ul>
<li><p>单行文字溢出省略号显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1．强制一行内显示文本*/</span></span><br><span class="line"><span class="attribute">white-space</span>: nowrap;(默认<span class="attribute">normal</span>自动换行)</span><br><span class="line"><span class="comment">/*2．超出的部分隐藏*/</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="comment">/*3．文字用省略号替代超出的部分 ellipsis就是省略号的意思*/</span></span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文字溢出省略号显示</p>
<p>多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span> : hidden;</span><br><span class="line">text-derflow: ellipsis;</span><br><span class="line"><span class="comment">/*弹性伸缩盒子模型显示*/</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-box ;</span><br><span class="line"><span class="comment">/*限制在一个块元素显示的文本的行数*/</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式*/</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（7）两个浮动元素重叠边框如何变细"><a href="#（7）两个浮动元素重叠边框如何变细" class="headerlink" title="（7）两个浮动元素重叠边框如何变细"></a>（7）两个浮动元素重叠边框如何变细</h3><p>使用margin-left:-边框值，可以使得两个重叠的边框不重叠，变细。</p>
<h2 id="8-CSS3-新特性"><a href="#8-CSS3-新特性" class="headerlink" title="8. CSS3 新特性"></a>8. CSS3 新特性</h2><h3 id="（1）新增属性选择器"><a href="#（1）新增属性选择器" class="headerlink" title="（1）新增属性选择器"></a>（1）新增属性选择器</h3><p>属性选择器可以根据元素特定属性的来选择元素。这样就可以不用借助于类或者id选择器。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153458.png" alt="image-20210831210640991" style="zoom:80%;" />

<h3 id="（2）新增结构伪类选择器"><a href="#（2）新增结构伪类选择器" class="headerlink" title="（2）新增结构伪类选择器"></a>（2）新增结构伪类选择器</h3><p> 结构伪类选择器主要根据文档结构来选择器元 素，常用于根据父级选择器里面的子元素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153500.png"></p>
<p><code>nth-child(n)</code>选择某个父元素的一个或多个特定的子元素</p>
<ul>
<li>n可以是数字，关键字和公式</li>
<li>n如果是数字，就是选择第n个子元素，里面数字从1开始，比如选择第3个元素：E:nth-child(3)</li>
<li>n可以是关键字：even偶数，odd奇数</li>
<li>n可以是公式：常见的公式如下(如果n是公式，则从0开始计算，第0个元素或者超出了元素的个数会被忽略)<ul>
<li>E:nth-child(n) 选择所有子元素</li>
<li>E:nth-child(2n) 选择所有偶数子元素</li>
<li>E:nth-child(2n+1) 选择所有奇数子元素</li>
</ul>
</li>
</ul>
<p><code>nth-of-type(n)</code>选择某个父元素的一个或多个指定的子元素，用法和<code>nth-child(n)</code>基本一样。只不过nth-of-type(n)只把指定的子元素进行排序，而net-child(n)会把所有子元素进行排序。</p>
<ul>
<li>nth-child对父元素里面所有孩子排序选择（序号是固定的）先找到第n个孩子，然后看看是否和E匹配</li>
<li>nth-of-type对父元素里面指定子元素进行排序选择。先去匹配E，然后再根据E找第n个孩子</li>
</ul>
<h3 id="（3）伪元素选择器（重点）"><a href="#（3）伪元素选择器（重点）" class="headerlink" title="（3）伪元素选择器（重点）"></a>（3）伪元素选择器（重点）</h3><p> 伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTM结构。</p>
<ul>
<li><code>::before</code>：在元素内部的前面插入内容</li>
<li><code>:after</code>：在元素内部的后面插入内容</li>
<li>注意：<ul>
<li>before和after创建一个元素，但是属于行内元素 </li>
<li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li>
<li>语法: element::before {}</li>
<li>before和after必须有content属性</li>
<li>before在父元素<u>内容</u>的前面创建元素，after在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，权重为1</li>
</ul>
</li>
</ul>
<h3 id="（4）CSS3-盒子模型"><a href="#（4）CSS3-盒子模型" class="headerlink" title="（4）CSS3 盒子模型"></a>（4）CSS3 盒子模型</h3><p>CSS3中可以通过box-sizing来指定盒模型，有2个值∶即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。可以分成两种情况∶</p>
<ul>
<li>box-sizing:content-box盒子大小为width + padding + border(以前默认的)</li>
<li>box-sizing: border-box盒子大小为width</li>
</ul>
<p>如果盒子模型我们改为了box-sizing: border-box，那padding和border就不会撑大盒子了(前提padding和border不会超过width宽度)</p>
<h3 id="（5）CSS3-过渡"><a href="#（5）CSS3-过渡" class="headerlink" title="（5）CSS3 过渡"></a>（5）CSS3 过渡</h3><p>过渡动画:是从一个状态渐渐的过渡到另外—个状态。可以让我们页面更好看，更动感十足，虽然低版本浏览器不支持( ie9 以下版本）但是不会影响页面布局。</p>
<p>我们现在经常和:hover 一起搭配使用。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>:要过渡的属性 花费时间 运动曲线 何时开始;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>属性︰想要变化的css属性，宽度高度背景颜色内外边距都可以。如果想要所有的属性都变化过渡，写一个 all就可以。</p>
</li>
<li><p>花费时间 : 单位是秒(必须写单位）比如 0.5s</p>
</li>
<li><p>运动曲线︰默认是 ease (可以省略)</p>
</li>
<li><p>何时开始︰单位是秒(必须写单位)可以设置延迟触发时间默认是0s(可以省略)</p>
</li>
<li><p>注意：</p>
<ul>
<li><p>谁做过渡 给谁加 transition</p>
</li>
<li><p>如果想要多个属性过渡，可以在之间用逗号隔开，所有属性都过渡，用all</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>:要过渡的属性<span class="number">1</span> 花费时间<span class="number">1</span> 运动曲线<span class="number">1</span> 何时开始<span class="number">1</span>, 要过渡的属性<span class="number">2</span> 花费时间<span class="number">2</span> 运动曲线<span class="number">2</span> 何时开始<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="四-JavaScript"><a href="#四-JavaScript" class="headerlink" title="四. JavaScript"></a>四. JavaScript</h1><h2 id="1-名词解释-2"><a href="#1-名词解释-2" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><p>JavaScript 是一门客户端<strong>脚本语言</strong>。</p>
<ul>
<li>运行在客户端浏览器中，每一个浏览器都有 JavaScript 的解析引擎</li>
<li>脚本语言：不需要编译，直接就可以被浏览器解析执行</li>
</ul>
<p>JavaScript 是一种专门为网页交互而设计的脚本语言，可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。由下列三个不同的部分组成：</p>
<p>1、ECMAScript：由 ECMA-262 定义，提供核心语言功能（语法、类型、语句、关键字、保留字、操作符、对象）<br>2、DOM：文档对象模型，提供访问和操作网页内容的方法和接口<br>3、BOM：浏览器对象模型，提供与与浏览器交互的方法和接口**</p>
<h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><h3 id="（1）与-HTML-结合"><a href="#（1）与-HTML-结合" class="headerlink" title="（1）与 HTML 结合"></a>（1）与 HTML 结合</h3><p>向 HTML 页面中插入 JavaScript 的主要方法就是使用 &lt;script&gt; 元素。</p>
<p>方式一：定义&lt;script&gt;，标签体内容就是 JavaScript 代码。</p>
<p>方式二：定义&lt;script&gt;，通过 src 属性引入外部的js文件，可以是相对路径，也可以是绝对路径</p>
<p>注意：</p>
<ul>
<li><p>① &lt;script&gt; 可以定义在 html 页面的任何地方。但是定义的位置会影响执行顺序。内部的 JavaScript 代码从上到下依次被解释，也就是后面的代码会覆盖掉前面重复的代码。也是因为这个原因，为了避免浏览器显示页面出现明显的延迟，一般把全部的 JavaScript 引用放在 body 元素中页面内容的最后面。</p>
</li>
<li><p>② &lt;script&gt; 可以定义多个。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;方式一代码&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">test.js文件内容为：</span><br><span class="line">alert(&quot;方式二代码&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="（2）注释"><a href="#（2）注释" class="headerlink" title="（2）注释"></a>（2）注释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*多行注释*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）数据类型"><a href="#（3）数据类型" class="headerlink" title="（3）数据类型"></a>（3）数据类型</h3><ul>
<li><p>原始数据类型(基本数据类型)：</p>
<ul>
<li><code>number</code>：数字。 整数&#x2F;小数&#x2F;NaN(not a number 一个不是数字的数字类型)】</li>
<li><code>string</code>：字符串。 字符串  “abc” “a” ‘abc’（string是小写的，其包装类为String，JavaScript单引号和双引号没有区别）</li>
<li><code>boolean</code>: true和false</li>
<li><code>null</code>：一个对象为空的占位符、</li>
<li><code>undefined</code>：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li>
</ul>
</li>
<li><p>引用数据类型：</p>
<p>Object 类型</p>
</li>
</ul>
<h3 id="（4）变量"><a href="#（4）变量" class="headerlink" title="（4）变量"></a>（4）变量</h3><p>变量：一小块存储数据的内存空间，变量可以用来保存任何类型的数据，定义变量的时候要使用var操作符，后面跟变量名（标识符）。</p>
<p>Java 语言是强类型语言，而 JavaScript 是弱类型语言。</p>
<ul>
<li><code>强类型</code>：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li>
<li><code>弱类型</code>：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li>
</ul>
<p>语法：</p>
<ul>
<li><p>var 变量名 &#x3D; 初始化值;</p>
</li>
<li><p>typeof(变量名)：获取变量的类型。（注意这里有一个bug，就是null返回的类型是object(原始类型中没这个)而不是null）</p>
</li>
</ul>
<p>注意：</p>
<p>ECMAScript 中的一切（变量，函数名，操作符）都严格区分大小写</p>
<h3 id="（5）运算符"><a href="#（5）运算符" class="headerlink" title="（5）运算符"></a>（5）运算符</h3><p>特殊：</p>
<ul>
<li><p>等于和全等于</p>
<ul>
<li>等于： &#x3D;&#x3D; 等于是简单的做字面值的比较 12&#x3D;”12”会判断为true</li>
<li>全等于： &#x3D;&#x3D;&#x3D; 除了做字面值的比较之外，还会比较两个变量的数据类型</li>
</ul>
</li>
<li><p>由于javascript只有number类型，不区分整数和浮点数，所以 整数&#x2F;整数 如果除不尽，则结果为小数。（2 &#x2F; 5 &#x3D; 0.4）</p>
</li>
<li><p>在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p>
<ul>
<li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）（+”123” 、+”abc”）</li>
<li>boolean转number：true转为1，false转为0</li>
</ul>
</li>
<li><p>在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用。0 、NAN、null、 undefined、””(空串) 都认为是 false，其他都认为是true。</p>
</li>
</ul>
<h3 id="（6）对象"><a href="#（6）对象" class="headerlink" title="（6）对象"></a>（6）对象</h3><ul>
<li><p>Function：函数(方法)对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1.创建：</span></span><br><span class="line"><span class="comment">    方式一：</span></span><br><span class="line"><span class="comment">        function 方法名称(形式参数列表)&#123;</span></span><br><span class="line"><span class="comment">            方法体;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    方式二：</span></span><br><span class="line"><span class="comment">        var 方法名 = function(形式参数列表)&#123;</span></span><br><span class="line"><span class="comment">            方法体;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">2.属性</span></span><br><span class="line"><span class="comment">	length：形参个数：fun.length//这个是属性而不是成员方法，不需要()</span></span><br><span class="line"><span class="comment">3.特点：</span></span><br><span class="line"><span class="comment">    ①. 方法定义中形参的类型不用写,返回值类型也不写（弱类型）。</span></span><br><span class="line"><span class="comment">    ②. 方法是一个对象，如果定义名称相同的方法，会覆盖（没有重载）</span></span><br><span class="line"><span class="comment">    ③. 在JS中，方法的调用只与方法的名称有关，和参数列表无关（调用方法时的实参个数可以与形参个数不一致）</span></span><br><span class="line"><span class="comment">    ④. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数。隐形参数特别像 java 基础的可变长参数一		 样，可以通过arguments[i]获取第i个参数值。</span></span><br><span class="line"><span class="comment">4.调用：</span></span><br><span class="line"><span class="comment">	方法名称(实际参数列表);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">编写一个函数。用于计算所有参数相加的和并返回</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1,num2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> result = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">arguments</span>[i]) == <span class="string">&quot;number&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			result += <span class="variable language_">arguments</span>[i];</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Array：数组对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1. 创建：</span></span><br><span class="line"><span class="comment">	①. var arr = new Array(元素列表);</span></span><br><span class="line"><span class="comment">	②. var arr = new Array(默认长度);</span></span><br><span class="line"><span class="comment">	③. var arr = [元素列表];</span></span><br><span class="line"><span class="comment">2. 方法</span></span><br><span class="line"><span class="comment">	join(参数):将数组中的元素按照指定的分隔符拼接为字符串。</span></span><br><span class="line"><span class="comment">	push():	向数组的末尾添加一个或更多元素，并返回新的长度。</span></span><br><span class="line"><span class="comment">	pop(): 从数组中删除最后一个元素。</span></span><br><span class="line"><span class="comment">3. 属性</span></span><br><span class="line"><span class="comment">	length:数组的长度</span></span><br><span class="line"><span class="comment">4. 特点：</span></span><br><span class="line"><span class="comment">	①. 数组元素的类型可变。</span></span><br><span class="line"><span class="comment">	②. 数组长度可变。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">数组的遍历</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> array = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;array.<span class="property">length</span>;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i]);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Date：日期对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1. 创建：</span></span><br><span class="line"><span class="comment">	var date = new Date();</span></span><br><span class="line"><span class="comment">2. 方法：</span></span><br><span class="line"><span class="comment">	toLocaleString()：返回当前date对象对应的时间本地字符串格式</span></span><br><span class="line"><span class="comment">	getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Math：数学对象</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1. 创建：</span></span><br><span class="line"><span class="comment">	特点：Math对象不用创建，直接使用Math.方法名();</span></span><br><span class="line"><span class="comment">2. 方法：</span></span><br><span class="line"><span class="comment">    random():返回 0 ~ 1 之间的随机数。 含0不含1</span></span><br><span class="line"><span class="comment">    ceil(x)：对数进行上舍入。</span></span><br><span class="line"><span class="comment">    floor(x)：对数进行下舍入。</span></span><br><span class="line"><span class="comment">    round(x)：把数四舍五入为最接近的整数。</span></span><br><span class="line"><span class="comment">3. 属性：</span></span><br><span class="line"><span class="comment">		PI</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Boolean、Number、String（原始数据类型的包装类）</strong></p>
</li>
<li><p><strong>RegExp：正则表达式对象</strong></p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[xyz]</td>
<td>一个字符集合。匹配方括号中的任意字符，包括转义序列。也可以使用破折号（-）来指定一个字符范围。[abcd] 和[a-d]是一样的。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。也可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字。等价于[0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配一个单字字符（字母、数字或者下划线）。等价于[A-Za-z0-9_]。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配一个非单字字符。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td>
</tr>
<tr>
<td>{n}</td>
<td>n是一个正整数，匹配了前面一个字符刚好发生了n次。</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面一个表达式0次或者1次。等价于 {0,1}。</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个表达式0次或多次（任意）。等价于 {0,}。例如，&#x2F;bo*&#x2F;会匹配 “A ghost boooooed” 中的 ‘booooo’</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面一个表达式1次或者多次（至少一次）。等价于 {1,}。例如，&#x2F;a+&#x2F;匹配了在 “candy” 中的 ‘a’，和在 “caaaaaaandy” 中所有的 ‘a’。</td>
</tr>
<tr>
<td>*</td>
<td>匹配将依照下列规则： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，前面没有’’的’d’通常匹配小写’d’。如果加了’’,这个字符变成了一个特殊意义的字符，意思是匹配一个数字。 反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 &#x2F;a*&#x2F; 代表会匹配 0 个或者多个 a。相反，模式 &#x2F;a*&#x2F; 将 ‘<em>‘ 的特殊性移除，从而可以匹配像 “a</em>“ 这样的字符串。 使用 new RegExp(“pattern”) 的时候也不要忘记将 \ 进行转义，因为 \ 在字符串里面也是一个转义字符。</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入的开始，例如，&#x2F;^A&#x2F; 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入的结束。例如，&#x2F;t$&#x2F; 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符之外的任何单个字符。例如，&#x2F;.n&#x2F;将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1. 正则表达式：定义字符串的组成规则。</span></span><br><span class="line"><span class="comment">	①. 单个字符:[]</span></span><br><span class="line"><span class="comment">        如： [a] [ab] [a-zA-Z0-9_]（或）</span></span><br><span class="line"><span class="comment">        特殊符号代表特殊含义的单个字符:</span></span><br><span class="line"><span class="comment">        \d:单个数字字符 [0-9]</span></span><br><span class="line"><span class="comment">        \w:单个单词字符[a-zA-Z0-9_]</span></span><br><span class="line"><span class="comment">    ②. 量词符号：</span></span><br><span class="line"><span class="comment">        ?：表示出现0次或1次</span></span><br><span class="line"><span class="comment">        *：表示出现0次或多次</span></span><br><span class="line"><span class="comment">        +：出现1次或多次</span></span><br><span class="line"><span class="comment">        &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n</span></span><br><span class="line"><span class="comment">        	* m如果缺省： &#123;,n&#125;:最多n次</span></span><br><span class="line"><span class="comment">        	* n如果缺省：&#123;m,&#125; 最少m次</span></span><br><span class="line"><span class="comment">    ③. 开始结束符号</span></span><br><span class="line"><span class="comment">        * ^:开始</span></span><br><span class="line"><span class="comment">        * $:结束</span></span><br><span class="line"><span class="comment">2. 正则对象：</span></span><br><span class="line"><span class="comment">	①. 创建</span></span><br><span class="line"><span class="comment">        方式一： var reg = new RegExp(&quot;正则表达式&quot;);//由于是字符串，可能会有转义的麻烦</span></span><br><span class="line"><span class="comment">        方式二： var reg = /正则表达式/;（常用，注意此时的正则表达式不需要要用&quot;&quot;包含着）</span></span><br><span class="line"><span class="comment">	②. 方法	</span></span><br><span class="line"><span class="comment">        test(参数):验证指定的字符串是否符合正则定义的规范，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</span></span><br><span class="line"><span class="comment">3.常用正则</span></span><br><span class="line"><span class="comment">    验证数字：^[0-9]*$</span></span><br><span class="line"><span class="comment">    验证n位的数字：^\d&#123;n&#125;$</span></span><br><span class="line"><span class="comment">    验证至少n位数字：^\d&#123;n,&#125;$</span></span><br><span class="line"><span class="comment">    验证m-n位的数字：^\d&#123;m,n&#125;$</span></span><br><span class="line"><span class="comment">    验证由26个英文字母组成的字符串：^[A-Za-z]+$</span></span><br><span class="line"><span class="comment">    验证由26个大写英文字母组成的字符串：^[A-Z]+$</span></span><br><span class="line"><span class="comment">    验证由26个小写英文字母组成的字符串：^[a-z]+$</span></span><br><span class="line"><span class="comment">    验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span></span><br><span class="line"><span class="comment">    验证Email地址：^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span></span><br><span class="line"><span class="comment">    验证身份证号（15位或18位数字）：^\d&#123;15&#125;|\d&#123;&#125;18$</span></span><br><span class="line"><span class="comment">    中国大陆手机号码：1\d&#123;10&#125;</span></span><br><span class="line"><span class="comment">    中国大陆固定电话号码：(\d&#123;4&#125;-|\d&#123;3&#125;-)?(\d&#123;8&#125;|\d&#123;7&#125;)</span></span><br><span class="line"><span class="comment">    中国大陆邮政编码：[1-9]\d&#123;5&#125;</span></span><br><span class="line"><span class="comment">    IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</span></span><br><span class="line"><span class="comment">    日期(年-月-日)：(\d&#123;4&#125;|\d&#123;2&#125;)-((1[0-2])|(0?[1-9]))-(([12][0-9])|(3[01])|(0?[1-9]))</span></span><br><span class="line"><span class="comment">    日期(月/日/年)：((1[0-2])|(0?[1-9]))/(([12][0-9])|(3[01])|(0?[1-9]))/(\d&#123;4&#125;|\d&#123;2&#125;)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//匹配规则为，只能是数字或者字母，且位数在5-12之间</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> reg=<span class="regexp">/^[0-9a-zA-Z]&#123;5,12&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;6&gt;ssdsd&quot;</span>));<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;12345&quot;</span>));<span class="comment">//true</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>));<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(reg.<span class="title function_">test</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>));<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Global</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();</span></span><br><span class="line"><span class="comment">2. 方法：</span></span><br><span class="line"><span class="comment">	encodeURI():url编码</span></span><br><span class="line"><span class="comment">	decodeURI():url解码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	encodeURIComponent():url编码,编码的字符更多</span></span><br><span class="line"><span class="comment">	decodeURIComponent():url解码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	parseInt():将字符串转为数字</span></span><br><span class="line"><span class="comment">   		* 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number</span></span><br><span class="line"><span class="comment">    isNaN():判断一个值是否是NaN</span></span><br><span class="line"><span class="comment">    	* NaN六亲不认，连自己都不认。NaN参与的==比较全部问false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    eval():将JavaScript字符串作为脚本代码来执行。</span></span><br><span class="line"><span class="comment">		* var a = &quot;alert(123)&quot;;</span></span><br><span class="line"><span class="comment">		* eval(a);</span></span><br><span class="line"><span class="comment">3. URL编码</span></span><br><span class="line"><span class="comment">	举例：</span></span><br><span class="line"><span class="comment">		var str = &quot;传智播客&quot;;</span></span><br><span class="line"><span class="comment">		var encode = encodeURI(str);</span></span><br><span class="line"><span class="comment">		var decode = decodeURI(encode);</span></span><br><span class="line"><span class="comment">		document.write(encode);//%E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</span></span><br><span class="line"><span class="comment">		document.write(decode);//传智播客</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（7）事件"><a href="#（7）事件" class="headerlink" title="（7）事件"></a>（7）事件</h3><blockquote>
<p>事件是某些组建被执行了某些操作后，触发了某些代码的执行；</p>
</blockquote>
<p>常见的事件：</p>
<table>
<thead>
<tr>
<th align="left"><strong>事件</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">onload</td>
<td align="left">加载完成事件：页面加载完成之后，常用于做页面 js 代码初始化操作</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">单击事件： 常用于按钮的点击响应操作。（ondblclick:双击事件）</td>
</tr>
<tr>
<td align="left">onblur</td>
<td align="left">失去焦点事件： 常用用于输入框失去焦点后验证其输入内容是否合法。</td>
</tr>
<tr>
<td align="left">onfocus</td>
<td align="left">获得焦点事件</td>
</tr>
<tr>
<td align="left">onchange</td>
<td align="left">内容发生改变事件： 常用于下拉列表和输入框内容发生改变后操作</td>
</tr>
<tr>
<td align="left">onmousemove</td>
<td align="left">鼠标被移动</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">鼠标从某元素移开</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">鼠标被移到某元素之上</td>
</tr>
<tr>
<td align="left">onsubmit</td>
<td align="left">表单提交事件：提交按钮被点击，常用于表单提交前，验证所有表单项是否合法，<br/>当return false时，可以组织表单提交</td>
</tr>
<tr>
<td align="left">onselect</td>
<td align="left">文本被选定</td>
</tr>
<tr>
<td align="left">onreset</td>
<td align="left">重置按钮被点击。</td>
</tr>
</tbody></table>
<p>事件的绑定：</p>
<p>事件的注册（绑定）其实就是告诉浏览器，当事件响应后要执行哪些操作代码，叫事件注册或事件绑定。</p>
<ul>
<li>静态注册事件 ：通过 html 标签的事件属性直接赋于事件响应后的代码。</li>
<li>动态注册事件 ：先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 &#x3D; function(){} 这种形式赋于事件<br>响应后的代码。**</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> buttonTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;button02&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            buttonTag.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&#x27;你点击了按钮2(动态绑定)&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--方式一：静态绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button01&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你点击了按钮1(静态绑定)&#x27;)&quot;</span>&gt;</span>点击按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--方式二：动态绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button02&quot;</span>&gt;</span>点击按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-DOM模型"><a href="#3-DOM模型" class="headerlink" title="3. DOM模型"></a>3. DOM模型</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><blockquote>
<p>Document Object Model 文档对象模型，将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作，DOM将HTML文档表达为树结构：DOM树</p>
</blockquote>
<h3 id="（2）DOM标准"><a href="#（2）DOM标准" class="headerlink" title="（2）DOM标准"></a>（2）DOM标准</h3><p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型<ul>
<li><p>Document：文档对象</p>
</li>
<li><p>Element：元素对象</p>
</li>
<li><p>Attribute：属性对象</p>
</li>
<li><p>Text：文本对象</p>
</li>
<li><p>Comment:注释对象</p>
</li>
<li><p>Node：节点对象，其他5个的父对象</p>
</li>
</ul>
</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
<h3 id="（3）核心DOM模型"><a href="#（3）核心DOM模型" class="headerlink" title="（3）核心DOM模型"></a>（3）核心DOM模型</h3><ul>
<li><p><code>Document</code>：文档对象</p>
<ul>
<li><p>Document 对象的理解：</p>
<p>​    ① Document 它管理了所有的 HTML 文档内容。<br>​    ② Document 它是一种树结构的文档。有层级关系。<br>​    ③ 它让我们把所有的标签都对象化<br>​    ④ 我们可以通过 document 访问所有的标签对象。</p>
</li>
<li><p>创建：在 html dom 模型中可以使用 window 对象来获取</p>
<p>window.document &#x2F; document（即window可省略）</p>
</li>
<li><p>方法：</p>
<p><u>获取Element对象</u>：</p>
<p>​    ①<code>getElementById()</code>： 根据id属性值获取元素对象。id 属性值一般唯一</p>
<p>​    ②getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组</p>
<p>​    ③getElementsByClassName():根据 Class 属性值获取元素对象们。返回值是一个数组</p>
<p>​    ④getElementsByName(): 根据 name 属性值获取元素对象们。返回值是一个数组</p>
<p>​    ⑤write():将参数内容输出到页面上。</p>
<p>创建其他DOM对象：<br>  createAttribute(name)<br>  createComment()<br>  createElement()<br>  createTextNode()</p>
</li>
</ul>
</li>
<li><p><code>Element</code>：元素对象</p>
<ul>
<li>获取&#x2F;创建：通过 document 来获取和创建</li>
<li>方法：<ul>
<li>removeAttribute()：删除属性（例如 HTML 中某个对象有个 font 的属性，我们可以使用这个方法来去除掉）</li>
<li>setAttribute()：设置属性</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Node</code>：节点对象，其他 5 个的父对象</p>
<ul>
<li>特点：所有 dom 对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild()    ：删除（并返回）当前节点的指定子节点。</li>
<li>replaceChild()：用新节点替换一个子节点。</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode 返回节点的父节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（4）HTML-DOM"><a href="#（4）HTML-DOM" class="headerlink" title="（4）HTML DOM"></a>（4）HTML DOM</h3><p>HTML DOM 允许 JavaScript 改变 HTML 元素的内容。</p>
<ol>
<li><p>获取&#x2F;设置HTML元素的内容</p>
<p><code>document.getElementById(id).innerHTML=新的HTML内容;（不重新赋值就是获取原来html内容）</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> divTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;01&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//使用新的内容替换原来内容</span></span></span><br><span class="line"><span class="language-javascript">            divTag.<span class="property">innerHTML</span> = <span class="string">&quot;新的内容&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript"><span class="comment">/*          var divTag = document.getElementsByTagName(&quot;div&quot;);//注意返回的是数组</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            divTag[0].innerHTML = &quot;新的内容&quot;;*/</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;01&quot;</span>&gt;</span>原来内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取&#x2F;设置HTML元素的属性</p>
<p><code>document.getElementById(id).属性名=新的属性值;（不重新赋值就是获取原来属性值）</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> aTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id01&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            aTag.<span class="property">target</span>=<span class="string">&quot;_blank&quot;</span>;<span class="comment">//将在本页面跳转，改变为新建一个页面跳转</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_self&quot;</span>&gt;</span>跳转到百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>控制元素样式</p>
<p>① 使用元素的style属性来设置</p>
<pre><code>  document.getElementById(id).style.属性名=新样式；`
</code></pre>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">     <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">         <span class="selector-id">#id01</span>&#123;</span></span><br><span class="line"><span class="language-css">             <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">         &#125;</span></span><br><span class="line"><span class="language-css">     </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="keyword">var</span> aTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id01&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">             aTag.<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;blue&quot;</span>;<span class="comment">//如果原来CSS样式属性存在，则替换</span></span></span><br><span class="line"><span class="language-javascript">             aTag.<span class="property">style</span>.<span class="property">border</span>=<span class="string">&quot;1px solid red&quot;</span>;<span class="comment">//如果原来CSS样式属性不存在，则会添加</span></span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">     </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span>&gt;</span>div内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>② 改变元素的class&#x2F;id&#x2F;name属性，使得其应用其他的CSS样式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#id01</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#id02</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> aTag = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id01&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            aTag.<span class="property">id</span>=<span class="string">&quot;id02&quot;</span>;<span class="comment">//应用id02样式</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id01&quot;</span>&gt;</span>div内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-BOM"><a href="#4-BOM" class="headerlink" title="4. BOM"></a>4. BOM</h2><h3 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h3><p>Browser Object Model 浏览器对象模型，将浏览器的各个组成部分封装成对象。其使得 JavaScript 有能力与浏览器”对话”。</p>
<h3 id="（2）组成"><a href="#（2）组成" class="headerlink" title="（2）组成"></a>（2）组成</h3><ul>
<li>Window：窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象</li>
<li>Location：地址栏对象</li>
</ul>
<h3 id="（3）Window：窗口对象"><a href="#（3）Window：窗口对象" class="headerlink" title="（3）Window：窗口对象"></a>（3）Window：窗口对象</h3><p>1）创建</p>
<p>Window 对象不需要创建，可以直接使用它的方法（类方法）。并且，window的引用也可以省略，也就是直接写方法名就行了，甚至不需要写类名：例如我们常用的 alert 方法，其实就是 window.alert()。还有 window.document,我们也简化为document了</p>
<p>2）方法</p>
<ul>
<li><p>与弹出框有关的方法：<br><u>    alert()</u>    显示带有一段消息和一个确认按钮的警告框。<br><u>    confirm()</u>    显示带有一段消息以及确认按钮和取消按钮的对话框。<br>    如果用户点击确定按钮，则方法返回true<br>    如果用户点击取消按钮，则方法返回false<br><u>    prompt()</u>    显示可提示用户输入的对话框。（返回值：获取用户输入的值）</p>
</li>
<li><p>与打开关闭有关的方法：<br> close()    关闭浏览器窗口。（谁调用我 ，我关谁）<br> open()    打开一个新的浏览器窗口（返回新的Window对象）</p>
</li>
<li><p>与定时器有关的方式<br><strong>setTimeout()</strong>    在指定的毫秒数后调用函数或计算表达式，只执行一次。<br>​            参数：(js代码或者方法对象 , 毫秒值)</p>
<p>​            返回值：唯一标识，用于取消定时器</p>
<p>​    <strong>clearTimeout()</strong>    取消由 setTimeout() 方法设置的 timeout。</p>
<p>​    <strong>setInterval()</strong>    按照指定的周期（以毫秒计）来调用函数或计算表达式。</p>
<p>​    <strong>clearInterval()</strong>    取消由 setInterval() 设置的 timeout。</p>
</li>
</ul>
<p>3）属性：</p>
<ul>
<li><p>获取其他 BOM 对象：history &#x2F; location &#x2F; Navigator &#x2F; Screen</p>
</li>
<li><p>获取 DOM 对象：document</p>
</li>
</ul>
<h3 id="（4）Location：地址栏对象"><a href="#（4）Location：地址栏对象" class="headerlink" title="（4）Location：地址栏对象"></a>（4）Location：地址栏对象</h3><ul>
<li>创建(获取)：window.location &#x2F; location</li>
<li>方法：reload()    重新加载当前文档。刷新</li>
<li>属性：<code>&lt;u&gt;href&lt;/u&gt;</code>    设置或返回完整的 URL（HyperText Reference 超文本引用）。使用此属性可以修改当前地址栏的网址，达到跳转网页的效果</li>
</ul>
<h3 id="（5）History：历史记录对象"><a href="#（5）History：历史记录对象" class="headerlink" title="（5）History：历史记录对象"></a>（5）History：历史记录对象</h3><ul>
<li><p>创建(获取)：window.history &#x2F; history</p>
</li>
<li><p>方法：</p>
<p>back()    加载 history 列表中的前一个 URL。</p>
<p>forward()    加载 history 列表中的下一个 URL。</p>
<p>go(参数)    加载 history 列表中的某个具体页面。（参数如果是正数，则指前进几个历史记录。负数只后退几个历史记录）</p>
</li>
<li><p>属性：length    返回当前窗口历史列表中的 URL 数量。</p>
</li>
</ul>
<h1 id="五-JQuery"><a href="#五-JQuery" class="headerlink" title="五. JQuery"></a>五. JQuery</h1><h2 id="1-名词解释-3"><a href="#1-名词解释-3" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><p>jQuery，顾名思义，也就是 JavaScript 和查询（Query），它是辅助 JavaScript 开发的 js 类库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。</p>
<p> JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已</p>
<h2 id="2-引入-jQuery-包"><a href="#2-引入-jQuery-包" class="headerlink" title="2. 引入 jQuery 包"></a>2. 引入 jQuery 包</h2><p>（1）下载 jQuery</p>
<p>目前 jQuery有三个大版本：<br>            1.x：兼容 ie678,使用最为广泛的，官方只做 BUG 维护，<br>                 功能不再新增。因此一般项目来说，使用 1.x 版本就可以了，<br>                 最终版本：1.12.4 (2016年5月20日)<br>            2.x：不兼容 ie678，很少有人使用，官方只做 BUG 维护，<br>                 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，<br>                 最终版本：2.2.4 (2016年5月20日)<br>            3.x：不兼容 ie678，只支持最新的浏览器。除非特殊要求，<br>                 一般不会使用 3.x 版本的，很多老的 jQuery 插件不支持这个版本。<br>                 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）</p>
<p>jquery-xxx.js 与 jquery-xxx.min.js区别：</p>
<ul>
<li><p>jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些</p>
</li>
<li><p>jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快</p>
</li>
</ul>
<p>（2）导入JQuery的js文件</p>
<p>使用Google提供的API导入：如 <code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.7.2.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="3-jQuery-核心函数"><a href="#3-jQuery-核心函数" class="headerlink" title="3. jQuery 核心函数 $()"></a>3. jQuery 核心函数 $()</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数，$是jQuery的别名，$()等价于jQuery()。</span><br><span class="line">jQuery库只提供了一个叫jQuery的函数，该函数中以及该元素的原型中定义了大量的方法。</span><br></pre></td></tr></table></figure>

<p>jQuery 函数具有四种参数：</p>
<ul>
<li><p><u>传入参数为 [ 函数 ] 时</u>：</p>
<p>$(function(){}); 当文档加载完毕之后jQuery函数调用匿名函数。表示页面加载完成之后。相当于 window.onload &#x3D; function(){}</p>
</li>
<li><p><u>传入参数为 [ HTML 字符串 ] 时</u>：</p>
<p>jQuery 函数根据传入的文本创建好 HTML 元素并封装成 jQuery 对象并返回。  $(“&lt;div class&#x3D;”one”&gt;one&lt;&#x2F;div&gt;”);</p>
</li>
<li><p><u>传入参数为 [ 选择器字符串 ] 时</u>：</p>
<p>jQuery 函数通过该选择器获取对应的 DOM，然后将这些 DOM 封装到一个人 jQuery 对象中并返回。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$(“#id属性值”); id 选择器，根据 id 查询标签对象</span><br><span class="line">$(“标签名”); 标签名选择器，根据指定的标签名查询标签对象</span><br><span class="line">$(“.class属性值”); 类型选择器，可以根据 class 属性查询标签对象</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>传入参数为 [ DOM 对象 ] 时</u>：<br>jQuery 函数将该 DOM 封装成 jQuery 对象并返回，即会把这个 dom 对象转换为 jQuery 对象</p>
</li>
</ul>
<p><code>window.onload </code> 和 <code>$(function)</code> 区别</p>
<p>① $(function(){})不会被覆盖，而window.onload会被覆盖。</p>
<p>​    window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉。<br>​    $(function)可以定义多次的。</p>
<p>② $(function(){})在window.onload执行前执行的。</p>
<p>$(function(){})类似于原生js中的DOMContentLoaded事件，在DOM加载完毕后，页面全部内容（如图片等）完全加载完毕前被执行。而window.onload会在页面资源全部加载完毕后才会执行。</p>
<p>DOM文档加载步骤： </p>
<ol>
<li>解析HTML结构 </li>
<li>加载外部的脚本和样式文件 </li>
<li>解析并执行脚本代码 </li>
<li>执行<code>$(function()&#123;&#125;)</code>内对应代码 </li>
<li>加载图片等二进制资源 </li>
<li>页面加载完毕，执行<code>window.onload</code></li>
</ol>
<h2 id="4-jQuery-对象"><a href="#4-jQuery-对象" class="headerlink" title="4. jQuery 对象"></a>4. jQuery 对象</h2><p><u>jQuery 对象是 jQuery 函数的一个实例，是一个类数组对象，数组中存放的是 DOM 对象</u>，而 DOM 对象是 Node 的实例。   对 jQuery 对象的操作实际上是对 JQuery 数组中的 DOM 对象的批量操作。jQuery 对象和 DOM 对象可以相互转化。 但是 jQuery 对象不能使用 DOM 对象的属性和方法，DOM 对象也不能使用 jQuery 对象的属性和方法 </p>
<p>JQuery 对象和 JS 对象区别与转换</p>
<ul>
<li><p>dom 对象转化为 jQuery 对象<br><code>$( DOM 对象 )</code> 就可以转换成为 jQuery 对象</p>
</li>
<li><p>jQuery 对象转为 dom 对象</p>
<p><code>jQuery对象[下标]</code> &#x2F; <code>jQuery对象.get(下标) </code> 可以获取相应的DOM 对象。</p>
</li>
</ul>
<h2 id="5-jQuery-选择器"><a href="#5-jQuery-选择器" class="headerlink" title="5. jQuery 选择器"></a>5. jQuery 选择器</h2><h3 id="（1）基本选择器"><a href="#（1）基本选择器" class="headerlink" title="（1）基本选择器"></a>（1）基本选择器</h3><ul>
<li><p><u>标签选择器</u>（根据标签名查找标签对象）： <code>$(&quot;html标签名&quot;)</code> 获得所有匹配标签名称的元素</p>
</li>
<li><p><u>id选择器</u>（根据 id 查找标签对象）：<code>$(&quot;#id的属性值&quot;) </code>获得与指定 id 属性值匹配的元素</p>
</li>
<li><p><u>类选择器</u>（根据 class 查找标签对象）： <code>$(&quot;.class的属性值&quot;)</code> 获得与指定的 class 属性值匹配的元素</p>
</li>
<li><p><u>组合选择器</u>（取并集）：<code>$(&quot;选择器1,选择器2....&quot;) </code>获取多个选择器选中的所有元素</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> $div = $(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">alert</span>($div)<span class="comment">//[object Object]此时获取的是jQuery对象</span></span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">alert</span>($div[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//div标签1</span></span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">alert</span>($div[<span class="number">1</span>].<span class="property">innerHTML</span>);<span class="comment">//div标签2</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）层级选择器"><a href="#（2）层级选择器" class="headerlink" title="（2）层级选择器"></a>（2）层级选择器</h3><ul>
<li><u>后代选择器</u>：<code>$(&quot;a b&quot;)</code>在给定的祖先元素下匹配所有后代元素。(不受层级限制)</li>
<li><u>子选择器</u>：<code>$(&quot;parent &gt; child&quot;)</code>在给定的父元素下匹配所有子元素。</li>
<li><u>相邻选择器</u>：<code>$(&quot;prev + next&quot;)</code> 匹配所有<u>紧接在</u><code>prev</code>元素后的<code>next</code>元素。</li>
<li><u>兄弟选择器</u>：<code>$(&quot;prev ~ siblings&quot;)</code> 匹配<code>prev</code>元素之后的<u>所有</u><code>sibling</code>元素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $div1 = $(<span class="string">&quot;div+span&quot;</span>);<span class="comment">//必须是仅挨着div的span</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">1</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签3</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $div2 = $(<span class="string">&quot;div~span&quot;</span>);<span class="comment">//所有div后面的同辈span元素都可</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div2[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div2[<span class="number">1</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签2</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div2[<span class="number">2</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签2</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）过滤选择器"><a href="#（3）过滤选择器" class="headerlink" title="（3）过滤选择器"></a>（3）过滤选择器</h3><p>jQuery的过滤器必须用在jQuery选择器后，表示对通过前面的jQuery选择器选择到的内容的过滤。是建立在前面选择器已经选择到的元素的基础之上。 语法：selector:过滤器</p>
<table>
<thead>
<tr>
<th><strong>基本过滤器</strong></th>
<th><strong>说明</strong></th>
<th><strong>返回</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>:first</code> ★</td>
<td>匹配找到的第1个元素</td>
<td>单个元素</td>
</tr>
<tr>
<td><code>:last</code> ★</td>
<td>匹配找到的最后一个元素</td>
<td>单个元素</td>
</tr>
<tr>
<td><code>:eq </code> ★</td>
<td>匹配一个给定索引值的元素</td>
<td>单个元素</td>
</tr>
<tr>
<td><code>:even</code></td>
<td>匹配所有索引值为偶数的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>: odd</code></td>
<td>匹配所有索引值为奇数的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:gt(index)</code></td>
<td>匹配所有大于给定索引值的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:lt(index)</code></td>
<td>匹配所有小于给定索引值的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:not</code></td>
<td>去除所有与给定选择器匹配的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:animated</code></td>
<td>选取当前正在执行动画的所有元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:focus</code></td>
<td>选取当前正在获取焦点的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $div1 = $(<span class="string">&quot;div+span:first&quot;</span>);<span class="comment">//只取第一个紧挨着div的span</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//alert($div1[1].innerHTML);//不能取出span标签3</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>内容过滤器</strong></th>
<th><strong>描述</strong></th>
<th><strong>返回</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>:contains(text)</code> ★</td>
<td>选取含有文本内容为text的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:empty</code></td>
<td>选取不包含子元素获取文本的空元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:has(selector)</code></td>
<td>选择含有选择器所匹配的元素的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:parent</code></td>
<td>选取含有子元素或者文本的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $div1 = $(<span class="string">&quot;div~span:contains(&#x27;哈哈&#x27;) &quot;</span>);<span class="comment">//必须是仅挨着div的span</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签1,哈哈</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">1</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签3,哈哈</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签1,哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签2,嘿嘿<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签3,哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>属性过滤器</th>
<th>说明</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td><code>[attribute]</code> ★</td>
<td>选取拥有此属性的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>[attribute=value]</code> ★</td>
<td>选取属性值为<code>value</code>值的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>[attribue^=value]</code></td>
<td>选取属性的值以<code>value</code>开始的元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>[attribue$=value]</code></td>
<td>选取属性的值以<code>value</code>结束的元素</td>
<td>集合元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $div1 = $(<span class="string">&quot;div~span[name=&#x27;aa&#x27;]&quot;</span>);<span class="comment">//必须是仅挨着div的span</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">0</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($div1[<span class="number">1</span>].<span class="property">innerHTML</span>);<span class="comment">//span标签3</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>span标签1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">name</span>=<span class="string">&quot;bb&quot;</span>&gt;</span>span标签2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">name</span>=<span class="string">&quot;aa&quot;</span>&gt;</span>span标签3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表单过滤器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>:input</code></td>
<td>选取所有<code>input</code> <code>textarea</code> <code>select</code> <code>button</code>元素</td>
</tr>
<tr>
<td><code>:text</code> ★</td>
<td>选取所有单行文本框</td>
</tr>
<tr>
<td><code>:password</code> ★</td>
<td>选取所有密码框</td>
</tr>
<tr>
<td><code>:radio</code> ★</td>
<td>选取所有单选框</td>
</tr>
<tr>
<td><code>:checkbox </code>★</td>
<td>选取所有多选框</td>
</tr>
<tr>
<td><code>:submit </code></td>
<td>选取所有的提交按钮</td>
</tr>
<tr>
<td><code>:image </code></td>
<td>选取所有的图像按钮</td>
</tr>
<tr>
<td><code>:reset </code></td>
<td>选取所有的重置按钮</td>
</tr>
<tr>
<td><code>:button</code></td>
<td>选取所有的按钮</td>
</tr>
<tr>
<td><code>:file</code></td>
<td>选取所有的上传域</td>
</tr>
<tr>
<td><code>:hidden</code></td>
<td>选取所有的不可见元素</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> $radio = $(<span class="string">&quot;:radio&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($radio[<span class="number">0</span>].<span class="property">name</span>);<span class="comment">//gender</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($radio[<span class="number">1</span>].<span class="property">name</span>);<span class="comment">//gender</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;www.baidu.com&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">name</span>=<span class="string">&quot;我的表单&quot;</span>&gt;</span></span><br><span class="line">        用户姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span><span class="attr">:</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        用户密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        国籍：<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择国籍<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> &gt;</span>--中国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>--美国<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span>&gt;</span>--日本<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot; gender&quot;</span>&gt;</span>男</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot; gender&quot;</span>&gt;</span>女 <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        兴趣爱好<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>java</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>c++</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>python</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>其他 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        自我介绍<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>表单对象属性过滤器</th>
<th>说明</th>
<th>返回</th>
</tr>
</thead>
<tbody><tr>
<td><code>:enabled</code></td>
<td>选取所有可用元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:disabled</code></td>
<td>选取所有不可用元素</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:checked </code> ★</td>
<td>选取所有被选中的元素（单选框、复选框）</td>
<td>集合元素</td>
</tr>
<tr>
<td><code>:selected</code> ★</td>
<td>选取所有被选中的元素（下拉列表）</td>
<td>集合元素</td>
</tr>
</tbody></table>
<h2 id="6-jQuery-中-DOM-操作"><a href="#6-jQuery-中-DOM-操作" class="headerlink" title="6. jQuery 中 DOM 操作"></a>6. jQuery 中 DOM 操作</h2><h3 id="（1）内容操作"><a href="#（1）内容操作" class="headerlink" title="（1）内容操作"></a>（1）内容操作</h3><p><code>html()</code> : 获取&#x2F;设置元素的标签体内容，跟 dom 属性 innerHTML 一样。  无参数时获取html的值 ，有参数时设置html的值。  </p>
<p><code>text()</code> : 获取&#x2F;设置元素的标签体纯文本内容 ，跟 dom 属性 innerText 一样。无参数时获取文本值 ，有参数时设置文本值。</p>
<p><code>val()</code> ： 获取&#x2F;设置表单项的value属性值，跟 dom 属性 value 一样。无参数时获取value的值，有参数时设置value的值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>jQuery使用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.7.2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        $(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($(<span class="string">&quot;a&quot;</span>).<span class="title function_">html</span>());<span class="comment">//&lt;b&gt;百度&lt;/b&gt;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($(<span class="string">&quot;a&quot;</span>).<span class="title function_">text</span>());<span class="comment">//百度</span></span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;a&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;百度一下&quot;</span>);<span class="comment">//将百度替换成了百度一下</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>($(<span class="string">&quot;input&quot;</span>).<span class="title function_">val</span>());<span class="comment">//123</span></span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;input&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//把123改成了abc</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）属性操作"><a href="#（2）属性操作" class="headerlink" title="（2）属性操作"></a>（2）属性操作</h3><p><code>attr()</code> : 获取&#x2F;设置元素的属性</p>
<ul>
<li><p>返回属性的值：$(<em>selector</em>).attr(<em>property</em>)</p>
</li>
<li><p>设置属性和值：$(<em>selector</em>).attr(<em>property,value</em>)</p>
</li>
<li><p>使用函数设置属性和值：$(<em>selector</em>).attr(*property,*function(<em>index,currentvalue</em>))</p>
</li>
<li><p>设置多个属性和值：$(<em>selector</em>).attr({<em>property</em>:<em>value</em>, <em>property</em>:<em>value</em>,…})</p>
</li>
</ul>
<p><code>removeAttr()</code> :删除属性</p>
<ul>
<li>attribute是要移除的属性</li>
</ul>
<p><code>prop()</code> :获取&#x2F;设置元素的属性</p>
<ul>
<li><p>返回属性的值：$(<em>selector</em>).prop(<em>property</em>)</p>
</li>
<li><p>设置属性和值：$(<em>selector</em>).prop(<em>property,value</em>)</p>
</li>
<li><p>使用函数设置属性和值：$(<em>selector</em>).prop(*property,*function(<em>index,currentvalue</em>))</p>
</li>
<li><p>设置多个属性和值：$(<em>selector</em>).prop({<em>property</em>:<em>value</em>, <em>property</em>:<em>value</em>,…})</p>
</li>
</ul>
<p><code>removeProp()</code>:删除属性</p>
<ul>
<li>$(selector).removeProp(attribute);</li>
</ul>
<p>attr和prop区别？</p>
<ol>
<li>prop,只推荐操作 checked、readOnly、selected、disabled 等等（如果属性的值是布尔类型的值，建议使用）</li>
<li>attr,不推荐操作 checked、readOnly、selected、disabled 等等</li>
</ol>
<h3 id="（3）CSS-样式操作"><a href="#（3）CSS-样式操作" class="headerlink" title="（3）CSS 样式操作"></a>（3）CSS 样式操作</h3><p><code>addClass()</code> :添加class属性值</p>
<p><code>removeClass()</code> :删除class属性值</p>
<p><code>toggleClass()</code> :切换class属性（如果没有，则添加样式。）</p>
<p><code>offset()</code> : 获取和设置元素的坐标。</p>
<h3 id="（4）CRUD-操作"><a href="#（4）CRUD-操作" class="headerlink" title="（4）CRUD 操作"></a>（4）CRUD 操作</h3><ul>
<li><p><u>创建</u>：</p>
<p>创建元素节点：var newTd &#x3D; $(“<td></td>“)  </p>
<p>创建文本节点：var newTd &#x3D; $(“<td>文本内容</td>“)</p>
</li>
<li><p><u>插入</u>：</p>
<p>① 插入子元素</p>
<p><code>append()</code> : $A.append(B)       将B追加到A内部，作为它的最后一个子元素</p>
<p><code>prepend()</code> : $A.prepend(B)   将B追加到A内部，作为它的第一个子元素</p>
<p><code>appendTo()</code> : $A.appendTo(B)   将A追加到B的内部，作为它的最后一个子元素</p>
<p><code>prependTo()</code>： $A.prependTo(B)   将A追加到B内部，作为它的第一个子元素</p>
<p>② 插入兄弟元素</p>
<p><code>after()</code> :     $A.after(B)            在A之后追加B，作为它的兄弟元素</p>
<p><code>before()</code> :       $A.before(B)            在A之前追加B，作为它的兄弟元素</p>
<p><code>insertAfter()</code> :       $A.insertAfter(B)            在B之后追加A，作为它的兄弟元素</p>
<p><code>insertBefore()</code> :       $A.insertBefore(B)             在B之前追加A，作为它的兄弟元素</p>
</li>
<li><p><u>删除</u>：</p>
<p><code>remove()</code> :对象.remove():将对象删除掉</p>
<p><code>empty()</code>: 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点</p>
</li>
<li><p><u>替换</u>：</p>
<p><code>replaceWith()</code> : A.replaceWith(B) ,用 B 替换掉A</p>
<p><code>replaceAll()</code> : A.replaceAll(B) 用 A替换掉所有 B</p>
</li>
</ul>
<h3 id="（5）jQuery筛选函数"><a href="#（5）jQuery筛选函数" class="headerlink" title="（5）jQuery筛选函数"></a>（5）jQuery筛选函数</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>eq()</code> ★</td>
<td>获取给定索引的元素，功能跟 :eq 一样</td>
</tr>
<tr>
<td><code>first()</code> ★</td>
<td>获取第一个元素，功能跟 :first 一样</td>
</tr>
<tr>
<td><code>last()  </code>★</td>
<td>获取最后一个元素 ，功能跟 :last 一样</td>
</tr>
<tr>
<td><code>is(exp)</code></td>
<td>判断是否匹配给定的选择器，只要有一个匹配就返回，true</td>
</tr>
<tr>
<td><code>has(exp)</code></td>
<td>返回包含有匹配选择器的元素的元素，功能跟 :has 一样</td>
</tr>
<tr>
<td><code>not(exp) </code></td>
<td>删除匹配选择器的元素，功能跟 :not 一样</td>
</tr>
<tr>
<td><code>children(exp) </code></td>
<td>返回匹配给定选择器的子元素，功能跟 parent&gt;child 一样</td>
</tr>
<tr>
<td><code>find(exp)</code></td>
<td>返回匹配给定选择器的后代元素，功能跟 ancestor descendant 一样</td>
</tr>
<tr>
<td><code>next()</code></td>
<td>返回当前元素的下一个兄弟元素，功能跟 prev + next 功能一样</td>
</tr>
<tr>
<td><code>nextAll()</code></td>
<td>返回当前元素后面所有的兄弟元素，功能跟 prev ~ siblings 功能一样</td>
</tr>
<tr>
<td><code>filter(exp)</code></td>
<td>留下匹配的元素</td>
</tr>
<tr>
<td><code>nextUntil()</code></td>
<td>返回当前元素到指定匹配的元素为止的后面元素</td>
</tr>
<tr>
<td><code>parent() </code></td>
<td>返回父元素</td>
</tr>
<tr>
<td><code>prev(exp)</code></td>
<td>返回当前元素的上一个兄弟元素</td>
</tr>
<tr>
<td><code>prevAll()</code></td>
<td>返回当前元素前面所有的兄弟元素</td>
</tr>
<tr>
<td><code>prevUnit(exp)</code></td>
<td>返回当前元素到指定匹配的元素为止的前面元素</td>
</tr>
<tr>
<td><code>siblings(exp) </code></td>
<td>返回所有兄弟元素</td>
</tr>
<tr>
<td><code>add()</code></td>
<td>把 add 匹配的选择器的元素添加到当前 jquery 对象中</td>
</tr>
</tbody></table>
<h3 id="（6）动画"><a href="#（6）动画" class="headerlink" title="（6）动画"></a>（6）动画</h3><ul>
<li><p>默认显示和隐藏方式</p>
<ul>
<li><p><code>show([speed,[fn]])</code> ,将隐藏的元素显示(通过改变元素的高度宽度和不透明度，直到这三个属性值到0)</p>
</li>
<li><p><code>hide([speed,[fn]]) </code>,将可见的元素隐藏。(从上到下增加元素的高度，从左到右增加元素宽度，从0到1增加透明度，直至内容完全可见)</p>
</li>
<li><p><code>toggle([speed],[fn])</code> ，切换，可见就隐藏，不可见就显示。</p>
</li>
<li><p>参数意思：</p>
<p>speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000)</p>
<p>fn：在动画完成时执行的函数，每个元素执行一次。</p>
</li>
</ul>
</li>
<li><p>滑动显示和隐藏方式</p>
<ul>
<li>slideDown([speed],[easing],[fn])</li>
<li>slideUp([speed,[easing],[fn]])</li>
<li>slideToggle([speed],[easing],[fn])</li>
</ul>
</li>
<li><p>淡入淡出显示和隐藏方式</p>
<ul>
<li>fadeIn([speed],[easing],[fn])</li>
<li>fadeOut([speed],[easing],[fn])</li>
<li>fadeToggle([speed,[easing],[fn]])</li>
</ul>
</li>
</ul>
<h3 id="（7）事件-1"><a href="#（7）事件-1" class="headerlink" title="（7）事件"></a>（7）事件</h3><ul>
<li><p>jquery 标准的绑定方式</p>
<p><code>jq对象.事件方法(回调函数)</code>；（如果调用事件方法，不传递回调函数，则会触发浏览器默认行为，例如：单击超链接后会跳转、单击提交后表单会提交，有时需要阻止元素的默认行为，使用return false)</p>
<p><u>click()</u> 它可以绑定单击事件，以及触发单击事件</p>
<p><u>dblclick()</u>  双击</p>
<p><u>mouseover()</u> 鼠标移入事件</p>
<p><u>mouseout()</u> 鼠标移出事件</p>
<p><u>bind()</u> 可以给元素一次性绑定一个或多个事件。</p>
<p><u>one()</u> 使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次。</p>
<p><u>unbind()</u> 跟 bind 方法相反的操作，解除事件的绑定</p>
<p><u>live(type, <em>[data]</em>, fn）</u> 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出来的也有效。    </p>
</li>
<li><p>on绑定事件&#x2F;off解除绑定</p>
<p>jq对象.on(“事件名称”,回调函数);</p>
<p>jq对象.off(“事件名称”);（如果off方法不传递任何参数，则将组件上的所有事件全部解绑）</p>
</li>
<li><p>事件切换：toggle</p>
<p>jq对象.toggle(fn1,fn2…)（当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..）</p>
</li>
</ul>
<h1 id="六-XML"><a href="#六-XML" class="headerlink" title="六. XML"></a>六. XML</h1><h2 id="1-名词解释-4"><a href="#1-名词解释-4" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><p>XML全称：Extensible Markup Language 可扩展标记语言</p>
<p>XML 作用：</p>
<ul>
<li><strong>用来传输和存储数据。</strong></li>
<li><strong>作为配置文件</strong></li>
</ul>
<p>XML与HTNL的区别：</p>
<ul>
<li>xml 标签都是自定义的，html 标签是预定义。</li>
<li>xml 的语法严格，html 语法松散</li>
<li>xml 用于存储和传输数据的，其焦点是数据的内容。html 用于显示数据，其焦点是数据的外观。</li>
</ul>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><h3 id="（1）规范"><a href="#（1）规范" class="headerlink" title="（1）规范"></a>（1）规范</h3><ul>
<li><p>xml 文档的后缀名 .xml</p>
</li>
<li><p>xml 第一行必须定义为文档声明</p>
</li>
<li><p>xml 文档中有且仅有一个根标签</p>
</li>
<li><p>属性值必须使用引号(单双都可)引起来</p>
</li>
<li><p>标签必须正确关闭</p>
</li>
<li><p>大小写敏感</p>
</li>
<li><p>注释不能嵌套 <!-- 注释内容 --></p>
</li>
</ul>
<h3 id="（2）文档声明"><a href="#（2）文档声明" class="headerlink" title="（2）文档声明"></a>（2）文档声明</h3><p>格式：&lt;?xml version&#x3D;”1.0” encoding&#x3D;”UTF-8”?&gt;</p>
<ul>
<li><p>version：版本号</p>
</li>
<li><p>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</p>
</li>
<li><p>standalone（可以省略）：是否独立，取值为yes，表示不依赖其他文件，取值为no（默认值），表示依赖其他文件</p>
</li>
</ul>
<h3 id="（3）标签（元素）"><a href="#（3）标签（元素）" class="headerlink" title="（3）标签（元素）"></a>（3）标签（元素）</h3><p>在XML中，元素就是标签的意思。</p>
<p>规则：</p>
<ul>
<li>名称可以包含字母、数字以及其他的字符 </li>
<li>名称不能以数字或者标点符号开始 </li>
<li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li>
<li>名称不能包含空格 </li>
<li>XML元素中出现的空格和换行都会被当做元素内容进行处理。</li>
<li>xml 也 中的元素（标签）可成分成单标签和双标签：<br>单标签： &lt;标签名 属性&#x3D;”值” 属性&#x3D;”值” …… &#x2F;&gt;<br>双标签：&lt; 标签名 属性&#x3D;”值” 属性&#x3D;”值” ……&gt;文本数据或子标签&lt;&#x2F;标签名&gt;**</li>
</ul>
<h3 id="（4）特殊字符"><a href="#（4）特殊字符" class="headerlink" title="（4）特殊字符"></a>（4）特殊字符</h3><table>
<thead>
<tr>
<th align="center">特殊字符</th>
<th align="center">替代符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;</code></td>
<td align="center"><code>&amp;lt;</code></td>
</tr>
<tr>
<td align="center"><code>&gt;</code></td>
<td align="center"><code>&amp;gt;</code></td>
</tr>
<tr>
<td align="center"><code>&#39;</code></td>
<td align="center"><code>&amp;apos;</code></td>
</tr>
<tr>
<td align="center"><code>&quot;</code></td>
<td align="center"><code>&amp;quot;</code></td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center"><code>&amp;amp;</code></td>
</tr>
</tbody></table>
<h3 id="（5）CDATA-区"><a href="#（5）CDATA-区" class="headerlink" title="（5）CDATA 区"></a>（5）CDATA 区</h3><p>CDATA 是 Character Dat a的缩写，作用：在该区域中的数据会被原样展示。</p>
<pre><code>格式：  &lt;![CDATA[ 内容 ]]&gt;
</code></pre>
<h2 id="3-XML-解析"><a href="#3-XML-解析" class="headerlink" title="3. XML 解析"></a>3. XML 解析</h2><p>解析：操作 xml 文档，将文档中的数据读取到内存中</p>
<p>操作 xml 文档</p>
<ul>
<li>解析(读取)：将文档中的数据读取到内存中</li>
<li>写入：将内存中的数据保存到xml文档中。持久化的存储</li>
</ul>
<p>解析 xml 的方式：</p>
<ul>
<li><p>JDK 提供</p>
<ul>
<li><p>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p>
<p>优点：操作方便，可以对文档进行CRUD的所有操作</p>
<p>缺点：占内存</p>
</li>
<li><p>SAX（ Simple API for XML ）：逐行读取，基于事件驱动的。</p>
<p>优点：不占内存。</p>
<p>缺点：只能读取，不能增删改</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>第三方解析器<ul>
<li>jdom 在 dom 基础上进行了封装</li>
<li>dom4j 又对 jdom 进行了封装。</li>
</ul>
</li>
</ul>
<h2 id="4-dom4j-解析技术"><a href="#4-dom4j-解析技术" class="headerlink" title="4. dom4j 解析技术"></a>4. dom4j 解析技术</h2><p>dom4j 解析集 DOM 和 SAX 技术优点于一身，是目前最常用的解析 XML 的方法，</p>
<p>使用：</p>
<p>（1）导如 jar 包</p>
<p>创建一个 lib 目录， 导入dom4j 的 jar 包。并添加到类路径。</p>
<p>（2）CRUD</p>
<p>① 读取 XML 文件，获得 Document 对象</p>
<p>② 调用 Document 对象的 getRootElement() 方法得到根标签，返回的是 Element 对象</p>
<p>③ 使用 ELement对象.方法名(参数)进行操作</p>
<table>
<thead>
<tr>
<th align="left">返回值类型</th>
<th align="left">方法名（参数）</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Element</td>
<td align="left">element(“标签名”)</td>
<td align="left">获取指定名称的子元素，如果有多个该名称的子元素，则返回第一个</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">elements()</td>
<td align="left">获取所有子元素，并用一个list返回</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">elements(“标签名”)</td>
<td align="left">获得所有的该标签的子元素</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">getText()</td>
<td align="left">获得元素文本值</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">elementText(“标签名”)</td>
<td align="left">获得指定名称子元素的文本值</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">setText(“文本值”)</td>
<td align="left">设置元素文本值</td>
</tr>
<tr>
<td align="left">Element</td>
<td align="left">getparent()</td>
<td align="left">获取父节点，如果是根元素调用则返回null</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">attributes()</td>
<td align="left">获取该元素的所有属性，以一个list返回</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">attributeValue(“属性名”)</td>
<td align="left">获取指定名称属性的值，如果不存在该属性返回null</td>
</tr>
<tr>
<td align="left">Attribute</td>
<td align="left">attribute(”属性名“)</td>
<td align="left">获取指定名称的属性</td>
</tr>
<tr>
<td align="left">Element</td>
<td align="left">addAttribute(“标签名”,”标签值”)</td>
<td align="left">为元素增加属性</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">setAttributes(List attributes)</td>
<td align="left">将list中的所有属性设置到该元素上</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">remove(Attribute attribute)</td>
<td align="left">移除元素上的属性</td>
</tr>
<tr>
<td align="left">Iterator</td>
<td align="left">attributeIterator()</td>
<td align="left">获取属性迭代器</td>
</tr>
<tr>
<td align="left">Iterator</td>
<td align="left">elementIterator()</td>
<td align="left">获取子元素迭代器</td>
</tr>
<tr>
<td align="left">Iterator</td>
<td align="left">elementIterator(QName qName)</td>
<td align="left">获取指定名称的子元素的迭代器</td>
</tr>
</tbody></table>
<p>注意：读取 XML 文档的数据，都是通过 Document 获取根元素，再通过根元素获取得到其他节点从而进行操作。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要解析的xml文档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">sn</span>=<span class="string">&quot;SN12341232&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>辟邪剑谱<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">price</span>&gt;</span>9.9<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>班主任<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">book</span> <span class="attr">sn</span>=<span class="string">&quot;SN12341231&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>葵花宝典<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">price</span>&gt;</span>99.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">author</span>&gt;</span>班长<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMLTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.创建一个 SAXReader 对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用SAXReader对象读取XML文件，获取Document对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;books.xml&quot;</span>));</span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.使用Document对象获取根元素</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取所有标签</span></span><br><span class="line">        List&lt;Element&gt; elements = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.遍历每一个标签，获取标签的每一个元素(.element)，再获取标签内容(.getText)</span></span><br><span class="line">        <span class="comment">//获取标签元素，再获取标签内容，可以合并为一步，使用.elementText</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="comment">//获取属性值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> element.attributeValue(<span class="string">&quot;cn&quot;</span>);</span><br><span class="line">            <span class="comment">//获取元素值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.elementText(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> element.elementText(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> element.elementText(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">            <span class="comment">//将信息封装到一个对象中</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Book</span>(cn,name,Double.parseDouble(price),author));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七-Tomcat"><a href="#七-Tomcat" class="headerlink" title="七. Tomcat"></a>七. Tomcat</h1><h2 id="1-名词解释-5"><a href="#1-名词解释-5" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><p>Java web，是用 java 技术来解决相关 web 互联网领域技术的总称。web 包括：web 服务器和 web 客户端两部分。</p>
<p>javaweb 是基于请求和响应来开发的。</p>
<ul>
<li>请求：浏览器（客户端）向服务器发送信息</li>
<li>响应：服务器向（客户端）浏览器回送信息</li>
</ul>
<p>Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。<strong>它是一种轻量级的 javaWeb 容器（服务器），也是当前应用最广的 JavaWeb 服务器（免费）。</strong></p>
<h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a><strong>2. 基本使用</strong></h2><h3 id="（1）安装"><a href="#（1）安装" class="headerlink" title="（1）安装"></a>（1）安装</h3><ul>
<li><p>下载 Tomcat：<a href="http://tomcat.apache.org/whichversion.html">http://tomcat.apache.org/whichversion.html</a></p>
</li>
<li><p>安装 Tomcat：Tomcat 有安装版和解压版（绿色版)。</p>
<p>安装版以.exe 形式的安装包，双击安装到我们的电脑上，用的比较少，解压版，即绿色版，解压压缩包后即可，用的比较多。</p>
</li>
<li><p>Tomcat 版本</p>
<p>Apache Tomcat® 是 Jakarta EE (正式的 Java EE )技术的一个子集的开源软件实现。对于不同版本的规范，可以使用不同版本的 Apache Tomcat。规范和各自的 Apache Tomcat 版本之间的映射如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153459.png" alt="image-20210831212305407" style="zoom:70%;" />
</li>
<li><p>卸载 Tomcat：删除目录就行了</p>
</li>
<li><p>安装目录介绍：</p>
<ul>
<li><p><u>bin</u>：存放可执行文件。</p>
<p>在 window 下使用 startup.bat 和 shutdown.bat (linux，使用 startup.sh 和 shutdown.sh )来开启和关闭。最核心的脚本是 catalina.bat&#x2F;catalina.sh，startup 和 shutdown 脚本都会调用 catalina 脚本，catalina 脚本启动或者停止 tomcat 服务器。</p>
</li>
<li><p><u>conf</u>：配置文件目录 。</p>
<ul>
<li><p>server.xml（核心配置文件）：配置整个 web 服务器信息。例如修改端口号，添加虚拟主机等.</p>
</li>
<li><p>tomcat-users.xml（用户权限配置文件）：存储 tomcat 用户的文件，这里保存的是 tomcat 的用户名及密码，以及用户的角色信息。</p>
</li>
<li><p>web.xml（所有 web 项目默认配置文件）：部署描述符文件，这个文件中注册了很多 MIME 类型，即文档类型。</p>
</li>
<li><p>context.xml：对所有应用的统一配置，通常我们不会去配置它。</p>
</li>
</ul>
</li>
<li><p><u>lib</u>：依赖库，tomcat 和 web 项目中需要使用的 jar 包</p>
</li>
<li><p><u>logs</u>：日志文件.</p>
<p>记录了 tomcat 启动和关闭的信息，如果启动 tomcat 时有错误，那么异常也会记录在日志文件中。</p>
<p>localhost_access_log.*.txttomcat 记录用户访问信息，星号表示时间。<br>例如：localhost_access_log.2016-02-28.txt</p>
</li>
<li><p><u>temp</u>：临时文件目录，文件夹内内容可以任意删除。</p>
</li>
<li><p><u>webapps</u>：<strong>存放web项目的目录，其中每个文件夹都是一个项目；</strong>如果这个目录下已经存在了目录，那么都是 tomcat 自带项目。其中 ROOT 是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT 项目。<a href="http://localhost:8080/examples%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE%E3%80%82%E5%85%B6%E4%B8%AD">http://localhost:8080/examples，进入示例项目。其中</a> examples 就是项目名，即文件夹的名字。</p>
</li>
<li><p><u>work</u><strong>：运行时生成的文件，最终运行的文件都在这里。</strong>通过 webapps 中的项目生成的，可以把这个目录下的内容删除，再次运行时会生再次生成 work 目录。当客户端用户访问一个JSP文件时，tomcat 会通过JSP 生成 Java 文件，然后再编译 Java 文件生成 class 文件，生成的 java 和 class 文件都会存放到这个目录下。</p>
</li>
</ul>
</li>
</ul>
<h3 id="（2）启动"><a href="#（2）启动" class="headerlink" title="（2）启动"></a>（2）启动</h3><p>① 启动</p>
<ul>
<li><p><code>bin/startup.bat</code> ,双击运行该文件即可（bin目录下）</p>
<p>可能遇到的问题：</p>
<ol>
<li><p>黑窗口一闪而过：</p>
<ul>
<li>原因： 没有正确配置JAVA_HOME环境变量</li>
<li>解决方案：正确配置JAVA_HOME环境变量</li>
</ul>
</li>
<li><p>启动报错：</p>
<ul>
<li><p>原因：端口号冲突</p>
</li>
<li><p>解决方案：</p>
<p>方法一：找到占用的端口号，并且找到对应的进程，杀死该进程。</p>
<p>​    运行 cmd，输入netstat -ano|findstr 8080，会显示正在使用8080 端口的进程的id。</p>
<p>​    再输入taskkill &#x2F;pid 进程的id &#x2F;f，即可将其关闭。</p>
<p>方法二：修改端口号，找到 Tomcat 目录下的 conf 目录，找到 server.xml 配置文件，修改Connector标签下的port。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;要修改的端口号(0~65535)&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8445&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<p>② 访问：浏览器输入：<a href="http://localhost:8080/">http://localhost:8080</a> &#x2F; <a href="http://172.0.0.1:8080/">http://172.0.0.1:8080</a> &#x2F; <u>http:&#x2F;&#x2F;真实ip地址:8080</u></p>
<p>③ 关闭：</p>
<ul>
<li><p><code>bin/shutdown.bat</code>，双击此文件即可（bin目录下）</p>
</li>
<li><p>Tomcat 服务器窗口下，使用ctrl+c</p>
</li>
<li><p>点击启动窗口的× 关闭</p>
</li>
</ul>
<h3 id="（3）部署"><a href="#（3）部署" class="headerlink" title="（3）部署"></a>（3）部署</h3><p>部署 web 项目的方式：</p>
<ol>
<li><p>直接将项目放到 webapps 目录下即可。</p>
<ul>
<li>访问资源路径：<a href="http://ip:port/工程名/资源名">http://ip:port/工程名/资源名</a> ， 比如<a href="http://localhost:8080/hello/hello.html">http://localhost:8080/hello/hello.html</a></li>
<li>简化部署：将项目打成一个 wa r包，再将 war 包放置到 webapps 目录下。<ul>
<li>war 包会自动解压缩（访问路径为 war 包的名称）</li>
</ul>
</li>
</ul>
</li>
<li><p>配置 conf&#x2F;server.xml 文件<br>在&lt;Host&gt;标签体中配置&lt;Context docBase&#x3D;”××××” path&#x3D;”××××” &#x2F;&gt;</p>
<ul>
<li>docBase：项目存放的路径</li>
<li>path：虚拟目录（即” &#x2F;工程名 “），访问资源路径：<a href="http://ip:port/工程名/资源名">http://ip:port/工程名/资源名</a></li>
</ul>
</li>
<li><p>在 conf\Catalina\localhost 创建任意名称的xml文件。在文件中编写]&lt;Context docBase&#x3D;”D:\hello” &#x2F;&gt;</p>
<ul>
<li>虚拟目录：xml文件的名称 ,访问资源路径：<a href="http://ip:port/xml文件名/资源名">http://ip:port/xml文件名/资源名</a> （热部署，推荐）</li>
</ul>
</li>
</ol>
<p>注意：</p>
<ul>
<li>当我们在浏览器地址栏中输入访问地址如下：<br><a href="http://ip:port/">http://ip:port/</a> &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt; 没有工程名的时候，默认访问的是 ROOT 工程。</li>
<li>当我们在浏览器地址栏中输入的访问地址如下：<br><a href="http://ip:port/工程名/">http://ip:port/工程名/</a> &#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&gt;&gt; 没有资源名，默认访问 index.html 页面</li>
</ul>
<h3 id="（4）IDEA-添加-Tomcat-服务器"><a href="#（4）IDEA-添加-Tomcat-服务器" class="headerlink" title="（4）IDEA 添加 Tomcat 服务器"></a>（4）IDEA 添加 Tomcat 服务器</h3><p>操作的菜单如下： File | Settings | Build, Execution, Deployment | Application Servers</p>
<p>点击 + 号，选择Tomcat Server，Tomcat Home为 apache-tomcat-8.0.50 的安装路径，之后点击OK即可。</p>
<p>（举例：F:\Program Files\apache-tomcat-8.0.50-windows-x64\apache-tomcat-8.0.50）</p>
<p>之后创建一个Java Enterprice 模块，如果在 Application Server 中可以选择 Tomcat 服务器，即配置成功。</p>
<h3 id="（5）IDEA-中动态-web-工程的操作"><a href="#（5）IDEA-中动态-web-工程的操作" class="headerlink" title="（5）IDEA 中动态 web 工程的操作"></a>（5）IDEA 中动态 web 工程的操作</h3><p>① <u>创建一个新模块</u>，选择 Java Enterprise，注意勾选 Web application。</p>
<p>② <u>为web工程添加额外jar包</u></p>
<ul>
<li><p>方式一：在 WEB-INF 目录下，创建一个 lib 文件夹，将需要的 jar 包复制到此文件夹下，并 Add as library。</p>
</li>
<li><p>方式二：File-&gt;Project Structure-&gt;Libraries-&gt;点击+，选择 java，添加需要的 jar 包-&gt;选择需要用此jar包的模块-&gt;apply，接着选择 Artifacts-&gt;模块名：war exploded-&gt;Fix-&gt;add…（将类库，添加到打包部署中）</p>
</li>
</ul>
<p>③ <u>在 IDEA 中部署工程到 Tomcat 上运行</u></p>
<p>​        可以在上方选择 Tomcat 的 Edit Configrations 编辑其属性，如名称、端口号、默认浏览器、url等</p>
<p>​        右边有启动、Debug 启动和停止。</p>
<p>java动态项目的目录结构：</p>
<ul>
<li>项目的根目录<ul>
<li>WEB-INF目录：（此目录下的资源不能被浏览器直接访问）<ul>
<li>web.xml：web项目的核心配置文件</li>
<li>classes目录：放置字节码文件的目录</li>
<li>lib目录：放置依赖的jar包</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="八-Servlet"><a href="#八-Servlet" class="headerlink" title="八. Servlet"></a>八. Servlet</h1><h2 id="1-名词解释-6"><a href="#1-名词解释-6" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><ul>
<li><p><strong>Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端。</strong></p>
</li>
<li><p>Servlet 就 JavaWeb 三大组件之一。三大组件分别是：<code>Servlet 程序</code>、<code>Filter 过滤器</code>、<code>Listener 监听器</code>。</p>
</li>
<li><p>Servlet 就是一个接口，定义了 Java 类被浏览器访问到（tomcat识别）的规则。</p>
</li>
<li><p>Servlet 的体系结构    </p>
<ul>
<li><u>Servlet</u> – 接口<br>|<br><u>GenericServle</u>t – 抽象类<br>    |<br><u>HttpServle</u>t  – 抽象类</li>
</ul>
<ul>
<li><p>GenericServlet：将 Servlet 接口中其他的方法做了默认空实现，只将 service() 方法作为抽象</p>
<ul>
<li>将来定义 Servlet类时，可以继承 GenericServlet，实现 service() 方法即可</li>
</ul>
</li>
<li><p>HttpServlet：对http协议的一种封装，简化操作</p>
<ol>
<li>定义类继承 HttpServlet</li>
<li>复写 doGet&#x2F;doPost 方法</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="2-实现-Servlet-接口实现-Servlet-程序"><a href="#2-实现-Servlet-接口实现-Servlet-程序" class="headerlink" title="2. 实现 Servlet 接口实现 Servlet 程序"></a>2. 实现 Servlet 接口实现 Servlet 程序</h2><h3 id="（1）步骤"><a href="#（1）步骤" class="headerlink" title="（1）步骤"></a>（1）步骤</h3><p>① 自定义一个类，实现 Servlet 接口<br>② 实现接口中的抽象方法，<u>其中 service 方法，用于处理请求，并响应数据</u><br>③ 到 web.xml 中去配置 servlet 程序的访问地址</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Servlet --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>servlettest.ServletTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--url-pattern 标签配置访问地址 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">	/ 斜杠在服务器解析的时候，表示地址为： http://ip:port/工程路径 </span></span><br><span class="line"><span class="comment">	/hello 表示地址为： http://ip:port/工程路径/hello --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（2）执行原理"><a href="#（2）执行原理" class="headerlink" title="（2）执行原理"></a>（2）执行原理</h3><p><strong><a href="http://localhost:8080/07_servlet/hello">http://localhost:8080/07_servlet/hello</a></strong></p>
<table>
<thead>
<tr>
<th>URL</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>http:&#x2F;&#x2F;</td>
<td>协议</td>
</tr>
<tr>
<td>localhost</td>
<td>ip</td>
</tr>
<tr>
<td>:8080</td>
<td>端口号</td>
</tr>
<tr>
<td>&#x2F;07_servlet</td>
<td>工程路径</td>
</tr>
<tr>
<td>&#x2F;hello</td>
<td>资源路径</td>
</tr>
</tbody></table>
<p>① 当服务器接受到客户端浏览器的请求后，会解析请求 URL 路径，获取访问的 Servlet 的资源路径</p>
<p>② 查找 web.xml 文件，是否有对应的 &lt;url-pattern&gt; 标签体内容。</p>
<p>③ 如果有，则在找到对应的 &lt;servlet-class&gt; 全类名</p>
<p>④ tomcat 会将字节码文件加载进内存(有了全类名，使用反射的方式)，并且创建其对象。</p>
<p>⑤ 调用其方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153503.bmp" alt="image-20220328152113712"></p>
<h3 id="（3）Servlet-中方法的生命周期"><a href="#（3）Servlet-中方法的生命周期" class="headerlink" title="（3）Servlet 中方法的生命周期"></a>（3）Servlet 中方法的生命周期</h3><table>
<thead>
<tr>
<th>作用</th>
<th>方法</th>
<th>调用时间</th>
<th>调用次数</th>
</tr>
</thead>
<tbody><tr>
<td>实例化</td>
<td>构造方法</td>
<td>第一次访问请求时</td>
<td>1</td>
</tr>
<tr>
<td>初始化</td>
<td>init</td>
<td>构造方法被调用后</td>
<td>1</td>
</tr>
<tr>
<td>服务</td>
<td>service</td>
<td>当 client（客户机）访问请求到达时</td>
<td>N（每次访问都会调用）</td>
</tr>
<tr>
<td>销毁</td>
<td>destory</td>
<td>server（服务器）关闭时</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="（4）注解配置（了解）"><a href="#（4）注解配置（了解）" class="headerlink" title="（4）注解配置（了解）"></a>（4）注解配置（了解）</h3><ul>
<li><p>好处：不需要 web.xml 了。</p>
</li>
<li><p>步骤：</p>
<ol>
<li>创建 JavaEE 项目，选择 Servlet 的版本 3.0 以上，可以不创建 web.xml</li>
<li>定义一个类，实现 Servlet 接口</li>
<li>复写方法</li>
<li><u>在类上使用@WebServlet注解，进行配置：@WebServlet(“资源路径”)</u></li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebServlet &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//相当于&lt;Servlet-name&gt;</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//代表urlPatterns()属性配置</span></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;<span class="comment">//相当于&lt;url-pattern&gt;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">loadOnStartup</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;<span class="comment">//相当于&lt;load-on-startup&gt;</span></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">    String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）service-方法"><a href="#（5）service-方法" class="headerlink" title="（5）service 方法"></a>（5）service 方法</h3><p>service(ServletRequest servletRequest, ServletResponse servletResponse)</p>
<ul>
<li>服务器创建一个请求对象，处理客户端请求</li>
<li>服务器创建一个响应对象，响应客户端请求</li>
<li>服务器激活 Servlet 的 service() 方法，传递请求和响应对象作为参数</li>
<li>service() 方法获得关于请求对象的信息，处理请求，访问其他资源，获得需要的信息</li>
</ul>
<p>service 方法是专门用来处理请求和响应的，service() 方法使用响应对象的方法，将响应传回 Server，最终到达客户端。service() 方法可能激活其它方法以处理请求，如 doGet() 或 doPost() 或程序员自己开发的新的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span></span><br><span class="line">ServletException, IOException &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;Servlet 被访问了&quot;</span>);</span><br><span class="line">    <span class="comment">// 类型转换（因为它有 getMethod() 方法）</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">    <span class="comment">// 获取请求的方式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> httpServletRequest.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">    	doGet();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">    	doPost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做 get 请求的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理get请求&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//做 post 请求的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;处理post请求&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-继承-HttpServlet-方法实现-Servlet-程序"><a href="#3-继承-HttpServlet-方法实现-Servlet-程序" class="headerlink" title="3. 继承 HttpServlet 方法实现 Servlet 程序"></a>3. 继承 HttpServlet 方法实现 Servlet 程序</h2><p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。</p>
<h3 id="（1）步骤-1"><a href="#（1）步骤-1" class="headerlink" title="（1）步骤"></a>（1）步骤</h3><p>① 自定义一个类，去继承 HttpServlet 类<br>② 根据业务需要重写 doGet 或 doPost 方法<br>③ 到 web.xml 中的配置 Servlet 程序的访问地址**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">//重写doGet方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理get请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写doPost方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理Post请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）使用IDEA自动创建"><a href="#（2）使用IDEA自动创建" class="headerlink" title="（2）使用IDEA自动创建"></a>（2）使用IDEA自动创建</h3><p>① 在包下，右键 New</p>
<p>② 选择 Create New Sevlet</p>
<p>③ 写类名，并将下方的使用注解的方式不勾选（当然也可以使用注解）</p>
<p>此时就创建了一个类，并且重写了 doGet 和 doPost 方法，注意还要去修改 web.xml 文件</p>
<h2 id="4-ServletConfig-类"><a href="#4-ServletConfig-类" class="headerlink" title="4. ServletConfig 类"></a>4. ServletConfig 类</h2><p><u>说明</u>：</p>
<ul>
<li>ServletConfig 类是 Servlet 程序的配置信息类。</li>
<li><u>Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。</u></li>
<li>每个 Servlet 程序创建时，ServletConfig就创建一个对应的 ServletConfig 对象。也可以使用this.getservletconfig()。</li>
</ul>
<p><u>作用</u>：</p>
<ul>
<li>获取 Servlet 名称  getServletName()</li>
<li>获取 Servlet 初始化参数  getInitParameter() &#x2F;getInitParameterNames()</li>
<li>获取 ServletContext 对象：域对象</li>
</ul>
<p><u>初始化参数的配置文件</u>：</p>
<p>在 web.xml 文件中我们可以对 servlet 进行配置，在 &lt;servlet&gt; 配置标签内可以有以下这样的子标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--init-param 是初始化参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>参数名<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>参数值<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><u>方法</u>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String  getServletName()</td>
<td>获取在web应用程序中部署的servlet实例的名称</td>
</tr>
<tr>
<td>String  getInitParameter(String name)</td>
<td>获取包含指定初始化参数的值的String,如果不存在，返回null</td>
</tr>
<tr>
<td>Enumeration  getInitParameterNames()</td>
<td>以 String 对象的 Enumeration 的形式返回 servlet 的初始化参数的名称</td>
</tr>
<tr>
<td>ServletContext  getServletContext()</td>
<td>返回对调用者在其中执行操作的 ServletContext 的引用。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.init(config);</span><br><span class="line">    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> config.getServletName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Servlet程序名称为：&quot;</span> + servletName);<span class="comment">//Servlet程序名称为：HttpSevletTest</span></span><br><span class="line">    System.out.println(<span class="string">&quot;初始化参数username的值是：&quot;</span> + username);<span class="comment">//初始化参数username的值是：root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">super</span>.init();</span><br><span class="line">    <span class="type">String</span> <span class="variable">servletName</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig().getServletName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig().getInitParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Servlet程序名称为：&quot;</span> + servletName);<span class="comment">//Servlet程序名称为：HttpSevletTest</span></span><br><span class="line">    System.out.println(<span class="string">&quot;初始化参数username的值是：&quot;</span> + username);<span class="comment">//初始化参数username的值是：root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-ServletContext-类"><a href="#5-ServletContext-类" class="headerlink" title="5. ServletContext 类"></a>5. ServletContext 类</h2><p><u>说明</u>：</p>
<ul>
<li>ServletContext 是一个接口，它表示 Servlet 上下文对象</li>
<li>一个 web 工程，只有一个 ServletContext 对象实例。</li>
<li>ServletContext 对象是一个域对象（可以像 Map 一样存取数据的对象。这里的域指的是存取数据的操作范围，整个 web 工程。）</li>
<li>ServletContext 是在 web 工程部署启动的时候创建。</li>
</ul>
<p><u>作用</u>：</p>
<ul>
<li>获取 WEB 应用的初始化参数。（获取 web.xml 中配置的上下文参数 context-param）</li>
<li>获取当前的工程路径，格式: &#x2F;工程路径</li>
<li>获取工程部署后在服务器硬盘上的绝对路径</li>
<li>实现资源的共享（可以共享所有用户所有请求的数据）。（<strong>多个 Servlet 通过 ServletContext 对象数据共享</strong>）</li>
</ul>
<p><u>获取 servletContext 对象</u>：</p>
<ul>
<li><code>this.getServletConfig.getServletContext()</code></li>
<li><code>this.getServletContext()</code></li>
<li><code>request.getServletContext()</code></li>
</ul>
<p><u>方法</u>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void  setAttribute(String name, Object obj);</td>
<td>添加属性</td>
</tr>
<tr>
<td>Object  getAttribute(String name)</td>
<td>获取属性值，这个方法返回Object</td>
</tr>
<tr>
<td>void  removeAttribute(String name)</td>
<td>删除属性</td>
</tr>
<tr>
<td>String  getRealPath(String path)</td>
<td>返回资源文件在服务器文件系统上的真实路径（文件的绝对路径）。<br/>参数 path 代表资源文件的虚拟路径，以 &#x2F; 开始，&#x2F; 表示当前 Web 应用的根目录</td>
</tr>
<tr>
<td>String  getInitParameter(String name)</td>
<td>获取Tomcat的初始化参数（上下文参数）</td>
</tr>
</tbody></table>
<p><u>上下文参数的配置文件：</u>  </p>
<p>在 web.xml 文件中我们可以对 servlet 进行配置，在 &lt;web-app&gt; 配置标签内可以有以下这样的子标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--context-param 是上下文参数 ( 它属于整个 web 工程 )--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>参数名<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>参数值<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：通过S ervletCintext 对象添加的属性，在全局内可以共享，即多个 Servlet 通过 ServletContext 对象数据共享。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig().getServletContext();</span><br><span class="line">        <span class="comment">// 添加属性</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">password</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> servletContext.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;password:&quot;</span> + password);<span class="comment">//password:123</span></span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span> + key);<span class="comment">//key:value</span></span><br><span class="line">        System.out.println(servletContext.getInitParameter(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除属性</span></span><br><span class="line">        servletContext.removeAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取绝对路径(/ 斜杠被服务器解析地址为 :http://ip:port/ 工程名 / 映射到 IDEA 代码的 web 目录 &lt;br/&gt;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        System.out.println(realPath);<span class="comment">// D:\IDEA_JAVA\JavaWeb\out\artifacts\07_serlvet_war_exploded\</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletTest1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletConfig().getServletContext();</span><br><span class="line">        System.out.println(servletContext.getAttribute(<span class="string">&quot;password&quot;</span>));<span class="comment">// 123，实现了资源的共享</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-HTTP-协议"><a href="#6-HTTP-协议" class="headerlink" title="6. HTTP 协议"></a>6. HTTP 协议</h2><h3 id="（1）概念-2"><a href="#（1）概念-2" class="headerlink" title="（1）概念"></a>（1）概念</h3><blockquote>
<p>Hyper Text Transfer Protocol 超文本传输协议（传输协议：定义了，客户端和服务器端通信时，发送数据的格式）</p>
</blockquote>
<h3 id="（2）特点"><a href="#（2）特点" class="headerlink" title="（2）特点"></a>（2）特点</h3><ol>
<li>基于 TCP&#x2F;IP 的高级协议</li>
<li>默认端口号：80</li>
<li>基于请求&#x2F;响应模型的：一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
<h3 id="（3）请求消息数据格式"><a href="#（3）请求消息数据格式" class="headerlink" title="（3）请求消息数据格式"></a>（3）请求消息数据格式</h3><p>HTTP 有 7 种请求方式，常用的是 GET 和 POST 请求。</p>
<ul>
<li><p><u>GET 请求</u></p>
<p>1）请求行：包含三部分内容</p>
<p>​    ① 请求的方式：GET<br>​    ② 请求的资源路径[+?+请求参数]<br>​    ③ 请求的协议的版本号： HTTP&#x2F;1.1</p>
<p>​    举例：GET &#x2F;07_servlet&#x2F; HTTP&#x2F;1.1</p>
<p>2）请求头：客户端浏览器告诉服务器一些信息，由不同的键值对组成。</p>
<p>​    Accept： 表示客户端可以接收的数据类型<br>​    Accpet-Languege： 表示客户端可以接收的语言类型<br>​    User-Agent： 表示客户端浏览器的版本信息<br>​    Host： 表示请求时的服务器 ip 和端口号</p>
<p>​    举例：</p>
<p>​    Accept-Language: zh-CN,zh;q&#x3D;0.9 </p>
</li>
<li><p><u>POST 请求</u></p>
<p>1）请求行</p>
<p>​    ① 请求的方式 ： POST</p>
<p>​    ② 请求的资源路径[+?+请求参数]</p>
<p>​    ③ 请求的协议的版本号 ：HTTP&#x2F;1.1</p>
<p>​    举例：POST &#x2F;07_servlet&#x2F;hello1 HTTP&#x2F;1.1</p>
<p>2）请求头：客户端浏览器告诉服务器一些信息，由不同的键值对组成。<br>3）请求空行：就是用于分割POST请求的请求头，和请求体的。<br>4）请求体（正文）：就是发送给服务器的数据（封装POST请求消息的请求参数的,比如username&#x3D;123&amp;password&#x3D;123）</p>
</li>
</ul>
<p>区别：</p>
<table>
<thead>
<tr>
<th align="left">请求方式</th>
<th align="left">GET</th>
<th align="left">POST</th>
</tr>
</thead>
<tbody><tr>
<td align="left">安全性</td>
<td align="left">不安全</td>
<td align="left">相对安全</td>
</tr>
<tr>
<td align="left">url长度</td>
<td align="left">有限制</td>
<td align="left">无限制</td>
</tr>
<tr>
<td align="left">请求参数</td>
<td align="left">请求参数在请求行中，在url后。</td>
<td align="left">请求参数在请求体中</td>
</tr>
<tr>
<td align="left">常见情景</td>
<td align="left">1、form 标签 method&#x3D;get<br/>2、a 标签<br/>3、link 标签引入 css<br/>4、Script 标签引入 js 文件<br/>5、img 标签引入图片<br/>6、iframe 引入 html 页面<br/>7、在浏览器地址栏中输入地址后敲回车</td>
<td align="left">form 标签 method&#x3D;pos</td>
</tr>
</tbody></table>
<h3 id="（4）响应消息数据格式"><a href="#（4）响应消息数据格式" class="headerlink" title="（4）响应消息数据格式"></a>（4）响应消息数据格式</h3><ul>
<li><p>响应行<br>① 响应的协议和版本号  HTTP&#x2F;1.1</p>
<p>② 响应状态码</p>
<ul>
<li>1xx：消息。服务器接收客户端消息，但没有接收完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。比如200 表示请求成功</li>
<li>3xx：重定向。比如302 表示请求重定向，304表示访问缓存</li>
<li>4xx：客户端错误。比如404 表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误），405一般表示请求方式错误</li>
<li>5xx：服务器端错误。比如500 表示服务器已经收到请求，但是服务器内部错误（代码错误）</li>
</ul>
<p>③ 响应状态描述符</p>
<p>举例：HTTP&#x2F;1.1 200 OK</p>
</li>
<li><p>响应头：key : value 不同的响应头，有其不同含义</p>
</li>
<li><p>空行</p>
</li>
<li><p>响应体（正文）：就是回传给客户端的数据</p>
</li>
</ul>
<h3 id="（5）MIME-类型说明"><a href="#（5）MIME-类型说明" class="headerlink" title="（5）MIME 类型说明"></a>（5）MIME 类型说明</h3><p>MIME 是 HTTP 协议中数据类型，全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型&#x2F;小类型”，并与某一种文件的扩展名相对应。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
<th align="left">典型示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>text</code></td>
<td align="left">表明文件是普通文本，理论上是人类可读</td>
<td align="left">普通文本：<code>text/plain</code>,<br/>超文本标记语言文本:<code>text/html</code>,<br/><code>text/css, </code> <code>text/javascript</code>…</td>
</tr>
<tr>
<td align="left"><code>image</code></td>
<td align="left">表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型</td>
<td align="left">GIF图像：<code>image/gif</code><br/> <code>image/png</code>, <code>image/jpeg</code>….</td>
</tr>
<tr>
<td align="left"><code>audio</code></td>
<td align="left">表明是某种音频文件</td>
<td align="left"><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/wav</code>…</td>
</tr>
<tr>
<td align="left"><code>video</code></td>
<td align="left">表明是某种视频文件</td>
<td align="left"><code>video/webm</code>, <code>video/ogg</code></td>
</tr>
<tr>
<td align="left"><code>application</code></td>
<td align="left">表明是某种二进制数据</td>
<td align="left"><code>application/vnd.mspowerpoint</code>,<code>application/xml</code>, <code>application/pdf</code>…</td>
</tr>
</tbody></table>
<h2 id="7-HttpServletRequest-类"><a href="#7-HttpServletRequest-类" class="headerlink" title="7. HttpServletRequest 类"></a>7. HttpServletRequest 类</h2><p><u>作用</u>：</p>
<blockquote>
<p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。然后传递到 service 方法（doGet 和 doPost）中给我们使用。我们可以通过 HttpServletRequest 对象，获取到所有请求的信息。service 方法中的 request 的类型是 ServletRequest，而 doGet&#x2F;doPost 方法的request 的类型是 HttpServletRequest，HttpServletRequest 是 ServletRequest 的子接口，功能和方法更加强大。</p>
</blockquote>
<p> HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中。</p>
<p><u>request对象继承体系结构</u>：<br>    ServletRequest        –    接口<br>        |    继承<br>    HttpServletRequest    – 接口<br>        |    实现<br>    org.apache.catalina.connector.RequestFacade 类(tomcat)</p>
<p><u>常用方法</u>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getMethod()</td>
<td>获取请求的方式 GET 或 POST</td>
</tr>
<tr>
<td>getContextPath()</td>
<td>获取请求的工程路径（&#x2F;工程名）（动态获取工程路径）</td>
</tr>
<tr>
<td>getRequestURI()</td>
<td>获取请求的资源路径（统一资源标识符）（&#x2F;工程名&#x2F;资源名）</td>
</tr>
<tr>
<td>getRequestURL()</td>
<td>获取请求的统一资源定位符（绝对路径 <a href="http://ip:port/工程名/资源名）">http://ip:port/工程名/资源名）</a></td>
</tr>
<tr>
<td>getRemoteHost()</td>
<td>获取客户端的 ip 地址</td>
</tr>
<tr>
<td>getHeader(String name)</td>
<td>获取请求头</td>
</tr>
<tr>
<td>getParameter(string name)</td>
<td>获取请求的参数</td>
</tr>
<tr>
<td>getParameterValues(string name)</td>
<td>获取请求的参数（多个值的时候使用，比如表单的复选框）</td>
</tr>
<tr>
<td>setAttribute(key, value)</td>
<td>设置域数据</td>
</tr>
<tr>
<td>getAttribute(key)</td>
<td>获取域数据</td>
</tr>
<tr>
<td>removeAttribute(key)</td>
<td>删除域数据</td>
</tr>
<tr>
<td>getRequestDispatcher()</td>
<td>获取请求转发对象</td>
</tr>
<tr>
<td>setcharacterEncoding(“UTF-8”)</td>
<td>中文转码</td>
</tr>
<tr>
<td>getServletContext()</td>
<td>获取ServletContext对象</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;请求方式：&quot;</span> + method);<span class="comment">//请求方式：GET</span></span><br><span class="line">        <span class="comment">// 获取资源路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;资源路径：&quot;</span> + request.getRequestURI());<span class="comment">//资源路径：/07_servlet/servlet1111</span></span><br><span class="line">        <span class="comment">// 获取绝对路径</span></span><br><span class="line">        System.out.println(<span class="string">&quot;URL：&quot;</span> + request.getRequestURL());<span class="comment">//URL：http://localhost:8080/07_servlet/servlet1111</span></span><br><span class="line">        <span class="comment">// 获取客户端ip地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端ip地址：&quot;</span> + request.getRemoteHost());<span class="comment">//客户端ip地址：127.0.0.1</span></span><br><span class="line">        <span class="comment">// 获取请求头</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Host：&quot;</span> + request.getHeader(<span class="string">&quot;Host&quot;</span>));<span class="comment">//Host：localhost:8080</span></span><br><span class="line">        <span class="comment">// 获取请求体</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + request.getParameter(<span class="string">&quot;username&quot;</span>));<span class="comment">//用户名：张三</span></span><br><span class="line">        String[] hobbies = request.getParameterValues(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;兴趣爱好：&quot;</span>+ Arrays.asList(hobbies) );<span class="comment">//兴趣爱好：[java, Python]</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><u>注意中文乱码问题</u>：<br>get 方式：tomcat 8 已经将 get 方式乱码问题解决了<br>post 方式：仍会乱码，解决方法是在获取参数前，设置 request 的编码 request.setCharacterEncoding(“utf-8”);</p>
<p><u>请求转发</u>：</p>
<p>请求转发是指，一个 web 资源收到客户端请求后，通知服务器去调用另外一个 web 资源进行处理。</p>
<ul>
<li><p>步骤：</p>
<ul>
<li>通过 request 对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</li>
<li>使用 RequestDispatcher 对象来进行转发：forward(ServletRequest request, ServletResponse response)</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>浏览器地址栏路径不发生变化（因为是在服务端实现的）</li>
<li>只能转发到当前服务器内部资源中，不可访问工程以外的资源</li>
<li>转发是一次请求，可以使用 request 对象来共享数据</li>
<li>可以转发到 WEB-INF 目录下</li>
</ul>
</li>
</ul>
<p>域对象：一个有作用范围的对象，可以在范围内共享数据</p>
<p><u>request 域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据。</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet1</span> <span class="keyword">extends</span> <span class="title class_">HttpServletTest</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 请求转发必须要以斜杠打头， / 斜杠表示地址为： http://ip:port/ 工程名 / , 映射到 IDEA 代码的web目录</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet2</span> <span class="keyword">extends</span> <span class="title class_">HttpServletTest</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在转发后的程序中处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>绝对路径和相对路径</u>：</p>
<p>在 javaWeb 中，路径分为相对路径和绝对路径两种：</p>
<ul>
<li><p>相对路径：</p>
<ul>
<li>.&#x2F;表示当前目录（.&#x2F;可以省略不写）</li>
<li>..&#x2F;表示上一级目录</li>
<li>资源名   表示当前目录&#x2F;资源名</li>
</ul>
</li>
<li><p>绝对路径：<a href="http://ip:port/工程路径/资源路径">http://ip:port/工程路径/资源路径</a></p>
</li>
</ul>
<p>在 web 中 &#x2F; 斜杠 是一种绝对路径。</p>
<ul>
<li><p>&#x2F; 斜杠 如果被浏览器解析，得到的地址是：<a href="http://ip:port/">http://ip:port/</a></p>
<p>​    response.sendRediect(“&#x2F;”); 把斜杠发送给浏览器解析。得到 <a href="http://ip:port/">http://ip:port/</a></p>
<p>​    建议工程路径动态获取，使用 request.getContextPath()</p>
<p>​    response.sendRediect(request.getContextPath() + “&#x2F;资源名”)</p>
</li>
<li><p>&#x2F; 斜杠 如果被服务器解析，得到的地址是：<a href="http://ip:port/工程路径/">http://ip:port/工程路径/</a></p>
<p>​    1、&lt;url-pattern&gt;&#x2F;servlet1</url-pattern><br>​    2、servletContext.getRealPath(“&#x2F;”);<br>​    3、request.getRequestDispatcher(“&#x2F;”);</p>
</li>
</ul>
<h2 id="8-HttpServletResponse-类"><a href="#8-HttpServletResponse-类" class="headerlink" title="8. HttpServletResponse 类"></a>8. HttpServletResponse 类</h2><p><u>作用</u>: </p>
<blockquote>
<p>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse 对象来进行设置。</p>
</blockquote>
<p>HttpServletResponse是对服务器的响应对象。这个对象中封装了向客户端发送数据、发送响应头，发送响应状态码的方法。</p>
<p><u>常用方法</u>： </p>
<table>
<thead>
<tr>
<th>方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>getOutputStream()</td>
<td align="left">用于返回 Servlet 引擎创建的字节输出流对象，Servlet 程序可以按字节形式输出响应正文。常用于下载（传递二进制数据）</td>
</tr>
<tr>
<td>getWriter()</td>
<td align="left">用于返回 Servlet 引擎创建的字符输出流对象，Servlet 程序可以按字符形式输出响应正文。常用于回传字符串（常用）</td>
</tr>
<tr>
<td>addHeader(String name,String value)</td>
<td align="left">该方法是设置有多个值的响应头,参数 name 表示响应头名称,参数 value 表示响应头的值</td>
</tr>
<tr>
<td>setStatus(int value)</td>
<td align="left">设置临时定向响应码</td>
</tr>
<tr>
<td>setHeader(String name,String value)</td>
<td align="left">该方法是设置只有一个值的响应头,参数 name 表示响应头名称,参数value表示响应头的值</td>
</tr>
<tr>
<td>setContentType(“text&#x2F;html; charset&#x3D;UTF-8”);</td>
<td align="left">同时设置服务器和客户端都使用 UTF-8 字符集，解决中文乱码问题</td>
</tr>
</tbody></table>
<p>注意：getOutputStream() 和 getWriter() 这两个方法互相排斥，调用了其中的任何一个方法后，就不能再调用另一方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向客户端回传数据</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//解决中文乱码问题</span></span><br><span class="line"><span class="comment">//        方式一：</span></span><br><span class="line"><span class="comment">//        resp.setCharacterEncoding(&quot;UTF-8&quot;);//设置服务器字符集为 UTF-8</span></span><br><span class="line"><span class="comment">//        resp.setHeader(&quot;Content-Type&quot;,&quot;text/html;UTF-8&quot;);//通过响应头，设置浏览器也使用 UTF-8 字符集</span></span><br><span class="line"><span class="comment">//        方式二：【推荐】同时设置服务器和客户端都使用 UTF-8 字符集，还设置了响应头</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);<span class="comment">// 此方法一定要在获取流对象之前调用才有效</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.write(<span class="string">&quot;回传给客户端的数据&quot;</span>.toCharArray());</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><u>请求重定向</u>：</p>
<p>重定向指的是一个 web 资源收到客户端请求后，web 服务器通知客户端去访问另外一个web资源。（可能之前的地址已经被废弃）</p>
<p>实现的原理就是给客户端返回了 302 状态码和 location 头。</p>
<ul>
<li><p>步骤：<br>方式一：</p>
<ul>
<li>设置状态码为 302。 response.setStatus(302);</li>
<li>设置响应头 location。 response.setHeader(“location”,”新的地址”);：</li>
</ul>
<p>方式二【推荐】：<code>response.sendRedirect(&quot;新的地址&quot;)</code>;</p>
</li>
</ul>
<ul>
<li>特点:<ul>
<li>地址栏发生变化（因为是在客户端实现的）</li>
<li>重定向可以访问其他站点(服务器)的资源</li>
<li>重定向是两次请求。不能使用 request 对象来共享数据。</li>
</ul>
</li>
</ul>
<p><u>转发 forward 和重定向 Redirect 的区别</u></p>
<table>
<thead>
<tr>
<th></th>
<th>转发</th>
<th>重定向</th>
</tr>
</thead>
<tbody><tr>
<td>浏览器URL地址</td>
<td>转发是在服务器端实现的。所以请求转发过程结束后，<strong>浏览器地址栏保持初始的URL地址不变。</strong></td>
<td>而重定向是在客户端实现的。所以调用重定向的访问过程结束后，<strong>浏览器地址栏中显示的URL会发生改变</strong>，由初始的URL 地址变成重定向的目标 URL。</td>
</tr>
<tr>
<td>访问资源范围</td>
<td>只能将请求转发给同一个WEB应用中的其他资源；</td>
<td>还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。</td>
</tr>
<tr>
<td>请求次数</td>
<td>forward 方法的调用者与被调用者之间共享相同的 request 对象和 response 对象，它们属于同一个访问请求和响应过程；</td>
<td>sendRedirect方法调用者与被调用者使用各自的 request 对象和 response 对象，它们属于两个独立的访问请求和响应过程。也就是说，重定向生成了新的 request 对象和 response对象。</td>
</tr>
<tr>
<td>客户端是否可见</td>
<td>forward 方法在服务器端将请求转发给另外一个资源，相当过程于对客户端不可见。</td>
<td>sendRedirect 方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个 URL 的访问请求</td>
</tr>
</tbody></table>
<h1 id="九-文件上传与下载"><a href="#九-文件上传与下载" class="headerlink" title="九. 文件上传与下载"></a>九. 文件上传与下载</h1><h2 id="1-文件上传"><a href="#1-文件上传" class="headerlink" title="1. 文件上传"></a>1. 文件上传</h2><p>文件上传主要是将文件通过 IO 流传放到服务器的某一个特定的文件夹下。（就是将客户端的数据发送到服务器上的操作）</p>
<h3 id="（1）HTML-页面"><a href="#（1）HTML-页面" class="headerlink" title="（1）HTML 页面"></a>（1）HTML 页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;链接&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">（表单要求） </span></span><br><span class="line"><span class="comment">1.设置enctype=&quot;multipart/form-data&quot;，它不对字符进行编码，用于发送二进制的文件（即所有文件类型，如视频、图片、音乐、文档都可以用此类型entype）。</span></span><br><span class="line"><span class="comment">2.请求方式必须为post。</span></span><br><span class="line"><span class="comment">3.需要提供文件上传框(组件) &lt;input type=&quot;file&quot;&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/08_upload&amp;download/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>  <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> &gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uploadpicture&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传头像&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）导入-jar-包"><a href="#（2）导入-jar-包" class="headerlink" title="（2）导入 jar 包"></a>（2）导入 jar 包</h3><p>需要导入两个 jar 包（commons-fileupload-1.2.1.jar、commons-io-1.4.jar）核心类有：</p>
<p><u>DiskFileItemFactory</u>：创建 FileItem 对象的工厂</p>
<p><u>ServletFileUpload</u>：用于解析上传的数据，并将表单中每个输入项封装成一个FileItem 对象中。常用方法有：</p>
<ul>
<li>boolean isMultipartContent(HttpServletRequest request)：判断上传表单是否为multipart&#x2F;form-data类型</li>
<li><code>List parseRequest(HttpServletRequest request</code>：解析request对象，并把表单中的每一个输入项包装成一个fileItem 对象，并返回一个保存了所有FileItem的list集合。</li>
</ul>
<p><u>FileItem</u>：表示每一个表单项，常用方法有：</p>
<ul>
<li><code>String getFieldName()</code>：用于返回表单标签name属性值。</li>
<li><code>String getName()</code>：用于获得文件上传字段中的文件名。</li>
<li><code>String getString()</code>：获取字段的内容。如果是普通字段，则是它的value值；如果是文件字段，则是文件内容。</li>
<li>String getContentType()：获取上传的文件类型，例如text&#x2F;plain、image。如果是普通字段，则返回null。</li>
<li>long getSize()：获取字段内容的大小，单位是字节。</li>
<li><code>boolean isFormField()</code>：判断是否是普通表单字段，若是，返回true，否则返回false(即上传的是文件类型)。</li>
<li>InputStream getInputStream()：获得文件内容的输入流。如果是普通字段，则返回value值的输入流。</li>
<li><code>void write( file )</code>：将上传的文件写到 参数 file 所指向抽硬盘位置 。</li>
</ul>
<h3 id="（3）Servlet页面"><a href="#（3）Servlet页面" class="headerlink" title="（3）Servlet页面"></a>（3）Servlet页面</h3><p>实现步骤：</p>
<ul>
<li><p>创建一个 DiskFileItemFactory工厂，DiskFileItemFactory 工厂名&#x3D; new DiskFileItemFactory();</p>
</li>
<li><p>创建文件上传解析器，ServletFileUpload 解析器名 &#x3D; new ServletFileUpload(factory);</p>
</li>
<li><p>使用解析器解析request对象，调用parseRequest方法解析request对象，得到一个保存了所有上传内容的List对象。</p>
</li>
<li><p>对list进行迭代，每迭代一个FileItem对象，调用其isFormField方法判断是否是上传文件：</p>
<p>​        如果为普通表单字段，则调用getFieldName()、getString()方法得到字段名和字段值。<br>​        如果为上传文件，则调用write( file)方法将上传数据写入磁盘</p>
<p>注意：中文乱码问题解决：</p>
<ol>
<li>文件名中文乱码处理：解析器名.setHeaderEncoding(“utf-8”) 或 request.setCharacterEncoding(“utf-8”);</li>
<li>表单普通字段中文乱码处理：FileItem.getString(“utf-8”);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Upload</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        1.创建工厂类：</span></span><br><span class="line">        <span class="type">DiskFileItemFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line"><span class="comment">//        2.创建解析器：</span></span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">upload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(factory);</span><br><span class="line">        	<span class="comment">//解决上传文件名的中文乱码                       </span></span><br><span class="line">            upload.setHeaderEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//           3.使用解析器解析request对象：</span></span><br><span class="line">            List&lt;FileItem&gt; list = upload.parseRequest(req);</span><br><span class="line"><span class="comment">//           4.遍历</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">                <span class="comment">//判断是否是普通表单字段，若是，返回true，否则返回false。</span></span><br><span class="line">                <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">                    System.out.println(fileItem.getFieldName());<span class="comment">//获取表单项的name的属性值。</span></span><br><span class="line">                    System.out.println(fileItem.getString(<span class="string">&quot;utf-8&quot;</span>));<span class="comment">//获取字段的内容。如果是普通字段，则是它的value值；如果是文件字段，则是文件内容。</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fileItem.getName() != <span class="string">&quot;&quot;</span>) &#123;<span class="comment">//获取文件字段的文件名,如果没有上传，则返回空串。</span></span><br><span class="line">                        <span class="comment">//将文件写入指定磁盘</span></span><br><span class="line">                       fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IDEA_JAVA\\JavaWeb\\08_upload&amp;download\\b.jpg&quot;</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;没有上传文件&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-文件下载"><a href="#2-文件下载" class="headerlink" title="2. 文件下载"></a>2. 文件下载</h2><p>文件下载主要是将文件从服务器的特定的文件夹下的文件通过 IO 流下载到本地。（就是将服务器的数据下载到客户端上的操作）</p>
<p>   步骤：</p>
<ul>
<li><p><u>设置响应头信息</u>，告诉客户端收到的数据是用于下载使用(如果不设置，文件会直接在页面显示，而不是下载)</p>
<p>Content-Disposition 响应头，表示收到的数据怎么处理<br>attachment 表示附件，表示下载使用<br>filename 表示指定下载的文件名（此名字只是用户下载后显示的名字，可以与服务器文件的名字不一样）</p>
<p>示例：resp.setHeader(“Content-Disposition”, “attachment; filename&#x3D;” + “指定所下载文件的名称”);</p>
<p>注意：为了解决中文乱码问题，可以将上面示例改为：</p>
<p>resp.setHeader(“Content-Disposition”, “attachment; filename&#x3D;” + URLEncoder.encode(“指定所下载文件的名称”, “UTF-8”));</p>
</li>
<li><p><u>获取文件输入流</u></p>
<p>示例：InputStream inputStream &#x3D; new FileInputStream(new File(“文件路径”));</p>
</li>
<li><p><u>获取响应输出流</u></p>
<p>示例：OutputStream outputStream &#x3D; resp.getOutputStream();</p>
</li>
<li><p><u>将文件回传到客户端</u>（即实现文件的复制）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/08_upload&amp;download/download&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span>&gt;</span>下载图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Download</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1、设置响应头信息</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=&quot;</span> + URLEncoder.encode(<span class="string">&quot;随便&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        <span class="comment">//2.获取文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext().getResourceAsStream(<span class="string">&quot;/&quot;</span> + a.jpg);</span><br><span class="line"><span class="comment">//        InputStream inputStream = new FileInputStream(new File(&quot;D:\\IDEA_JAVA\\JavaWeb\\08_upload&amp;download\\b.jpg&quot;));</span></span><br><span class="line">        <span class="comment">//3.获取响应的输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line">        <span class="comment">//4 、把文件内容回传给客户端</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十-JSP"><a href="#十-JSP" class="headerlink" title="十. JSP"></a>十. JSP</h1><blockquote>
<p>JSP全名为Java Server Pages，即 java 服务器页面。JSP 是⼀种基于⽂本的程序，其特点就是 HTML 和 Java 代码共同存在！Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高，而 jsp 的主要作用就是代替 Servlet 程序回传 html 页面的数据。</p>
</blockquote>
<p>jsp 页面本质上是一个 Servlet 程序。<br>当我们第一次访问 jsp 页面的时候。Tomcat 服务器会帮我们把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成为.class 字节码程序。而java源文件中的类间接的继承了 HttpServlet 类。</p>
<h2 id="1-jsp-的语法"><a href="#1-jsp-的语法" class="headerlink" title="1. jsp 的语法"></a>1. jsp 的语法</h2><h3 id="（1）指令"><a href="#（1）指令" class="headerlink" title="（1）指令"></a>（1）指令</h3><ul>
<li><p>作用：用于配置JSP页面，导入资源文件</p>
</li>
<li><p>格式：&lt;%@ 指令名称 属性名1&#x3D;属性值1 属性名2&#x3D;属性值2 … %&gt;</p>
</li>
<li><p>分类：</p>
<p><u>page</u>： 配置JSP页面</p>
<ul>
<li>&lt;%@ page contentType&#x3D;”text&#x2F;html;charset&#x3D;UTF-8” language&#x3D;”java” %&gt;</li>
</ul>
<ul>
<li>contentType：等同于response.setContentType()<ol>
<li>设置响应体的mime类型以及字符集</li>
<li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li>
</ol>
</li>
<li>import：导包</li>
<li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li>
<li>isErrorPage：标识当前也是是否是错误页面。<ul>
<li>true：是，可以使用内置对象exception</li>
<li>false：否。默认值。不可以使用内置对象exception</li>
</ul>
</li>
</ul>
<p><u>include</u>： 页面包含的。导入页面的资源文件</p>
<ul>
<li>&lt;%@include file&#x3D;”top.jsp”%&gt;</li>
</ul>
<p><u>taglib</u>： 导入资源</p>
<ul>
<li>&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”<a href="http://java.sun.com/jsp/jstl/core&quot;">http://java.sun.com/jsp/jstl/core&quot;</a> %&gt;</li>
<li>prefix：前缀，自定义的</li>
</ul>
</li>
</ul>
<h3 id="（2）注释-1"><a href="#（2）注释-1" class="headerlink" title="（2）注释"></a>（2）注释</h3><ol>
<li>html注释：<!-- -->:只能注释html代码片段</li>
<li>jsp注释：推荐使用<br>&lt;%– –%&gt;：可以注释所有</li>
</ol>
<h3 id="（3）脚本"><a href="#（3）脚本" class="headerlink" title="（3）脚本"></a>（3）脚本</h3><ul>
<li><code>&lt;% java语句 %&gt;</code>（代码脚本）【定义局部变量，编写语句】<ul>
<li>代码脚本翻译之后都在_jspService 方法中</li>
<li>代码脚本由于翻译到_jspService()方法中，所以在jspService()方法中的现有对象都可以直接使用。</li>
<li>可以由多个代码脚本块组合完成一个完整的 java 语句。</li>
<li>java语句会在控制台输出。</li>
<li>如果没有&lt;% %&gt;，则会被认为是html文本，输出到页面上。</li>
</ul>
</li>
<li><code>&lt;%!声明java代码 %&gt;</code>（声明脚本）【定义类或⽅法，但是没⼈这样⽤！】</li>
<li><code>&lt;%=表达式 %&gt;</code>（表达式脚本）【输出各种类型的变量，int、double、String、Object等】<ul>
<li>表达式结果会在html页面上展示。</li>
<li>所有的表达式脚本都会被翻译到_jspService() 方法中_</li>
<li>表达式脚本都会被翻译成为 out.print()输出到页面上</li>
<li>由于表达式脚本翻译的内容都在_jspService() 方法中,所以jspService()方法中的对象都可以直接使用。</li>
<li>表达式脚本中的表达式不能以分号结束。</li>
</ul>
</li>
</ul>
<h2 id="2-jsp-内置对象"><a href="#2-jsp-内置对象" class="headerlink" title="2. jsp 内置对象"></a>2. jsp 内置对象</h2><p>JSP 的内置对象即：在jsp页面中不需要获取和创建，可以直接使用的对象</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>真实类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContext</td>
<td>当前页面共享数据，还可以获取其他八个内置对象</td>
</tr>
<tr>
<td>request</td>
<td>HttpServletRequest</td>
<td>一次请求访问的多个资源(转发)</td>
</tr>
<tr>
<td>session</td>
<td>HttpSession</td>
<td>一次会话的多个请求间</td>
</tr>
<tr>
<td>application</td>
<td>ServletContext</td>
<td>所有用户间共享数据</td>
</tr>
<tr>
<td>response</td>
<td>HttpServletResponse</td>
<td>响应对象</td>
</tr>
<tr>
<td>page</td>
<td>Object</td>
<td>当前页面(Servlet)的对象  this</td>
</tr>
<tr>
<td>out</td>
<td>JspWriter</td>
<td>输出对象，数据输出到页面上</td>
</tr>
<tr>
<td>config</td>
<td>ServletConfig</td>
<td>Servlet的配置对象</td>
</tr>
<tr>
<td>exception</td>
<td>Throwable</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h2 id="3-jsp-域对象"><a href="#3-jsp-域对象" class="headerlink" title="3. jsp 域对象"></a>3. jsp 域对象</h2><p>jsp的九大内置对象中有四个域对象：pageContext、request、session、application。</p>
<p>它们从小到大的顺序分别是：pageContext 、Request、Session 、application</p>
<p>使用的优先顺序是从小到大：pageContext 、Request、Session 、application</p>
<p>out和Response输出的区别。<br>    out输出都写到out缓冲区中，response输出都写到Respnse的缓冲区中</p>
<p>​    response.getWriter()数据输出永远在out.write()之前</p>
<p>当jsp页面中所有代码都执行完成之后。全做以下两个操作<br>1、执行out.flush()操作，把out缓冲区中的数据都追加到Response缓冲区中<br>2、执行Response的flush()操作。把Response缓冲区中的数据，都写给客户端。</p>
<p>在jsp页面中，统一使用out来进行输出。 </p>
<p>out.write()可以输出字符串<br>out.print()可以输出任意数据</p>
<h2 id="4-EL-表达式"><a href="#4-EL-表达式" class="headerlink" title="4. EL 表达式"></a>4. EL 表达式</h2><p>（1）概念：Expression Language 表达式语言</p>
<p>（2）作用：<u>代替 jsp 页面中的表达式脚本在 jsp 页面中进行数据的输出</u>。因为 EL 表达式在输出数据时比 jsp 的表达式脚本要简洁很多。</p>
<p>（3）语法：${表达式}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：jsp默认支持el表达式的。如果要忽略el表达式</span><br><span class="line">方式一：设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式</span><br><span class="line">方式二：\$&#123;表达式&#125; ：忽略当前这个el表达式</span><br></pre></td></tr></table></figure>

<p>（4）使用：</p>
<ul>
<li><p><u>运算</u></p>
<p>算数运算符： + - * &#x2F; %</p>
<p>比较运算符： &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; !&#x3D;</p>
<p>逻辑运算符： &amp;&amp;(and) ||(or) !(not)</p>
<p>空运算符： empty（用于判断字符串、集合、数组对象是否为null或者长度是否为0）</p>
<p>举例：${empty list}:判断字符串、集合、数组对象是否为null或者长度为0</p>
</li>
<li><p><u>获取值</u>（EL表达式只能从域对象中获取值）</p>
<ul>
<li><p>① ${域名称.键名}：从指定域中获取指定键的值</p>
<p>域名称：</p>
<p>​    pageScope        –&gt; pageContext</p>
<p>​    requestScope     –&gt; request</p>
<p>​    sessionScope     –&gt; session</p>
<p>​    applicationScope –&gt; application（ServletContext）</p>
<p>举例：在request域中存储了name&#x3D;张三，获取值：${requestScope.name}</p>
</li>
<li><p>②${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p>
</li>
<li><p>③获取对象、List集合、Map集合的值</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">对象：$&#123;域名称.键名.属性名&#125;（本质上会去调用对象的getter方法）</span><br><span class="line">List集合：$&#123;域名称.键名[索引]&#125;</span><br><span class="line">Map集合：$&#123;域名称.键名.key名称&#125;、$&#123;域名称.键名[<span class="string">&quot;key名称&quot;</span>]&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><u>隐式对象</u>：（EL表达式中有11个隐式对象）</p>
<ol>
<li>pageContext 对应于JSP⻚⾯中的pageContext对象（注意：取的是pageContext对象）</li>
<li>pageScope 代表page域中⽤于保存属性的Map对象</li>
<li>requestScope 代表request域中⽤于保存属性的Map对象</li>
<li>sessionScope 代表session域中⽤于保存属性的Map对象</li>
<li>applicationScope 代表application域中⽤于保存属性的Map对象</li>
<li>param 表示⼀个保存了所有请求参数的Map对象</li>
<li>paramValues表示⼀个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是⼀个string[]</li>
<li>header 表示⼀个保存了所有http请求头字段的Map对象</li>
<li>headerValues同上，返回string[]数组。</li>
<li>cookie 表示⼀个保存了所有cookie的Map对象</li>
<li>initParam 表示⼀个保存了所有web应⽤初始化参数的map对象</li>
</ol>
</li>
</ul>
<h2 id="5-JSTL-标签"><a href="#5-JSTL-标签" class="headerlink" title="5. JSTL 标签"></a>5. JSTL 标签</h2><p>（1）概念：JavaServer Pages Tag Library  JSP标准标签库（是由Apache组织提供的开源的免费的jsp标签）</p>
<p>（2）作用：EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。</p>
<p>（3）使用步骤：</p>
<p>​        ①导入jstl相关jar包</p>
<p>​        ②引入标签库：taglib指令：  &lt;%@ taglib %&gt;</p>
<p>​        ③使用标签</p>
<p>（4）常用的JSTL标签</p>
<ul>
<li><p>&lt;c:if &#x2F;&gt;:相当于java代码的if语句</p>
<ul>
<li><p>属性：</p>
<p>test 必须属性，接受boolean表达式，如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</p>
<p>一般情况下，test属性值会结合el表达式一起使用</p>
</li>
<li><p>注意：c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签</p>
</li>
</ul>
</li>
<li><p>&lt; c:choose&gt; &lt; c:when&gt; &lt; c:otherwise&gt;:相当于java代码的switch语句</p>
<ul>
<li>使用choose标签声明                     相当于switch声明</li>
<li>使用when标签做判断                     相当于case</li>
<li>使用otherwise标签做其他情况的声明        相当于default</li>
</ul>
</li>
<li><p>&lt;c:forEach &#x2F;&gt;:相当于java代码的for语句</p>
<ol>
<li>完成重复的操作<br>for(int i &#x3D; 0; i &lt; 10; i ++){}<ul>
<li>属性：<br>begin：开始值<br>end：结束值<br>var：临时变量<br>step：步长<br>varStatus:循环状态对象<br>index:容器中元素的索引，从0开始<br>count:循环次数，从1开始</li>
</ul>
</li>
<li>遍历容器<br>List&lt;User&gt; list;<br>for(User user : list){}<ul>
<li>属性：<br>items:容器对象<br>var:容器中元素的临时变量<br>varStatus:循环状态对象<br>index:容器中元素的索引，从0开始<br>count:循环次数，从1开始</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="十一-Listener"><a href="#十一-Listener" class="headerlink" title="十一. Listener"></a>十一. Listener</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote>
<p>web 的三大组件之一。（JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器。）</p>
<p>Listener 它是 JavaEE 的规范，就是接口。</p>
<p>监听器的作用是，<strong>监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。</strong></p>
</blockquote>
<h2 id="2-事件监听机制"><a href="#2-事件监听机制" class="headerlink" title="2. 事件监听机制"></a>2. 事件监听机制</h2><p>事件    ：一件事情</p>
<p>事件源 ：事件发生的地方</p>
<p>监听器 ：一个对象</p>
<p>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</p>
<h2 id="3-ServletContextListener-监听器"><a href="#3-ServletContextListener-监听器" class="headerlink" title="3. ServletContextListener 监听器"></a>3. ServletContextListener 监听器</h2><p>ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。</p>
<p>ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。</p>
<p>监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。</p>
<ul>
<li><p>方法：</p>
<ul>
<li>void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法</li>
<li>void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li><p>定义一个类，实现 ServletContextListener 接口</p>
</li>
<li><p>实现其两个回调方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ServletContext 对象被创建了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;ServletContext 对象被销毁了&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
</li>
</ol>
<p>  方式一：web.xml</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>全类名<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  方式二：注解：@WebListener</p>
</li>
</ul>
<h1 id="十二-Cookie"><a href="#十二-Cookie" class="headerlink" title="十二 Cookie"></a>十二 Cookie</h1><h2 id="1-名词解释-7"><a href="#1-名词解释-7" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><p><u>概念</u>：Cookie 是客户端会话技术，用于将数据保存到客户端，客户端有了 Cookie 后，<strong>每次请求都会将此 Cookie 中数据发送给服务器。</strong>浏览器对于单个cookie 的大小有限制(4kb) 以及对同一个域名下的总 cookie 数量也有限制(20个)</p>
<p><u>作用</u>：Cookie 可以在不登录的情况下，完成服务器对客户端的身份识别，比如用户在第二次登录一个页面时，可以记住用户的账号、密码等，用户就无需重新输入。</p>
<p>就像我们去超市买东西，没有积分卡的情况下，我们买完东西之后，超市没有我们的任何消费信息，但我们办了积分卡之后，超市就有了</p>
<p>我们的消费信息。cookie 就像是积分卡，可以保存积分，商品就是我们的信息，超市的系统就像服务器后台，http协议就是交易的过程。</p>
<h2 id="2-基本使用-1"><a href="#2-基本使用-1" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h2><ul>
<li>创建 Cookie 对象，绑定数据  new Cookie(String name, String value) </li>
<li>发送 Cookie 对象  response.addCookie(Cookie cookie) </li>
<li>获取 Cookie，拿到数据  Cookie[]  request.getCookies()</li>
</ul>
<p>注意：一次可以创建多个 Cookie 对象，使用 response 调用多次 addCookie 方法发送 cookie 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/cookieDemo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建Cookie对象</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">//2.发送Cookie</span></span><br><span class="line">        response.addCookie(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cookieDemo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">       <span class="comment">//3. 获取Cookie</span></span><br><span class="line">        Cookie[] cs = request.getCookies();</span><br><span class="line">        <span class="comment">//获取数据，遍历Cookies</span></span><br><span class="line">        <span class="keyword">if</span>(cs != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie c : cs) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> c.getName();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> c.getValue();</span><br><span class="line">                System.out.println(name+<span class="string">&quot;:&quot;</span>+value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先访问cookieDemo1，再访问cookieDemo2，可以获取cookieDemo1设置的cookie信息。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/JavaWeb/20220328153501.png" alt="img"></p>
<h2 id="3-Cookie-生命控制"><a href="#3-Cookie-生命控制" class="headerlink" title="3. Cookie 生命控制"></a>3. Cookie 生命控制</h2><p>cookie 在浏览器中保存时间：</p>
<ul>
<li>默认情况下，当浏览器关闭后，Cookie 数据被销毁</li>
<li>持久化存储：setMaxAge(int seconds)<ol>
<li>正数：将 Cookie 数据写到硬盘的文件中。持久化存储。并指定 cookie 存活时间，时间到后，cookie 文件自动失效</li>
<li>负数：默认值</li>
<li>零：删除 cookie 信息</li>
</ol>
</li>
</ul>
<h1 id="十三-Session"><a href="#十三-Session" class="headerlink" title="十三. Session"></a>十三. Session</h1><ol>
<li><p>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p>
</li>
<li><p>快速入门：</p>
</li>
<li><p>获取 HttpSession 对象：</p>
<p> <code>HttpSession session = request.getSession();</code></p>
<ol start="2">
<li>使用HttpSession对象：</li>
</ol>
<ul>
<li>Object getAttribute(String name) </li>
<li>void setAttribute(String name, Object value)</li>
<li>void removeAttribute(String name)</li>
</ul>
</li>
<li><p>原理</p>
</li>
</ol>
<ul>
<li>Session 的实现是依赖于 Cookie 的。</li>
</ul>
<ol start="4">
<li><p>细节：</p>
<ul>
<li><p>当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个？</p>
<ul>
<li><p>默认情况下。不是。</p>
</li>
<li><p>如果需要相同，则可以创建 Cookie，键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cookie</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;JSESSIONID&quot;</span>,session.getId());</span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">response.addCookie(c);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>客户端不关闭，服务器关闭后，两次获取的 session 是同一个吗？</p>
<ul>
<li>不是同一个，但是要确保数据不丢失。tomcat 自动完成以下工作<ul>
<li>session 的钝化：<ul>
<li>在服务器正常关闭之前，将session对象系列化到硬盘上</li>
</ul>
</li>
<li>session 的活化：<ul>
<li>在服务器启动后，将 session 文件转化为内存中的 session 对象即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>session 什么时候被销毁？</p>
<ol>
<li><p>服务器关闭</p>
</li>
<li><p>session 对象调用 invalidate() 。</p>
</li>
<li><p>session 默认失效时间 30分钟<br>选择性配置修改    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>session 的特点</p>
<ol>
<li>session 用于存储一次会话的多次请求的数据，存在服务器端</li>
<li>session 可以存储任意类型，任意大小的数据</li>
</ol>
</li>
<li><p><strong>session 与 Cookie 的区别：</strong></p>
</li>
<li><p>session存储数据在服务器端，Cookie在客户端</p>
</li>
<li><p>session 没有数据大小限制，Cookie有</p>
</li>
<li><p>session 数据安全，Cookie相对于不安全</p>
</li>
</ol>
<h1 id="十四-Filter"><a href="#十四-Filter" class="headerlink" title="十四. Filter"></a>十四. Filter</h1><ol>
<li>概念：</li>
</ol>
<ul>
<li>生活中的过滤器：净水器,空气净化器，土匪、</li>
<li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li>
<li>过滤器的作用：一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li>
</ul>
<ol start="2">
<li>快速入门：</li>
</ol>
<ul>
<li><p>步骤：</p>
<ul>
<li>定义一个类，实现接口 Filter</li>
<li>复写方法</li>
<li>配置拦截路径  使用web.xml &#x2F; 注解</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span><span class="comment">//访问所有资源之前，都会执行该过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterDemo1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    	 System.out.println(<span class="string">&quot;filterDemo1被执行了....&quot;</span>);</span><br><span class="line">      	 <span class="comment">//放行</span></span><br><span class="line">		 filterChain.doFilter(servletRequest,servletResponse);	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>过滤器细节：</li>
</ol>
<ul>
<li><p>web.xml配置    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.web.filter.FilterDemo1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤器执行流程</p>
<ol>
<li>执行过滤器</li>
<li>执行放行后的资源</li>
<li>回来执行过滤器放行代码下边的代码</li>
</ol>
</li>
<li><p>过滤器生命周期方法</p>
<ul>
<li>init：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</li>
<li><code>doFilter</code>：每一次请求被拦截资源时，会执行。执行多次</li>
<li>destroy：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</li>
</ul>
</li>
<li><p>过滤器配置详解</p>
<ul>
<li><p>拦截路径配置：</p>
<ol>
<li>具体资源路径： &#x2F;index.jsp   只有访问index.jsp资源时，过滤器才会被执行</li>
<li>拦截目录： &#x2F;user&#x2F;*    访问&#x2F;user下的所有资源时，过滤器都会被执行</li>
<li>后缀名拦截： *.jsp        访问所有后缀名为jsp资源时，过滤器都会被执行</li>
<li>拦截所有资源：&#x2F;*        访问所有资源时，过滤器都会被执行</li>
</ol>
</li>
<li><p>拦截方式配置：资源被访问的方式</p>
<ul>
<li><p>注解配置：</p>
<p>设置 dispatcherTypes 属性</p>
<ol>
<li>REQUEST：默认值。浏览器直接请求资源</li>
<li>FORWARD：转发访问资源</li>
<li>INCLUDE：包含访问资源</li>
<li>ERROR：错误跳转资源</li>
<li>ASYNC：异步访问资源</li>
</ol>
</li>
<li><p>web.xml 配置</p>
<p>设置&lt;dispatcher&gt;&lt;&#x2F;dispatcher&gt;标签即可</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>过滤器链(配置多个过滤器)</p>
<ul>
<li><p>执行顺序：如果有两个过滤器：过滤器1和过滤器2</p>
<p>过滤器1–&gt;过滤器2–&gt;资源执行–&gt;过滤器2–&gt;过滤器1 </p>
</li>
<li><p>过滤器先后顺序问题：</p>
<ul>
<li>注解配置：按照类名的字符串比较规则比较，值小的先执行<ul>
<li>如： AFilter 和 BFilter，AFilter就先执行了。</li>
</ul>
</li>
<li>web.xml配置： &lt;filter-mapping&gt;谁定义在上边，谁先执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="十五-AJAX"><a href="#十五-AJAX" class="headerlink" title="十五. AJAX"></a>十五. AJAX</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>ASynchronous JavaScript And XML：异步的 JavaScript 和 XML</p>
<p>异步和同步：客户端和服务器端相互通信的基础上</p>
<ul>
<li>同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。</li>
<li>异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。：</li>
</ul>
<p><strong>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术（局部刷新）</strong></p>
<p>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现<strong>异步更新</strong>。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。</p>
<h2 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h2><ul>
<li>原生的JS实现方式（了解）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建核心对象</span></span><br><span class="line">      <span class="keyword">var</span> xmlhttp;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>)</span><br><span class="line">      &#123;<span class="comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">          xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;<span class="comment">// code for IE6, IE5</span></span><br><span class="line">          xmlhttp=<span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 2. 建立连接</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">      参数：</span></span><br><span class="line"><span class="comment">          1. 请求方式：GET、POST</span></span><br><span class="line"><span class="comment">              * get方式，请求参数在URL后边拼接。send方法为空参</span></span><br><span class="line"><span class="comment">              * post方式，请求参数在send方法中定义</span></span><br><span class="line"><span class="comment">          2. 请求的URL：</span></span><br><span class="line"><span class="comment">          3. 同步或异步请求：true（异步）或 false（同步）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajaxServlet?username=tom&quot;</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.发送请求</span></span><br><span class="line">  xmlhttp.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.接受并处理来自服务器的响应结果</span></span><br><span class="line">  <span class="comment">// 获取方式 ：xmlhttp.responseText</span></span><br><span class="line">  <span class="comment">// 什么时候获取？当服务器响应成功后再获取</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span></span><br><span class="line">  xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 判断readyState就绪状态是否为4，判断status响应状态码是否为200</span></span><br><span class="line">      <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span>==<span class="number">200</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// 获取服务器的响应结果</span></span><br><span class="line">          <span class="keyword">var</span> responseText = xmlhttp.<span class="property">responseText</span>;</span><br><span class="line">          <span class="title function_">alert</span>(responseText);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>JQeury 实现方式</li>
</ul>
<ol>
<li><u>$.ajax()</u></li>
</ol>
<ul>
<li>语法：<code>$.ajax(&#123;键值对&#125;)</code>;</li>
</ul>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用$.ajax()发送异步请求</span></span><br><span class="line">   $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">       <span class="attr">url</span>:<span class="string">&quot;ajaxServlet1111&quot;</span> , <span class="comment">// 请求路径</span></span><br><span class="line">       <span class="attr">type</span>:<span class="string">&quot;POST&quot;</span> , <span class="comment">// 请求方式</span></span><br><span class="line">       <span class="comment">//data: &quot;username=jack&amp;age=23&quot;,// 请求参数</span></span><br><span class="line">       <span class="attr">data</span>:&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>&#125;,</span><br><span class="line">       <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">           <span class="title function_">alert</span>(data);</span><br><span class="line">       &#125;,<span class="comment">// 响应成功后的回调函数</span></span><br><span class="line">       <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">alert</span>(<span class="string">&quot;出错啦...&quot;</span>)</span><br><span class="line">       &#125;,<span class="comment">// 表示如果请求响应出现错误，会执行的回调函数</span></span><br><span class="line">	   <span class="attr">dataType</span>:<span class="string">&quot;text&quot;</span><span class="comment">// 设置接受到的响应数据的格式</span></span><br><span class="line">	 &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><u>$.get()</u>：发送get请求</li>
</ol>
<ul>
<li>语法：<code>$.get(url, [data], [callback], [type])</code><ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应结果的类型</li>
</ul>
</li>
</ul>
<ol start="3">
<li><u>$.post()</u>：发送post请求</li>
</ol>
<ul>
<li>语法：<code>$.post(url, [data], [callback], [type])</code><ul>
<li>url：请求路径</li>
<li>data：请求参数</li>
<li>callback：回调函数</li>
<li>type：响应结果的类型</li>
</ul>
</li>
</ul>
<h1 id="十六-JSON"><a href="#十六-JSON" class="headerlink" title="十六. JSON"></a>十六. JSON</h1><h2 id="1-名词解释-8"><a href="#1-名词解释-8" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><blockquote>
<p>JSON：JavaScript 对象表示法（JavaScript Object Notation）。 JSON 是存储和交换文本信息的语法。类似 XML。但比 XML 更小、更快，更易解析。</p>
</blockquote>
<h2 id="2-基本语法-1"><a href="#2-基本语法-1" class="headerlink" title="2. 基本语法"></a>2. 基本语法</h2><p><u>基本规则</u>：</p>
<ul>
<li>数据在名称&#x2F;值对中：json数据是由键值对构成的<ul>
<li>键用引号(单双都行)引起来，也可以不使用引号</li>
<li>值得取值类型：<ol>
<li>数字（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在方括号中）    {“persons”:[{},{}]}</li>
<li>对象（在花括号中） {“address”:{“province”：”陕西”….}}</li>
<li>null</li>
</ol>
</li>
</ul>
</li>
<li>数据由逗号分隔：多个键值对由逗号分隔</li>
<li>花括号保存对象：使用{}定义json 格式</li>
<li>方括号保存数组：[]</li>
<li>示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;book&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>:<span class="string">&quot;01&quot;</span>,</span><br><span class="line">            <span class="string">&quot;language&quot;</span>: <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">            <span class="string">&quot;edition&quot;</span>: <span class="string">&quot;third&quot;</span>,</span><br><span class="line">            <span class="string">&quot;author&quot;</span>: <span class="string">&quot;Herbert Schildt&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>:<span class="string">&quot;07&quot;</span>,</span><br><span class="line">            <span class="string">&quot;language&quot;</span>: <span class="string">&quot;C++&quot;</span>,</span><br><span class="line">            <span class="string">&quot;edition&quot;</span>: <span class="string">&quot;second&quot;</span></span><br><span class="line">            <span class="string">&quot;author&quot;</span>: <span class="string">&quot;E.Balagurusamy&quot;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>获取数据</u>:</p>
<ol>
<li>json对象.键名</li>
<li>json对象[“键名”]</li>
<li>数组对象[索引]</li>
<li>遍历</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义基本格式</span></span><br><span class="line">     <span class="keyword">var</span> person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>, <span class="string">&#x27;gender&#x27;</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">//获取name的值</span></span><br><span class="line">	<span class="keyword">var</span> name = person.<span class="property">name</span>;  <span class="comment">//json对象.键名</span></span><br><span class="line">	<span class="keyword">var</span> name = person[<span class="string">&quot;name&quot;</span>];<span class="comment">//json对象[&quot;键名&quot;]</span></span><br><span class="line"><span class="comment">//2.嵌套格式   &#123;&#125;———&gt; []</span></span><br><span class="line">    <span class="keyword">var</span> persons = &#123;</span><br><span class="line">        <span class="string">&quot;persons&quot;</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">24</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">false</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//获取王五值</span></span><br><span class="line">    <span class="keyword">var</span> name1 = persons.<span class="property">persons</span>[<span class="number">2</span>].<span class="property">name</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.嵌套格式   []———&gt; &#123;&#125;</span></span><br><span class="line">    <span class="keyword">var</span> ps = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">              &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">24</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">              &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">false</span>&#125;];</span><br><span class="line">    <span class="comment">//获取李四值</span></span><br><span class="line">	<span class="keyword">var</span> name2 = ps[<span class="number">1</span>].<span class="property">name</span>;	</span><br><span class="line"><span class="comment">//4.遍历操作</span></span><br><span class="line">    <span class="keyword">var</span> ps = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">23</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">              &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">24</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">              &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>, <span class="string">&quot;gender&quot;</span>: <span class="literal">false</span>&#125;];</span><br><span class="line">	<span class="comment">//获取person对象中所有的键和值</span></span><br><span class="line">    <span class="comment">//for in 循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> person)&#123;</span><br><span class="line">        <span class="comment">//这样的方式获取不行。因为相当于  person.&quot;name&quot;</span></span><br><span class="line">        <span class="comment">//alert(key + &quot;:&quot; + person.key);</span></span><br><span class="line">        <span class="title function_">alert</span>(key+<span class="string">&quot;:&quot;</span>+person[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取ps中的所有值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> p = ps[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> p)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(key+<span class="string">&quot;:&quot;</span>+p[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-JSON数据和Java对象的相互转换-Jackson"><a href="#3-JSON数据和Java对象的相互转换-Jackson" class="headerlink" title="3. JSON数据和Java对象的相互转换(Jackson)"></a>3. JSON数据和Java对象的相互转换(Jackson)</h2><p>JSON解析器：Jsonlib，Gson，fastjson，jackson……</p>
<h3 id="（1）JSON转为Java对象"><a href="#（1）JSON转为Java对象" class="headerlink" title="（1）JSON转为Java对象"></a>（1）JSON转为Java对象</h3><ul>
<li>导入 jackson 的相关 jar 包</li>
<li>创建 Jackson 核心对象 ObjectMapper</li>
<li>调用 ObjectMappe r的相关方法进行转换：<code>readValue(json字符串数据,Class)</code>;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objectToJson</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.Json数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">Json</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;score\&quot;:98,\&quot;gender\&quot;:\&quot;男\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的readValue方法将Json数据转换为java对象</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> objectMapper.readValue(Json, Student.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出转换的java对象</span></span><br><span class="line">    System.out.println(student);<span class="comment">//Student&#123;name=&#x27;张三&#x27;, score=98, gender=&#x27;男&#x27;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）Java-对象转换-JSON"><a href="#（2）Java-对象转换-JSON" class="headerlink" title="（2）Java 对象转换 JSON"></a>（2）Java 对象转换 JSON</h3><ul>
<li>导入 jackson 的相关jar包</li>
<li>创建 Jackson 核心对象 ObjectMapper</li>
<li>调用 ObjectMapper 的相关方法进行转换<ul>
<li>转换方法：<ul>
<li><code>writeValue(参数1，obj)</code>:<br>参数1：<br>    File：将obj对象转换为JSON字符串，并保存到指定的文件中<br>    Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中<br>    OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</li>
<li><code>writeValueAsString(obj)</code>：将对象转为json字符串</li>
</ul>
</li>
<li>注解：<ul>
<li>@JsonIgnore：排除属性。</li>
<li>@JsonFormat：属性值格式化。举例：@JsonFormat(pattern &#x3D; “yyyy-MM-dd”)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jsonToObject</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//1.java对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的writeValueAsString方法将java对象转换为Json数据</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(student);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出转换的Json数据</span></span><br><span class="line">    System.out.println(json);<span class="comment">//&#123;&quot;name&quot;:&quot;李四&quot;,&quot;score&quot;:80,&quot;gender&quot;:&quot;男&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）复杂-Java-对象和-JSON-的相互转换"><a href="#（3）复杂-Java-对象和-JSON-的相互转换" class="headerlink" title="（3）复杂 Java 对象和 JSON 的相互转换"></a>（3）复杂 Java 对象和 JSON 的相互转换</h3><ul>
<li><u>List：数组</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将list集合转换为Json数组【注意只有list转换后是json数组，其他转换是json对象】</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listToJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//1.list对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">88</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">96</span>,<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(s1);</span><br><span class="line">    list.add(s2);</span><br><span class="line">    list.add(s3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的writeValueAsString方法</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出转换结果</span></span><br><span class="line">    System.out.println(json);<span class="comment">//[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;score&quot;:80,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;王二&quot;,&quot;score&quot;:88,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;小花&quot;,&quot;score&quot;:96,&quot;gender&quot;:&quot;女&quot;&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将Json数组转换为List集合</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jsonToList</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.json数组</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;[&#123;\&quot;name\&quot;:\&quot;李四\&quot;,\&quot;score\&quot;:80,\&quot;gender\&quot;:\&quot;男\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;王二\&quot;,\&quot;score\&quot;:88,\&quot;gender\&quot;:\&quot;男\&quot;&#125;,&#123;\&quot;name\&quot;:\&quot;小花\&quot;,\&quot;score\&quot;:96,\&quot;gender\&quot;:\&quot;女\&quot;&#125;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的readValue方法</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    List&lt;Student&gt; list = objectMapper.readValue(json,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;Student&gt;&gt;() &#123; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出结果</span></span><br><span class="line">    Iterator&lt;Student&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*控制台输出结果</span></span><br><span class="line"><span class="comment">    Student&#123;name=&#x27;李四&#x27;, score=80, gender=&#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="comment">    Student&#123;name=&#x27;王二&#x27;, score=88, gender=&#x27;男&#x27;&#125;</span></span><br><span class="line"><span class="comment">    Student&#123;name=&#x27;小花&#x27;, score=96, gender=&#x27;女&#x27;&#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><u>Map：对象格式一致</u></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map转换为json数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mapToJson</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">//1.map对象</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;score&quot;</span>,<span class="number">50</span>);</span><br><span class="line">    map.put(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的writeValueAsString方法</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> objectMapper.writeValueAsString(map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出转换结果</span></span><br><span class="line">    System.out.println(json);<span class="comment">//&#123;&quot;score&quot;:50,&quot;gender&quot;:&quot;男&quot;,&quot;name&quot;:&quot;小明&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//json数据转换为map</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jsonToMap</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.json数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span><span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;张三\&quot;,\&quot;score\&quot;:98,\&quot;gender\&quot;:\&quot;男\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.使用objectMapper的readValue方法</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> objectMapper.readValue(json, Map.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.输出map结果</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="keyword">for</span> (Object obj:set)&#123;</span><br><span class="line">        System.out.println(obj + <span class="string">&quot;=&quot;</span> + map.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*控制台结果为：</span></span><br><span class="line"><span class="comment">    name=张三</span></span><br><span class="line"><span class="comment">    score=98</span></span><br><span class="line"><span class="comment">    gender=男 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础知识</title>
    <url>/2022/02/16/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一-Java-开发环境"><a href="#一-Java-开发环境" class="headerlink" title="一. Java 开发环境"></a>一. Java 开发环境</h1><ol>
<li><p><code>JVM</code>（Java Virtual Machine）java 虚拟机</p>
<p>主要负责将Java程序经过编译之后生成的和平台无关的字节码文件解释成具体的平台能够识别的机器指令。</p>
</li>
<li><p><code>JRE</code>（Java Runtime Environment）Java 运行环境</p>
<p>JRE &#x3D; JVM +  Java程序执行所需要的核心类库。</p>
<span id="more"></span>
</li>
<li><p><code>JDK</code>（Java Development Kit）Java 开发工具包<br>JDK &#x3D; JRE + 开发工具（java、javac…）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162329.png" style="zoom: 50%;" /></li>
</ol>
<blockquote>
<p>JVM 是整个 java 实现跨平台的最核心的部分，但是只有 JVM 并不能运行程序；</p>
<p>如果想要运行一个 Java 程序，可以只安装 JRE，不安装 JDK；</p>
<p>如果想要开发一个 Java 程序 ，必须安装 JDK；</p>
</blockquote>
<h1 id="二-Java-语法规范"><a href="#二-Java-语法规范" class="headerlink" title="二. Java 语法规范"></a>二. Java 语法规范</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<h2 id="2-Java-关键字"><a href="#2-Java-关键字" class="headerlink" title="2. Java 关键字"></a>2. Java 关键字</h2><blockquote>
<p>关键字 ：是指在程序中，Java 已经定义好的单词，具有特殊含义。如 public、class、int 等等（关键字中所有字母都为小写）。</p>
</blockquote>
<h2 id="3-Java-标识符"><a href="#3-Java-标识符" class="headerlink" title="3. Java 标识符"></a>3. Java 标识符</h2><blockquote>
<p>标识符：程序中的我们给类、变量以及方法所起的名字。</p>
</blockquote>
<p>Java中的类、变量、方法的名称不是随便都可以起的，需要满足一些<strong>规则</strong>：</p>
<p>​    ① 标识符可以包含名称只能由字母、数字、下划线、$ 符号 。</p>
<p>​    ② 所有的标识符都应该名称只能由字母、下划线、$ 符号开头，不能以数字开头。</p>
<p>​    ③ 标识符不能是关键字。</p>
<p>为了使得程序的可读性更好，一般编写Java程序时，也要满足一定的<strong>规范</strong>：</p>
<p>​    ① <u>类名</u>建议采用大驼峰式（首字母大写，后面每个单词首字母大写）。</p>
<p>​    ② <u>方法名和变量名</u>建议采用小驼峰式（首字母小写，后面每个单词首字母大写）。</p>
<p>​    ③ <u>常量名</u>建议全部大写，单词之间用下划线分割。</p>
<p>​    ④ <u>包名、模块名、项目名</u>建议所有字母都小写。</p>
<h2 id="4-Java-编程的注意事项"><a href="#4-Java-编程的注意事项" class="headerlink" title="4. Java 编程的注意事项"></a>4. Java 编程的注意事项</h2><ul>
<li>Java 是大小写敏感的。</li>
<li><strong>源文件名必须和类名相同</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li>所有的 Java 程序由 public static void main(String[] args) 方法开始执行。</li>
</ul>
<h1 id="三-Java-基础语法"><a href="#三-Java-基础语法" class="headerlink" title="三. Java 基础语法"></a>三. Java 基础语法</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><blockquote>
<p>单行注释: 以 &#x2F;&#x2F; 开头 换行结束<br>多行注释: 以 &#x2F;* 表示注释开始 ， 以*&#x2F;表示注释结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">   一个</span></span><br><span class="line"><span class="comment">   多行</span></span><br><span class="line"><span class="comment">   注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>Java 数据类型分为两大类。</p>
<p><u>① 基本类型（4 类 8 种）</u></p>
<ul>
<li>整数型（byte、short、int、long）</li>
<li>浮点型（float double）</li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用&#x2F;字节</th>
<th align="center">取值范围</th>
<th align="center">最小值符号</th>
<th align="center">最大值符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128 ~ +127</td>
<td align="center">Byte.MIN_VALUE</td>
<td align="center">Byte.MAX_VALUE</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768 ~ +32767</td>
<td align="center">Short.MIN_VALUE</td>
<td align="center">Short.MAX_VALUE</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1（超过20亿）</td>
<td align="center">Integer.MIN_VALUE</td>
<td align="center">Integer.MAX_VALUE</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-2^63 ~ 2^63-1</td>
<td align="center">Long.MIN_VALUE</td>
<td align="center">Long.MAX_VALUE</td>
</tr>
<tr>
<td align="center">单精度浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">1.4E-45 ~ 3.4028235E38（有效位数6~7位）</td>
<td align="center">Float.MIN_VALUE</td>
<td align="center">Float.MAX_VALUE</td>
</tr>
<tr>
<td align="center">双精度浮点型</td>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">4.9E-324~1.7977E+308（有效位数15位）</td>
<td align="center">Double.MIN_VALUE</td>
<td align="center">Double.MAX_VALUE</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">0 ~ 65535</td>
<td align="center">Character.MIN_VALUE</td>
<td align="center">Character.MAX_VALUE</td>
</tr>
<tr>
<td align="center">布尔型</td>
<td align="center">Boolean</td>
<td align="center">1</td>
<td align="center">true、false</td>
<td align="center">*</td>
<td align="center">*</td>
</tr>
</tbody></table>
<p><strong>Java 没有任何无符号 (unsigned) 形式的 int、long、short 或 byte 类型，但可以通过其包装类转换得到。</strong></p>
<p>基本数据类型必须进行初始化，没有默认值。</p>
<p>基本类型之间可以进行转换，分为自动类型转换和强制类型转换。</p>
<ul>
<li><p><code>自动类型转换</code>（将容量小的数据类型转换为容量大的数据类型）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162400.png" style="zoom: 75%;" />

<p>注意：</p>
<ul>
<li><input disabled="" type="checkbox"> 不能对 boolean 类型进行类型转换。</li>
<li><input disabled="" type="checkbox"> <strong>byte,short,char 之间不会相互转换，他们三者在计算时首先转换为int类型。</strong></li>
<li><input disabled="" type="checkbox"> 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串(String) 类型。</li>
</ul>
</li>
<li><p><code>强制类型转换</code>（将容量大的数据类型转换为容量小的数据类型）</p>
<p>格式：级别低的数据类型  变量名 &#x3D; (级别低的数据类型) 级别高的数据类型;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">如：<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10.5</span>；<span class="comment">// 结果为 10，直接砍掉小数部分。</span></span><br></pre></td></tr></table></figure>

<p>注意：强制类型转换可能造成精度降低或溢出</p>
</li>
</ul>
<p><u>② 引用类型</u></p>
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（array）</li>
</ul>
<h2 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h2><blockquote>
<p>常量是在程序运行时不能被修改的量。通常使用大写字母表示常量。</p>
<p>在 Java 中，利用关键字 final 指示常量，比如 final int a &#x3D; 10;</p>
</blockquote>
<ul>
<li><p>整数常量</p>
<p>十进制： 正常的写法，如 5，-125 等。</p>
<p>二进制： 在数字前面加前缀 0B 或 0b，如 0B11，0B110等。</p>
<p>八进制： 在数字前面加前缀 0，如 05，01等。</p>
<p>十六进制： 在数字前面加前缀 0x 或 0X，如 0XA，0x3等。</p>
</li>
<li><p>浮点数常量：如 0.1，10.8等等。</p>
</li>
<li><p>字符常量： 如 ‘A’，’C’ 等。</p>
</li>
<li><p>字符串常量： 如 “zhang”,”A” 等。</p>
</li>
<li><p>布尔常量： 只有 true 和 false。</p>
</li>
<li><p>空常量： null。</p>
</li>
</ul>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><blockquote>
<p>变量是在程序运行时能被修改的量。通常变量名采用小驼峰式（首字母小写，后面每个单词首字母大写）。</p>
</blockquote>
<p>变量的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则：数据类型 变量名;</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>变量的初始化一般有两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  第一种变量赋值方法，在声明的时候直接赋值。</span></span><br><span class="line"><span class="comment">	规则：数据类型 变量名 = 要赋的值;	*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>；</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  第二种变量赋值方法，先声明，后赋值。</span></span><br><span class="line"><span class="comment">	规则：数据类型 变量名;</span></span><br><span class="line"><span class="comment">		 变量名 = 要赋的值;	*/</span></span><br><span class="line"><span class="type">int</span> a;  </span><br><span class="line">a = <span class="number">10</span>;    </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 整数默认为 int 类型，如果需要的数据类型是 long，那么需要在数据后加后缀 L 或 l，如 long a &#x3D; 10L;</li>
<li><input checked="" disabled="" type="checkbox"> 浮点数默认为 double 类型，如果需要的数据类型是 float，那么需要在数据后加后缀 F 或 f，如 float a &#x3D; 0.5F;</li>
<li><input checked="" disabled="" type="checkbox"> 变量未赋值时不可使用；</li>
<li><input checked="" disabled="" type="checkbox"> 不可重复定义变量。</li>
<li><input checked="" disabled="" type="checkbox"> 从Java 10 开始，对于<u>局部变量</u>，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字 var 而无需指定类型，比如：var vacationDays &#x3D;12; 整型</li>
</ul>
<h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h2><p><strong>① 运算符的分类</strong></p>
<ul>
<li><p>算数运算符（+、-、*、&#x2F;、%、++、–）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：整数除法的结果仍然会是整数，规则是直接砍掉小数取整，而不是四舍五入。*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符（&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意：关系运算符用于比较两个数据的大小，结果会产生一个布尔（boolean）值。如果关系为真，则结果为 true，如果关系为假，则结果为false。*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符（&amp;&amp;、||、!）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注意：逻辑运算符的运算结果只能是一个布尔值（true/false）; &amp;&amp; 和 || 具有短路现象，</span></span><br><span class="line"><span class="comment">当&amp;&amp;时，如果第一个表达式已经为false，不管第二个表达式为true/false，结果一定为false ，此时第二个表达式将不会再执行。</span></span><br><span class="line"><span class="comment">当||时，如果第一个表达式已经为true，不管第二个表达式为true/false，结果一定为true，此时第二个表达式将不会再执行。*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (<span class="number">3</span>&gt;<span class="number">5</span>) &amp;&amp; (++a == <span class="number">6</span> )</span><br><span class="line">    System.out.println(a);<span class="comment">//由于短路现象，++a表达式并没有被执行，因此输出结果为5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符（也称三目运算符）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  条件运算符语法规则： 数据类型 变量名 = 布尔表达式？结果1:结果2;</span></span><br><span class="line"><span class="comment"> 	条件运算符含义：如果布尔表达式为true，则执行变量名=结果1，否则执行变量名=结果2。  */</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> a &lt; b ? a : b;<span class="comment">//因为a&lt;b为真，故将执行结果1，即num=a，则可得结果为num=2</span></span><br><span class="line"><span class="comment">/*条件运算符相比于if else语句更加简洁，且执行效率更高，但运算完必须要有一个结果。而if else运算完不需要一个结果。比如三元运算符内不能单独列出输出表达式。凡是可以使用三元运算符的地方，都可以改写为if-else；反之，不成立。*/</span></span><br><span class="line"><span class="keyword">if</span> (num  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num是正数&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num是负数&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//不能使用条件运算符代替</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值运算符（&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* a + = b; 等价于  a = a + b ;  */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算符（&amp;、|、~、^、&lt;&lt;、&gt;&gt;）</p>
</li>
</ul>
<p><strong>② 运算符的优先级</strong>（算、关、逻、条、赋）</p>
<h2 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6. 流程控制"></a>6. 流程控制</h2><h3 id="（1）顺序结构"><a href="#（1）顺序结构" class="headerlink" title="（1）顺序结构"></a>（1）顺序结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顺序执行，即根据编写的顺序，从上到下运行，没有跳转。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）选择结构"><a href="#（2）选择结构" class="headerlink" title="（2）选择结构"></a>（2）选择结构</h3><ul>
<li><p>if 选择结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种：if，如果布尔表达式为真，则执行语句体，否则不执行。</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 第二种：if-else，如果布尔表达式为真，则执行语句体1，否则执行语句体2.</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 第三种：if—else if—...-else</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 选择结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> 常量n:</span><br><span class="line">		语句体n;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case 标签可以为：</p>
<ul>
<li>类型为 char、byte、short、或 int 的常量表达式</li>
<li>枚举常量</li>
<li>从Java 7开始，还可以是字符串字面量。</li>
</ul>
</li>
</ul>
<h3 id="（3）循环结构"><a href="#（3）循环结构" class="headerlink" title="（3）循环结构"></a>（3）循环结构</h3><ul>
<li><p><code>for </code>循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">for(初始化表达式①;布尔表达式②;递进表达式③)&#123;</span></span><br><span class="line"><span class="comment">	循环体④;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	执行顺序：①②④③-②④③-②④③-...</span></span><br><span class="line"><span class="comment">	当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span>+sum);<span class="comment">// 1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while </code>循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(布尔表达式)&#123;</span></span><br><span class="line"><span class="comment">	循环体;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span> + sum);<span class="comment">// 1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do while</code> 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do&#123;</span></span><br><span class="line"><span class="comment">	循环体;</span></span><br><span class="line"><span class="comment">&#125;while(布尔表达式);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	do while中的循环体至少执行一次；</span></span><br><span class="line"><span class="comment">	当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span> + sum);<span class="comment">//1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>break </code> 和 <code>continue</code></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> break 和 continue 均为循环控制语句；</li>
<li><input checked="" disabled="" type="checkbox"> break 用于终止当前整个循环；</li>
<li><input checked="" disabled="" type="checkbox"> continue 用于跳出本次循环，转而去判断是否需要执行下次循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：计算2+4+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( i % <span class="number">2</span>!=<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2+4+..+100的结果为：&quot;</span> + sum);<span class="comment">//2+4+..+100的结果为：2550</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h2><blockquote>
<p>数组是一组有序的具有相同数据类型的元素序列。</p>
</blockquote>
<p><strong>数组的特点：</strong></p>
<ul>
<li>数组是一种引用数据类型；</li>
<li>数组当中的多个数据，类型必须统一；</li>
<li>数组的长度一旦指定，不可更改。</li>
</ul>
<p><strong>数组的初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★一维数组：</span></span><br><span class="line"><span class="comment">1.动态初始化（指定长度）：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = new 数组存储的数据类型[长度];</span></span><br><span class="line"><span class="comment">	格式说明：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型：创建的数组中要存储的数据类型，可以是基本数据类型，也可以是引用数据类型。</span></span><br><span class="line"><span class="comment">		[] : 表示定义的是数组。</span></span><br><span class="line"><span class="comment">		数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字来操作数组，数组的命名一般使用小驼峰式。</span></span><br><span class="line"><span class="comment">		new ：关键字，创建数组使用的关键字。</span></span><br><span class="line"><span class="comment">		[长度]：数组的长度，表示数组中可以存储多少个元素。</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] array = new int[10];</span></span><br><span class="line"><span class="comment">2.静态初始化（指定内容）：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;//静态定义的标准格式</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;; //静态定义的省略格式</span></span><br><span class="line"><span class="comment">	格式说明：</span></span><br><span class="line"><span class="comment">		&#123;&#125;中是数组中想要存储的元素，在定义数组的同时，对数组进行了初始化。</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] array = new int[]&#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">★二维数组：（二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组）</span></span><br><span class="line"><span class="comment">1.动态初始化</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = new 数组存储的数据类型[行数][【列数】];</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		String[][] array = new String[3][2];//二维数组中有3个一维数组，每一个一维数组中有2个元素</span></span><br><span class="line"><span class="comment">		String[][] arr = new String[3][];//只定义行数，然后可以自行定义每一行的列数，不必都是规则矩阵形式</span></span><br><span class="line"><span class="comment">		arr[0] = new String[3]; arr[1] = new String[1]; arr[2] = new String[2];</span></span><br><span class="line"><span class="comment">2.静态初始化</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = new 数据类型&#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;.....&#125;;</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = &#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;.....&#125;;</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] arr4[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="comment">		int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的使用：</strong></p>
<p>数组元素的引用方式：数组名[数组元素下标]；</p>
<ul>
<li>数组元素下标（也称为索引）从 0 开始；长度为 n 的数组合法下标取值范围: 0~n-1；</li>
<li>数组的长度：通过使用【数组名 .length】 可以获取数组的长度；</li>
<li>数组名是该数组所在内存的地址值；</li>
<li>new 出来的东西在内存的堆区；</li>
<li><strong>数组如果没有初始化，会有默认值（数字默认全为0，boolen默认为false）</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：定义一个数组，存放1,2,3,4,5，并将数组元素遍历打印。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组中的元素为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>+array[i]);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-Java-面向对象"><a href="#四-Java-面向对象" class="headerlink" title="四. Java 面向对象"></a>四. Java 面向对象</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><h3 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a><strong>（1）基本概念</strong></h3><ul>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li>
<li><strong>属性</strong> ：一个类的状态信息，对应类中的成员变量。</li>
<li><strong>行为</strong> ：一个类能够做什么，对应类中的成员方法</li>
</ul>
<h3 id="（2）类的定义"><a href="#（2）类的定义" class="headerlink" title="（2）类的定义"></a><strong>（2）类的定义</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 class 类名&#123;</span></span><br><span class="line"><span class="comment">		成员变量;//即类的属性</span></span><br><span class="line"><span class="comment">    	成员方法;//即类的行为</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	1. 定义类（考虑修饰符、类名）</span></span><br><span class="line"><span class="comment">	2. 编写类的成员变量（考虑修饰符、变量类型、变量名、初始化值）</span></span><br><span class="line"><span class="comment">	3. 编写类的成员方法（考虑修饰符、返回值类型、方法名、形参等）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建学生类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;我是：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）对象的创建与使用"><a href="#（3）对象的创建与使用" class="headerlink" title="（3）对象的创建与使用"></a><strong>（3）对象的创建与使用</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建对象：</span></span><br><span class="line"><span class="comment">	类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">使用对象访问类中的成员:</span></span><br><span class="line"><span class="comment">	对象名.成员变量;</span></span><br><span class="line"><span class="comment">	对象名.成员方法();</span></span><br><span class="line"><span class="comment">匿名对象：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		new 类名();（不定义对象的句柄，而直接调用这个对象的方法）</span></span><br><span class="line"><span class="comment">	使用情况：</span></span><br><span class="line"><span class="comment">		①如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</span></span><br><span class="line"><span class="comment">		②我们经常将匿名对象作为实参传递给一个方法调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建一个学生对象，并访问类中成员。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        student.age = <span class="number">18</span>;</span><br><span class="line">        student.introduce();<span class="comment">// 我是：张三,年龄：18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）成员变量"><a href="#（4）成员变量" class="headerlink" title="（4）成员变量"></a><strong>（4）成员变量</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 数据类型 成员变量名 = 初始化值;</span></span><br><span class="line"><span class="comment">格式说明：</span></span><br><span class="line"><span class="comment">	常用的权限修饰符有：public、private、缺省、protected</span></span><br><span class="line"><span class="comment">	 其他修饰符：static、final</span></span><br><span class="line"><span class="comment">	数据类型可以是任何基本数据类型或任何引用数据类型。</span></span><br><span class="line"><span class="comment">	成员变量名的规则同一般变量名。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>★ 成员变量与局部变量的区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">在类中的位置</th>
<th align="center">作用范围</th>
<th align="center">初始化值</th>
<th align="center">修饰符</th>
<th align="center">内存位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员变量</td>
<td align="center">类中，方法外</td>
<td align="center">类中</td>
<td align="center">有默认值</td>
<td align="center">public、private、static、final 等</td>
<td align="center">堆区</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">方法中或者方法声明上 (形式参数)</td>
<td align="center">方法中</td>
<td align="center">没有默认值。必须先定义，赋值，最后使用</td>
<td align="center">不能用权限修饰符修饰，可以用 final 修饰</td>
<td align="center">栈区</td>
</tr>
</tbody></table>
<h3 id="（5）成员方法"><a href="#（5）成员方法" class="headerlink" title="（5）成员方法"></a><strong>（5）成员方法</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 返回值类型 方法名 ( 参数类型 形参1, 参数类型 形参2, … )&#123;</span></span><br><span class="line"><span class="comment">		方法体;</span></span><br><span class="line"><span class="comment">		return 返回值;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">格式说明：</span></span><br><span class="line"><span class="comment">	 修饰符：告诉编译器如何调用该方法。定义了该方法的访问类型。有public, 缺省,private, protected等</span></span><br><span class="line"><span class="comment">	 如果没有返回值，那么返回值类型写void，并且不需要return 返回值;</span></span><br><span class="line"><span class="comment">	  如果有返回值，返回值类型就是return 返回值;这一语句的返回值的类型，可以是任意数据类型。</span></span><br><span class="line"><span class="comment">	 方法名的命名规则同变量名;</span></span><br><span class="line"><span class="comment">	 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用逗号隔开；</span></span><br><span class="line"><span class="comment">	 return：将方法执行后的结果带给调用者，方法执行到return语句后，整体方法运行结束。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 返回值类型，必须要和return语句返回的类型相同，否则编译失败 。</span></span><br><span class="line"><span class="comment">	② 不能在return语句后面写代码， return意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</span></span><br><span class="line"><span class="comment">	③ 没有返回值时，方法体中可以不必使用return语句。如果使用，仅用来结束方法，格式为：return;</span></span><br><span class="line"><span class="comment">	④ 方法中只能调用方法或属性，不可以在方法内部定义方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><u>方法的的重载：</u></p>
<ul>
<li>概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>特点：与返回值类型无关，只看参数列表，且参数列表必须不同（个数不同 &#x2F; 数据类型不同 &#x2F; 顺序不同）。</li>
<li>调用：通过方法的参数列表，调用不同的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：创建一个sum方法，可以计算两个整数或三个整数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloading</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//3</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 计算两个整数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法重载，计算三个整数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>形参个数可变的方法：</u></p>
<ul>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的；</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：<u>0个</u>，1个或多个；</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载；</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后；</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例：定义形参可变的方法，并与定义数组形式的新参方法做对比。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 定义了形参个数可变的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String... str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            System.out.print(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义了数组形式的形参方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(String[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            System.out.print(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1(<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>);<span class="comment">// 张三丰 张无忌 张翠山</span></span><br><span class="line">        test2(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>&#125;);<span class="comment">// 使用了匿名对象，结果为：张三丰 张无忌 张翠山</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>方法的<strong>参数传递机制</strong>：</u></p>
<ul>
<li>Java 里方法的参数传递方式只有一种：值传递。（即将实际参数值的副本传入方法内，而参数本身不受影响。）</li>
<li>如果形参是基本数据类型，则将实参基本数据类型变量的“<code>数据值</code>”传递给形参；</li>
<li>如果形参是引用数据类型，则将实参引用数据类型变量的“<code>地址值</code>”传递给形参；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;值传递前的值为：&quot;</span>+num);<span class="comment">//5</span></span><br><span class="line">        change(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;值传递后的值为：&quot;</span>+num);<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个方法，将传入的参数值修改为0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;改变值的方法被调用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）static-关键字"><a href="#（6）static-关键字" class="headerlink" title="（6）static 关键字"></a>（6）static 关键字</h3><p>static 关键字可以用来修饰：属性、方法、内部类、代码块；<strong>被修饰的成员是从属于类的</strong>，而不是单单是属于某个对象的。既然属于类，就可以不靠创建对象来调用了，而直接通过类进行调用。</p>
<ul>
<li><p><u>静态变量</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">	当static修饰成员变量时，该变量称为静态变量，也称为类变量。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	static 数据类型 变量名;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。</span></span><br><span class="line"><span class="comment">	② 任何对象都可以更改静态变量的值，但也可以在不创建该类的对象的情况下，通过【类.属性】的方式对静态变量进行操作。</span></span><br><span class="line"><span class="comment">	③ 当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</span></span><br><span class="line"><span class="comment">	④ 静态变量随着类的加载而加载，它的加载要早于对象的创建。由于类只会加载一次，则静态变量在内存中也只会存在一份，而且是存在方法区的静态域中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Test.num = <span class="number">20</span>;</span><br><span class="line">        test1.num = <span class="number">30</span>;</span><br><span class="line">        test2.num = <span class="number">40</span>;</span><br><span class="line">        System.out.println(Test.num);   <span class="comment">//40</span></span><br><span class="line">        System.out.println(test1.num);  <span class="comment">//40</span></span><br><span class="line">        System.out.println(test2.num);  <span class="comment">//40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★ 静态变量与普通成员变量的区别</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">所属</th>
<th align="center">存储区域</th>
<th align="center">生命周期</th>
<th align="center">调用方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态变量</td>
<td align="center">类</td>
<td align="center">方法区</td>
<td align="center">与类的生命周期相同</td>
<td align="center">类.属性 &#x2F; 对象.属性</td>
</tr>
<tr>
<td align="center">普通成员变量</td>
<td align="center">某个对象</td>
<td align="center">堆区</td>
<td align="center">与其所属对象的生命周期相同</td>
<td align="center">所属对象.属性</td>
</tr>
</tbody></table>
</li>
<li><p><u>静态方法</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">	当static修饰成员方法时，该变量称为静态方法，也称为类方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 static 返回值类型 方法名 (参数列表)&#123;</span></span><br><span class="line"><span class="comment">		方法体;     </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 在静态的方法内，不能使用this关键字、super关键字。</span></span><br><span class="line"><span class="comment">	② 静态方法随着类的加载而加载，可以通过【类名.静态方法】进行调用，也可以通过【对象名.静态方法】调用。</span></span><br><span class="line"><span class="comment">	③ 静态方法中，只能调用静态的方法或变量。</span></span><br><span class="line"><span class="comment">	④ 非静态方法中，既可以调用非静态的方法或变量，也可以调用静态的方法或变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Test.staticMethod(); <span class="comment">// 这是一个静态方法</span></span><br><span class="line">        test.staticMethod(); <span class="comment">// 这是一个静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><h3 id="（1）高内聚低耦合"><a href="#（1）高内聚低耦合" class="headerlink" title="（1）高内聚低耦合"></a>（1）高内聚低耦合</h3><p>好的程序设计应该具有的特性：</p>
<ul>
<li><code>高内聚</code> ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li><code>低耦合</code> ：仅对外暴露少量的方法用于使用。</li>
</ul>
<h3 id="（2）封装的好处"><a href="#（2）封装的好处" class="headerlink" title="（2）封装的好处"></a>（2）封装的好处</h3><ul>
<li>良好的封装能够减少耦合。</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性以及安全性。</li>
<li>可以对成员变量进行更精确的控制。（使用者对类内部定义的属性直接操作可能会导致数据的错误、混乱或安全性问题。）</li>
</ul>
<h3 id="（3）访问权限修饰符"><a href="#（3）访问权限修饰符" class="headerlink" title="（3）访问权限修饰符"></a>（3）访问权限修饰符</h3><p>Java 权限修饰符 public、protected、default(缺省)、private 置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<ul>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p>以下是访问控制级别：</p>
<p>public &gt; protected &gt; (default) &gt; private</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default（缺省）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>注意：对于 class 的权限修饰只可以用 public 和 default(缺省)。</p>
<h3 id="（4）实现封装的步骤"><a href="#（4）实现封装的步骤" class="headerlink" title="（4）实现封装的步骤"></a>（4）实现封装的步骤</h3><ul>
<li>使用 private 关键字来修饰成员变量（成员变量私有化）。</li>
<li>对需要访问的成员变量，提供对应的一对公共的（public）setter 方法 、getter 方法实现对该成员变量的操作（提供对外接口）。<ul>
<li>setter、getter 方法的名称应该为 private 修饰的成员变量的首字母大写，并在前面添加 get、set，比如一个private的成员变量名为 age，那么其 setter、getter 方法的名称为 setAge、getAge。</li>
<li>对于 setter 来说，不能有返回值，参数类型和成员变量对应（用于给变量赋值）</li>
<li>对于 getter 来说，不能有参数，返回值类型和成员变量对应（用于获取变量值）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以学生类为示例，说明封装的步骤</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> age;<span class="comment">// 将年龄age定义为private，只能被Student类内部访问   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义setAge方法，并定义为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">200</span>)&#123;</span><br><span class="line">            age = -<span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄大小输入不符合实际！请重新设置一次&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            age = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义getAge方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：定义一个Test类，创建Student对象，并给对象赋值为张三，18岁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">// student age = 18; 此语句是错误的，因为Student类中的age修饰符为private，只能在Student类中使用。</span></span><br><span class="line">        student.setAge(<span class="number">18</span>);<span class="comment">// 通过setAge()方法对年龄赋值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+ student.name );<span class="comment">// 姓名：张三</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + student.getAge());<span class="comment">// 年龄：18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）构造方法"><a href="#（5）构造方法" class="headerlink" title="（5）构造方法"></a>（5）构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：	</span></span><br><span class="line"><span class="comment"> 	1.创建对象（当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。当我们通过关键字new来创建对象时，其实就是在调用构造方法）</span></span><br><span class="line"><span class="comment">	2.初始化对象的信息。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public 类名称(参数类型 参数名称) &#123;</span></span><br><span class="line"><span class="comment">    	方法体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	①构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</span></span><br><span class="line"><span class="comment">	②构造方法不要写返回值类型，连void都不写</span></span><br><span class="line"><span class="comment">	③不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</span></span><br><span class="line"><span class="comment">	④如果没有编写任何构造方法，那么编译器将会默认提供一个构造方法，没有参数、方法体什么事情都不做。public Student() &#123;&#125;</span></span><br><span class="line"><span class="comment">	 也就是在Java语言中，每个类都至少有一个构造方法</span></span><br><span class="line"><span class="comment">	⑤一旦编写了至少一个构造方法，那么编译器将不再提供空的构造方法。</span></span><br><span class="line"><span class="comment">	⑥构造方法可以进行重载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：定义一个学生类，并构造一个无参构造函数和全参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个无参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个全参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String str , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">        age  = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义getter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）this关键字"><a href="#（6）this关键字" class="headerlink" title="（6）this关键字"></a>（6）this关键字</h3><ul>
<li>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，会优先使用局部变量。如果需要访问本类当中的成员变量，需要使用格式：<code>this.成员变量名</code></li>
<li>this 关键字指向的是当前对象的引用（this 理解为：当前对象或当前正在创建的对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用this关键字区分局部变量和成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line">    <span class="comment">// 定义一个全参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// name = name;错误，此时根据就近原则，两个name都是局部变量，并不能给成员变量初始化</span></span><br><span class="line">        <span class="comment">// age  = age;</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// this.name指成员变量，name指局部变量</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）标准代码——JavaBean"><a href="#（7）标准代码——JavaBean" class="headerlink" title="（7）标准代码——JavaBean"></a>（7）标准代码——JavaBean</h3><p>JavaBean 是一种可重用的Java组件，它可以被 Applet、Servlet、JSP 等 Java 应用程序调用，也可以可视化地被Java开发工具使用。</p>
<p>一个标准的类（也叫做JavaBean）通常要拥有下面四个组成部分：</p>
<ul>
<li>所有的成员变量都要使用 private 关键字修饰；</li>
<li>为每一个成员变量编写一对儿 getter&#x2F;setter 方法；</li>
<li>编写一个无参数的构造方法；</li>
<li>编写一个全参数的构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个标准的学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="comment">// 定义成员变量，都用private修饰</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义无参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//定义全参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//定义gettter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义gettter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）代码块"><a href="#（8）代码块" class="headerlink" title="（8）代码块"></a>（8）代码块</h3><blockquote>
<p>在 Java 中，使用{}大括号括起来的代码被称为代码块。</p>
</blockquote>
<ul>
<li><p><u>普通代码块</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最常见的一种代码块，有方法名称，即类中方法的方法体，可以控制变量的生命周期，提高内存利用率。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;  <span class="comment">// 普通代码块</span></span><br><span class="line">      System.out.println(<span class="string">&quot;这是一个普通代码块&quot;</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(test.Method);<span class="comment">// 这是一个普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>构造代码块</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义：</span></span><br><span class="line"><span class="comment">	在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块，其可以给所有对象进行初始化。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	&gt;构造代码块内部可以输出语句；</span></span><br><span class="line"><span class="comment">	&gt;每创建一个对象，就执行一次构造代码块，再执行构造方法；</span></span><br><span class="line"><span class="comment">	&gt;如果一个类中定义了多个构造代码块，则按照声明的先后顺序执行，（一般也不会构造多个）；</span></span><br><span class="line"><span class="comment">	&gt;构造代码块内可以调用静态变量、静态方法、普通成员变量、普通成员方法。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	&#123; <span class="comment">//构造代码块</span></span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(test.num);<span class="comment">//这是一个构造代码块\n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>静态代码块</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义：</span></span><br><span class="line"><span class="comment">	在类中直接定义的只有static关键字修饰的代码块即为静态代码块，其可以对静态属性、类进行初始化，并且只执行一次。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	&gt;静态代码块内部可以输出语句；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块随着类的加载而执行,而且只执行一次，优先于main方法和构造方法的执行；</span></span><br><span class="line"><span class="comment">	&gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块的执行要优先于非静态代码块的执行；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块内只能调用静态变量和静态方法。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.num);<span class="comment">//这是一个静态代码块\n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h2><h3 id="（1）继承的概念"><a href="#（1）继承的概念" class="headerlink" title="（1）继承的概念"></a>（1）继承的概念</h3><blockquote>
<p>子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p>
</blockquote>
<h3 id="（2）继承的优缺点"><a href="#（2）继承的优缺点" class="headerlink" title="（2）继承的优缺点"></a>（2）继承的优缺点</h3><p>优点：代码共享，减少重复代码。</p>
<ul>
<li>减少了代码冗余，提高了代码的复用性。</li>
<li>提高了代码的维护性，更有利于功能的扩展。</li>
<li>让类与类之间产生了关系，是多态的前提</li>
</ul>
<p>缺点：提高了类的耦合性，使得代码之间的联系更加紧密，那么代码独立性更差。</p>
<h3 id="（3）继承的格式"><a href="#（3）继承的格式" class="headerlink" title="（3）继承的格式"></a>（3）继承的格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用extends关键字。</span></span><br><span class="line"><span class="keyword">public</span> class 父类名称&#123;</span><br><span class="line">	代码体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称&#123;</span><br><span class="line">	代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）继承的特点"><a href="#（4）继承的特点" class="headerlink" title="（4）继承的特点"></a>（4）继承的特点</h3><ul>
<li><p>子类拥有父类非 private 的属性、方法。</p>
</li>
<li><p>子类可以拥有自己特有的属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以对父类的方法进行重写，即子类可以用自己的方式实现父类的方法。</p>
</li>
<li><p>顶层父类是Object类。所有的类默认继承Object作为父类。</p>
</li>
<li><p>java支持单继承、多级继承、不同类继承同一个类，不支持多继承</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162516.png" style="zoom:60%;" /></li>
</ul>
<h3 id="（5）重写"><a href="#（5）重写" class="headerlink" title="（5）重写"></a>（5）重写</h3><blockquote>
<p>重写（也称为覆盖）：子类对父类方法的实现过程进行重新编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 父类名称&#123;</span><br><span class="line">    <span class="comment">// 父类被重写的方法A</span></span><br><span class="line">	修饰符 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类的方法A</span></span><br><span class="line">	修饰符 返回值类型 和父类相同方法名称(和父类相同的参数列表)&#123;</span><br><span class="line">        新的方法体;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>重写的好处</u>：子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p><u>重写的要求</u>：</p>
<ul>
<li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称和参数列表。</p>
</li>
<li><p>父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void</p>
<p>父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类</p>
<p>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型(一模一样)。</p>
</li>
<li><p>子类方法的权限必须【大于等于】父类方法的权限修饰符。public &gt; protected &gt; (default) &gt; private</p>
<p> 子类不能重写父类中声明为 private 权限的方法。</p>
</li>
<li><p>子类方法抛出的异常不能大于父类被重写方法的异常。</p>
</li>
<li><p>在子类的重写方法前，可以加一个注解 @override，用来检测是不是有效的正确覆盖重写。</p>
</li>
</ul>
<p><u>重写的特点</u>：创建的是子类对象，则优先用子类方法。</p>
<p><u>重写与重载的区别★★★：</u></p>
<p>重载：同一个类中不同方法具有相同的名字，但是参数不一样，即参数的名称和参数的类型不一样。同类不同参。</p>
<p>重写：子父类的，即子类与父类具有相同的方法名字还有参数参数相同和相同的返回类型。即同名同参同类型。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">参数列表</th>
<th align="center">是否有继承关系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载（overload）</td>
<td align="center">必须不同</td>
<td align="center">无继承关系，在同一个类中</td>
</tr>
<tr>
<td align="center">重写（override）</td>
<td align="center">必须相同</td>
<td align="center">有继承关系，在不同类中</td>
</tr>
</tbody></table>
<h3 id="（6）super-关键字"><a href="#（6）super-关键字" class="headerlink" title="（6）super 关键字"></a>（6）super 关键字</h3><p>如果子类想要调用父类中的内容，可以使用super关键字，主要有下面三种用法：</p>
<p>​    ① super 可用于访问父类中定义的成员变量【因为成员变量时私有的，所有子类不能直接调用父类的，需要用到super关键字】</p>
<p>​    ② super 可用于调用父类中定义的成员方法</p>
<p>​    ③ super 可用于在子类构造器中调用父类的构造器</p>
<p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员</li>
<li>super 的追溯不仅限于直接父类</li>
<li>super 和 this 的用法相像，this 代表本类对象的引用，super 代表父类的内存空间的标识</li>
</ul>
<p><strong>super 关键字的使用</strong>：</p>
<p>① <u>访问成员变量</u>★</p>
<p>​    <code>this.成员变量</code> -&gt;本类的  </p>
<p>​    <code>super.成员变量</code> -&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);<span class="comment">// 没有this和super，局部变量，30</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num);<span class="comment">// 有this，本类中的成员变量，20</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num);<span class="comment">// 有super，父类中的成员变量，10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <u>访问成员方法</u>★</p>
<p>​    <code>this.成员方法名() </code>-&gt;本类的  </p>
<p>​    <code>super.成员方法名() </code>-&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.method();<span class="comment">// 有this，调用子类中方法</span></span><br><span class="line">        <span class="built_in">super</span>.method();<span class="comment">// 有super，调用父类中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <u>访问构造方法</u>★</p>
<p>​    <code>this.(形参列表)</code> -&gt;本类的  </p>
<p>​    <code>super(形参列表)</code> -&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 子类构造方法当中有一个默认隐含的“super()”调用，调用父类的空参构造。所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">2. 子类构造可以通过super关键字来调用父类重载构造，手动调用父类构造会覆盖默认的super(),</span></span><br><span class="line"><span class="comment">3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 隐含有一个super()；</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在main方法中，new了一个子类B，那么会使用B的构造方法，而B继承了A，则会先调用父类A的构造方法，再调用子类B的构造方法</span></span><br><span class="line"><span class="comment">结果为：</span></span><br><span class="line"><span class="comment">父类的构造方法执行了</span></span><br><span class="line"><span class="comment">子类的构造方法执行了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>总结：★ <strong>this 和 super 的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">访问成员变量</th>
<th align="center">调用成员方法</th>
<th>调用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">this</td>
<td align="center">访问本类中的成员变量，如果本类没有，则从父类中继续查找</td>
<td align="center">访问本类中的成员方法，如果本类没有，则从父类中继续查找</td>
<td>访问本类中的构造方法</td>
</tr>
<tr>
<td align="center">super</td>
<td align="center">直接访问父类中的成员变量</td>
<td align="center">直接访问父类中的成员方法</td>
<td>访问父类中的构造方法</td>
</tr>
</tbody></table>
<p>在主函数中，创建具有继承关系的对象时，</p>
<p>如果成员变量或者静态方法重名，看等号左边是谁，则优先用谁，没有则向上找。（编译看左边，运行看左边）</p>
<p>如果成员方法重名，看 new 的谁，则优先用谁，没有则向上找。（编译看左边，运行看右边）</p>
<h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h2><h3 id="（1）多态的概念"><a href="#（1）多态的概念" class="headerlink" title="（1）多态的概念"></a>（1）多态的概念</h3><blockquote>
<p>同一行为发生在不同的对象上会产生不同的结果。（同一行为，具有多个不同表现形式）</p>
</blockquote>
<h3 id="（2）多态的优缺点"><a href="#（2）多态的优缺点" class="headerlink" title="（2）多态的优缺点"></a>（2）多态的优缺点</h3><p>优点：提高了代码的扩展性，前期定义的代码可以使用后期的内容，而且可以接口复用（子类共用一个父类接口）。</p>
<p>缺点：多态不能访问子类特有的功能（ 前期定义的内容不能使用(调用)后期子类的特有内容。）</p>
<h3 id="（3）多态的使用"><a href="#（3）多态的使用" class="headerlink" title="（3）多态的使用"></a>（3）多态的使用</h3><p>使用多态的前提：</p>
<p>① 存在继承或者实现关系</p>
<p>② 子类覆盖（重写）父类方法</p>
<p>③ 向上转型（父类引用指向子类对象）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多态的格式：</span></span><br><span class="line"><span class="comment">	父类类型 变量名 = new 子类对象；</span></span><br><span class="line"><span class="comment">	变量名.方法名();</span></span><br><span class="line"><span class="comment">在多态的代码当中，</span></span><br><span class="line"><span class="comment">成员方法的访问规则是：看new的是谁，就优先用谁，没有则向上找。（编译看左边，运行看右边）</span></span><br><span class="line"><span class="comment">成员变量或者静态方法的访问规则是：看等号左边是谁，则优先用谁，没有则向上找。（编译看左边，运行看左边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法不是重写，因为有static关键字，如果加上 @override 会报错</span></span><br><span class="line">    <span class="comment">// 如果子类有和父类相同的静态方法，那么父类的静态方法将会被隐藏，对于子类不可见</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法不是重写，因为有static关键字，如果加上@override会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        System.out.println(animal.name);<span class="comment">// 成员变量，编译看左，运行也看左。运行的是父类的成员变量，结果为：动物</span></span><br><span class="line">        animal.eat();<span class="comment">// 成员方法，编译看左，运行看右。运行的是子类的成员方法，结果为：猫吃鱼</span></span><br><span class="line">        animal.sleep();<span class="comment">// 静态方法，编译看左，运行也看左。运行的是父类的静态方法，结果为：动物在睡觉</span></span><br><span class="line">        <span class="comment">// animal.catchMouse();错误！多态时，不能使用子类特有的属性和方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        function(cat);<span class="comment">// 发生了多态</span></span><br><span class="line">        function(dog);<span class="comment">// 发生了多态，实现了接口复用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(Animal animal)</span>&#123; <span class="comment">// 接口复用，如果没有多态性，则需要重载</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）instanceof-关键字"><a href="#（4）instanceof-关键字" class="headerlink" title="（4）instanceof 关键字"></a>（4）instanceof 关键字</h3><p>instanceof 关键字用于来判断多态中父类引用的对象，原本是哪个子类（判断某个对象是否是某个 Class 类的实例）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：对象名 instanceof 数据类型</span></span><br><span class="line"><span class="comment">返回值为boolean。</span></span><br><span class="line"><span class="comment">	如果对象属于该数据类型，返回true。</span></span><br><span class="line"><span class="comment">	如果对象不属于该数据类型，返回false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        System.out.println(animal <span class="keyword">instanceof</span> Cat);<span class="comment">//由于定义的时候，animal原本是Cat类，则结果为true</span></span><br><span class="line">        System.out.println(animal <span class="keyword">instanceof</span> Dog);<span class="comment">//由于定义的时候，animal原本是Cat类，不是Dog类，则结果为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）引用类型转换"><a href="#（5）引用类型转换" class="headerlink" title="（5）引用类型转换"></a>（5）引用类型转换</h3><ul>
<li><p><u>向上转型</u></p>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。（类似于基本类型中的自动类型转换）</span></span><br><span class="line"><span class="comment">使用格式：</span></span><br><span class="line"><span class="comment">	父类类型  变量名 = new 子类类型();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>向下转型</u></p>
<p>一个已经向上转型的子类对象，将父类引用再转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父类类型向子类类型向下转换的过程，这个过程是强制的。（类似于基本类型中的强制类型转换）</span></span><br><span class="line"><span class="comment">使用格式：</span></span><br><span class="line"><span class="comment">	变量名 = (子类类型) 父类变量名;</span></span><br><span class="line"><span class="comment">向下转型的目的：</span></span><br><span class="line"><span class="comment">	多态的一个缺点就是不能调用子类中特有的方法。而如果想要调用子类特有的方法，就需要向下转型。</span></span><br><span class="line"><span class="comment">向下转型的注意事项：</span></span><br><span class="line"><span class="comment">	使用强转时，可能出现ClassCastException的异常，出现异常的原因是多态中父类引用的对象，原本不是此子类，却想要转型为此子类。为了避免在向下转型时出现ClassCastException的异常，在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 猫特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 狗特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keepHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// Dog dog = (Dog)animal; 语句错误，本来new的是Cat，却要转换为Dog，会出现ClassCastException</span></span><br><span class="line">        <span class="comment">// Cat cat = (Cat)animal; //向下转型</span></span><br><span class="line"></span><br><span class="line">        function(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(Animal animal)</span> &#123; <span class="comment">// 接口复用</span></span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;  <span class="comment">// 如果animal对象原本属于Cat类，则进行向下转型，并调用Cat特有的方法</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;  <span class="comment">// 如果animal对象原本属于Dog类，则进行向下转型，并调用Dog特有的方法</span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">            dog.keepHouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于定义的animal原本属于Cat类，故最终结果为：猫抓老鼠</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（6）final关键字"><a href="#（6）final关键字" class="headerlink" title="（6）final关键字"></a>（6）final关键字</h3><p>final 关键字代表最终、不可改变的，可以用来修饰：类、方法、变量。</p>
<ul>
<li><p><u>final 修饰类</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	final class 类名 &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的类，不能被继承。比如：String类、System类、StringBuffer类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>final 修饰方法</u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 final 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">    	//方法体</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的方法，不能被重写。比如：Object类中getClass();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>final 修饰变量</u></p>
<p>① 修饰局部变量——基本类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	方式一：</span></span><br><span class="line"><span class="comment">		final 数据类型 变量名;</span></span><br><span class="line"><span class="comment">		变量名 = 值;</span></span><br><span class="line"><span class="comment">	方式二：</span></span><br><span class="line"><span class="comment">		final 数据类型 变量名 = 值;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的局部变量，只能被赋值一次。</span></span><br><span class="line"><span class="comment">	被final修饰的常量名称，一般都有书写规范，所有字母都大写。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> NUM;	<span class="comment">//声明变量，使用final修饰        </span></span><br><span class="line">        NUM = <span class="number">10</span>;	<span class="comment">//赋值</span></span><br><span class="line">        <span class="comment">//NUM = 20; // 报错,不可重新赋值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">        <span class="comment">//NUM1 = 20; // 报错,不可重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 修饰局部变量——引用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	final 引用数据类型 变量名 = new 引用数据类型(参数列表);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;引用类型final关键字的测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//test  =new Test();//报错，不能指向新的对象。</span></span><br><span class="line">        test.method();<span class="comment">//引用类型final关键字的测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员初始化方式有两种，只能二选一：</span></span><br><span class="line"><span class="comment">	①显示初始化；</span></span><br><span class="line"><span class="comment">		public class Test &#123;</span></span><br><span class="line"><span class="comment">    		final int NUM = 10;</span></span><br><span class="line"><span class="comment">		&#125;	</span></span><br><span class="line"><span class="comment">	②构造方法初始化。</span></span><br><span class="line"><span class="comment">		public class Test &#123;</span></span><br><span class="line"><span class="comment">   		 	final int NUM;</span></span><br><span class="line"><span class="comment">   		 	public Test(int num) &#123;</span></span><br><span class="line"><span class="comment">       		 	this.NUM = num;</span></span><br><span class="line"><span class="comment">  		 	&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-抽象"><a href="#5-抽象" class="headerlink" title="5. 抽象"></a>5. 抽象</h2><h3 id="（1）抽象类"><a href="#（1）抽象类" class="headerlink" title="（1）抽象类"></a>（1）抽象类</h3><p>用 abstract 关键字来修饰一个类，这个类就叫做抽象类。</p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类；</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 abstract class 类名 &#123;</span></span><br><span class="line"><span class="comment"> 		代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 抽象类不能实例化，即不能创建对象；</span></span><br><span class="line"><span class="comment">	② 抽象类一定要被继承，否则没有意义。且抽象类中一定有构造器，便于其子类实例化时调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）抽象方法"><a href="#（2）抽象方法" class="headerlink" title="（2）抽象方法"></a>（2）抽象方法</h3><p>用 abstract 关键字来修饰一个方法，这个方法就叫做抽象方法。</p>
<p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 abstract 返回值类型 方法名 (参数列表);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 抽象方法只有方法声明，没有方法体；</span></span><br><span class="line"><span class="comment">	② 如果一个类中含有抽象方法，那么这个类必须定义为抽象类。反之不成立，抽象类中可以没有抽象方法的。</span></span><br><span class="line"><span class="comment">	③ 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</span></span><br><span class="line"><span class="comment">	④ 不能用abstract修饰变量、代码块、构造器；</span></span><br><span class="line"><span class="comment">	⑤ 不能用abstract修饰私有方法、静态方法、final的方法、final的类。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个抽象的父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//子类重写父类的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal animal = new Aniaml();错误，抽象类不能实例化</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6. 接口"></a>6. 接口</h2><blockquote>
<p>Java 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p>
</blockquote>
<p>类的内部封装了成员变量、构造方法和成员方法，而接口的内部封装了常量和抽象方法（JDK 7及以前）、默认方法和静态方法（JDK 8）、私有方法（JDK 9）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public interface 接口名称 &#123;</span></span><br><span class="line"><span class="comment">		// 成员变量，使用 public static final 修饰，关键字可以省略，供子类调用或者子类重写。</span></span><br><span class="line"><span class="comment">    	// 抽象方法，使用 public abstract 修饰，关键字可以省略，没有方法体。该方法供子类实现使用。</span></span><br><span class="line"><span class="comment">   	 	// 默认方法，使用 public default 修饰，default不可省略，供子类调用或者子类重写。（JDK 8有的新特性）</span></span><br><span class="line"><span class="comment">   		// 静态方法，使用 public static 修饰，static不可省略，供接口直接调用。（JDK 8有的新特性）</span></span><br><span class="line"><span class="comment">   	 	// 私有方法，使用 private 修饰，供接口中的默认方法或者静态方法调用。（JDK 9有的新特性）</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 接口中没有构造器，意味着接口不可以实例化。</span></span><br><span class="line"><span class="comment">	② 接口不能直接使用，必须有一个“实现类”来实现（implements）该接口。如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化；如果实现类没覆盖接口中所有的抽象方法，则此实现类必须为一个抽象类。</span></span><br><span class="line"><span class="comment">	③ 一个类可以实现多个接口（多实现），接口也可以继承其它接口（且可以多继承）。---&gt;弥补了Java单继承性的局限性</span></span><br><span class="line"><span class="comment">	④ 接口与实现类之间存在多态性。</span></span><br><span class="line"><span class="comment">	⑤ 继承是一个&quot;是不是&quot;（is a）的关系，而接口实现则是 &quot;能不能&quot;（hava a）的关系。</span></span><br><span class="line"><span class="comment">	⑥ 默认方法可以解决接口升级的问题，直接在接口中写默认方法，而实现类不需要重写，默认就有了此方法。</span></span><br><span class="line"><span class="comment">	⑦ 优先级的问题：当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</span></span><br><span class="line"><span class="comment">	⑧ 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。</span></span><br><span class="line"><span class="comment">	⑨ 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</span></span><br><span class="line"><span class="comment">接口的使用步骤（实现）：</span></span><br><span class="line"><span class="comment">	public class 实现类名称 implements 接口名称 &#123;</span></span><br><span class="line"><span class="comment">   	 	// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">   		// 重写接口中默认方法【可选】</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">haveWings</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有翅膀可以飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写接口中的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小鸟正在飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.fly();<span class="comment">// 小鸟正在飞</span></span><br><span class="line">        bird.haveWings(); <span class="comment">// 有翅膀可以飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★ <strong>抽象类与接口的对比</strong></p>
<ul>
<li>相同点<ul>
<li>均不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</li>
</ul>
</li>
<li>不同点<ul>
<li>抽象类中有构造方法，而接口中没有。</li>
<li>抽象类不能多继承，而接口可以。</li>
<li>接口中的变量必须有 static、final 修饰，实际是一个常量，必须赋初值，而抽象类可以任意。</li>
</ul>
</li>
</ul>
<h2 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h2><blockquote>
<p>如果将一个类定义在另一个类里面或者一个方法里面，这样的类就称为内部类。内部类又可以分为成员内部类、局部内部类、匿名内部类和静态内部类。</p>
</blockquote>
<h3 id="（1）成员内部类"><a href="#（1）成员内部类" class="headerlink" title="（1）成员内部类"></a>（1）成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部。在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时，Engine 就可以使用成员内部类来描述。</p>
<p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的 .class文件，但是前面冠以外部类的类名和$符号 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	class 外部类名 &#123;</span></span><br><span class="line"><span class="comment">		外部类属性;</span></span><br><span class="line"><span class="comment">		外部类方法;</span></span><br><span class="line"><span class="comment">		class 内部类名 &#123;</span></span><br><span class="line"><span class="comment">			内部类属性;</span></span><br><span class="line"><span class="comment">			内部类方法;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">创建内部类对象格式：</span></span><br><span class="line"><span class="comment">（成员内部类是依附外部类的，只有创建了外部类才能创建内部类）</span></span><br><span class="line"><span class="comment">	方式一：</span></span><br><span class="line"><span class="comment">		外部类名.内部类名 内部对象名 = new 外部类名().new 内部类名();</span></span><br><span class="line"><span class="comment">	方式二：</span></span><br><span class="line"><span class="comment">		外部类名 外部对象名 = new 外部类名();</span></span><br><span class="line"><span class="comment">		外部类名.内部类名 内部对象名 = 外部对象名.new 内部类名();</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 和外部类不同，内部类可以被任意权限修饰符修饰；</span></span><br><span class="line"><span class="comment">	② 内部类可以直接访问外部类的成员，包括私有成员；</span></span><br><span class="line"><span class="comment">	③ 外部类要访问内部类的成员，必须要建立内部类的对象；</span></span><br><span class="line"><span class="comment">	④ 当内部类属性和外部类属性重名时，内部类可以通过【外部类名.this.属性名】的方式调用外部类重名属性；</span></span><br><span class="line"><span class="comment">	⑤ 当内部类方法和外部类方法重名时，内部类可以通过【外部类名.this.方法名】的方式调用外部类重名方法；</span></span><br><span class="line"><span class="comment">	⑥ 内部类的内部不能有静态信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">            System.out.println(num); <span class="comment">// 内部类调用内部类属性，20</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.num); <span class="comment">// 内部类调用外部类属性，10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        outer.outerMethod(); <span class="comment">// 这是一个外部类方法</span></span><br><span class="line">        inner.innerMethod(); <span class="comment">//  这是一个内部类方法 \n20 \n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）局部内部类"><a href="#（2）局部内部类" class="headerlink" title="（2）局部内部类"></a>（2）局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	class 外部类名 &#123;</span></span><br><span class="line"><span class="comment">		外部类属性;</span></span><br><span class="line"><span class="comment">		修饰符 返回值类型 外部类方法名(形参)&#123;</span></span><br><span class="line"><span class="comment">			class 内部类名 &#123;</span></span><br><span class="line"><span class="comment">				内部类属性;</span></span><br><span class="line"><span class="comment">				内部类方法;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private；</span></span><br><span class="line"><span class="comment">	② 局部内部类不能使用static修饰，因此也不能包含静态成员，因为在方法结束之后，内存需要释放；</span></span><br><span class="line"><span class="comment">	③ 局部内部类只能在定义的方法中使用，创建对象后使用，并且可以直接访问方法内的局部变量和参数，但是不能更改。</span></span><br><span class="line"><span class="comment">	④ 当内部类属性和外部类属性重名时，内部类可以通过【外部类名.this.属性名】的方式调用外部类重名属性；</span></span><br><span class="line"><span class="comment">	⑤ 当内部类方法和外部类方法重名时，内部类可以通过【外部类名.this.方法名】的方式调用外部类重名方法；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">// 方法的局部变量</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">                System.out.println(num); <span class="comment">// 内部类调用内部类属性，30</span></span><br><span class="line">                System.out.println(Outer.<span class="built_in">this</span>.num); <span class="comment">// 内部类调用外部类属性，10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.outerMethod(); <span class="comment">// 这是一个外部类方法 \n30 \n10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）匿名内部类"><a href="#（3）匿名内部类" class="headerlink" title="（3）匿名内部类"></a>（3）匿名内部类</h3><p>匿名内部类是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口】的匿名的子类对象。开发中，最常用到的内部类就是匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">方式一：（匿名内部类，非匿名对象）</span></span><br><span class="line"><span class="comment">	父接口名 实现名  = new 父类名或父接口名() &#123;</span></span><br><span class="line"><span class="comment">		重写父类或父接口的abstract方法;</span></span><br><span class="line"><span class="comment">		自己特有的方法;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	实现名.方法名(形参);</span></span><br><span class="line"><span class="comment">方式二：（匿名内部类且匿名对象）</span></span><br><span class="line"><span class="comment">	new 父类名或父接口名() &#123;</span></span><br><span class="line"><span class="comment">		重写父类或父接口的abstract方法;</span></span><br><span class="line"><span class="comment">		自己特有的方法;</span></span><br><span class="line"><span class="comment">	&#125;.方法名(形参);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 匿名内部类必须继承一个父类或者实现一个父接口；</span></span><br><span class="line"><span class="comment">	② 如果某个局部类你只需要用一次，则可以考虑使用匿名内部类；</span></span><br><span class="line"><span class="comment">	③ 匿名内部类没有类名，因此没有构造方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义一个父类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类，非匿名对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;  <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.method(); <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类且匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>() &#123;  <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">// 在大括号后直接调用类中方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）静态内部类"><a href="#（4）静态内部类" class="headerlink" title="（4）静态内部类"></a>（4）静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态内部类创建对象格式：</span></span><br><span class="line"><span class="comment">	外部类名.内部类名 对象名 = new 外部类名.内部类名(); //注意和成员内部类不同</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 静态内部类的创建不需要依赖外部类可以直接创建。</span></span><br><span class="line"><span class="comment">	② 静态内部类不可以使用任何外部类的非static类（包括属性和方法），但可以存在自己的成员变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">            <span class="comment">//outerMethod();// 错误，不能调用非静态方法</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 内部类调用内部类属性，20</span></span><br><span class="line">            <span class="comment">//System.out.println(Outer.this.num);// 错误，不能调用外部非静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-Java常用API"><a href="#五-Java常用API" class="headerlink" title="五. Java常用API"></a>五. Java常用API</h1><blockquote>
<p>API（Application Programming Interface），应用程序编程接口。它是 JDK 中提供给使用者的一些常用类的说明文档，使用者不需要访问源码或理解内部工作机制的细节，只需要会使用即可。在查看 API 文档时，使用者需要查看当前类的包路径、构造方法以及方法摘要。</p>
</blockquote>
<p>引用类型的一般使用步骤：</p>
<ul>
<li><p>①<code>导包</code>。import 包路径.类名称；</p>
<ul>
<li>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</li>
<li>如果使用的类或接口是 java.lang 包下定义的，则可以省略 import 结构。</li>
<li>可以使用 “xxx.*” 的方式，表示可以导入 xxx 包下的所结构。    </li>
<li>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</li>
</ul>
</li>
<li><p>②<code>创建</code>。类名称 对象名 &#x3D; new 类名称 ( 参数列表 );</p>
</li>
<li><p>③<code>使用</code>。对象名.成员方法名 ()；</p>
</li>
</ul>
<h2 id="1-Object-类"><a href="#1-Object-类" class="headerlink" title="1. Object 类"></a>1. Object 类</h2><ul>
<li>Object 类在 java.lang 包下，导包语句可以省略不写</li>
<li>java.lang.Object 类是 Java 语言中的根类，即所有类的父类。</li>
<li>如果一个类没有特别指定父类，那么默认则继承自 Object 类。</li>
<li>Object 类只声明了一个空参的构造器</li>
<li>Object 类中的所有方法，子类均都可以使用。（equals() 、toString() 、getClass() 、hashCode()…）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★ equals方法</span></span><br><span class="line"><span class="comment">定义： </span></span><br><span class="line"><span class="comment">    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">    	return (this == obj);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	①Object类中定义的equals()和==的作用是相同的：比较两个对象的【地址值】是否相同，即两个引用是否指向同一个对象实体。</span></span><br><span class="line"><span class="comment">	②对于自定义的类，如果希望进行对象【内容】的比较，则可以覆盖重写equals方法。</span></span><br><span class="line"><span class="comment">	③像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的&quot;实体内容&quot;是否相同。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//equals方法的重写：</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//对equals方法进行重写</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 转换为当前类型</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">            <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★ toString方法</span></span><br><span class="line"><span class="comment">定义： </span></span><br><span class="line"><span class="comment">	 public String toString() &#123;</span></span><br><span class="line"><span class="comment">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	①当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。</span></span><br><span class="line"><span class="comment">	②toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</span></span><br><span class="line"><span class="comment">	③对于自定义的类，如果希望返回对象的【实体内容】，则可以覆盖重写toSting方法。</span></span><br><span class="line"><span class="comment">	④像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回&quot;实体内容&quot;信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// toString方法的重写：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 对toSting方法进行重写</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Scanner类"><a href="#2-Scanner类" class="headerlink" title="2. Scanner类"></a>2. Scanner类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中，实现人机交互。</span></span><br><span class="line"><span class="comment">Scanner类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Scanner;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		Scanner 对象名 = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">	③使用		</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个int数字：int 变量名 = 对象名.nextInt();</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个double数字：double 变量名 = 对象名.nextDouble();</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个字符串：String 变量名 = 对象名.next();//结束符是回车/空格/Tab</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个字符串：String 变量名 = 对象名.nextLine();//读取一行，结束符只有回车</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：从键盘输入两个int数字并求和</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); </span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;两数之和为：&quot;</span>+(num1+num2));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Random类"><a href="#3-Random类" class="headerlink" title="3. Random类"></a>3. Random类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类的功能：用来生成随机数字。</span></span><br><span class="line"><span class="comment">Random类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Random;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		Random 对象名 = new Random();</span></span><br><span class="line"><span class="comment">	③使用		</span></span><br><span class="line"><span class="comment">		● 获取一个随机的int数字（范围是int所有范围）：int 变量名 = 对象名.nextInt();</span></span><br><span class="line"><span class="comment">		● 获取一个随机的int数字（参数代表了范围，左闭右开区间）：int 变量名 = 对象名.nextInt(n);</span></span><br><span class="line"><span class="comment">		● 如果输入的为n，那么此时随机的数字范围是【0，n)，又由于是整数，那么实际取值为0 1 2 ... n-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：创建一个随机整数，范围为[1, 10]</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数为：&quot;</span>+num);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-String类"><a href="#4-String类" class="headerlink" title="4. String类"></a>4. String类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String类的功能：字符串。</span></span><br><span class="line"><span class="comment">String类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.String;//String类在java.lang包下，导包语句可以省略不写</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		方式一：直接创建</span></span><br><span class="line"><span class="comment">			String 对象名 = &quot;Hello&quot;; //最常用</span></span><br><span class="line"><span class="comment">        方式二：无参或有参构造</span></span><br><span class="line"><span class="comment">        	String 对象名 = new String();// 创建了一个空白字符串，不含有任何内容。</span></span><br><span class="line"><span class="comment">        	String 对象名 = new String(String original);。</span></span><br><span class="line"><span class="comment">		方式三：通过字符数组构造</span></span><br><span class="line"><span class="comment">			char[] 字符数组名= &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;    </span></span><br><span class="line"><span class="comment">			String 对象名 = new String(字符数组名);</span></span><br><span class="line"><span class="comment">		方式四：通过字节数组构造</span></span><br><span class="line"><span class="comment">			byte [] 字节数组名= &#123; 97, 98, 99 &#125;;    </span></span><br><span class="line"><span class="comment">			String 对象名 = new String(字节数组名);</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● ★boolean equals(Object obj)：比较字符串的内容是否相同，如果相同，则返回true，如果不同，则返回false。</span></span><br><span class="line"><span class="comment">			注意：如果比较双方一个常量一个变量，推荐把常量字符串写在前面，即</span></span><br><span class="line"><span class="comment">				 推荐：&quot;abc&quot;.equals(str)    </span></span><br><span class="line"><span class="comment">			 	 不推荐：str.equals(&quot;abc&quot;)（因为如果变量值为null，则会报NullPointerException的错误）</span></span><br><span class="line"><span class="comment">		● ★boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。（比如验证码）</span></span><br><span class="line"><span class="comment">		● ★int length() ：返回此字符串的长度。</span></span><br><span class="line"><span class="comment">		● String concat (String str) ：将指定的字符串连接到该字符串的末尾，等价于用“+”。</span></span><br><span class="line"><span class="comment">		● ★char charAt (int index) ：返回指定索引处的char值。</span></span><br><span class="line"><span class="comment">		● int indexOf (String str / Char c) ：返回指定子字符串/字符第一次出现在该字符串内的索引。如果没有，返回-1</span></span><br><span class="line"><span class="comment">		● int indexOf (String str,int Startindex) ：返回指定子字符串/字符第一次出现在该字符串内的索引(从StartIndex处开始进行搜索)。如果没有，返回-1</span></span><br><span class="line"><span class="comment">		● boolean isEmpty() ：判断是否是空字符串</span></span><br><span class="line"><span class="comment">		● String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="comment">		● String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。包含beginIndex，不包含endIndex。</span></span><br><span class="line"><span class="comment">		● int compareTo(String anotherString)：比较两个字符串的大小（一个字符一个字符的比较），如果原字符串更大，返回1，相同返回0，原字符串更小返回-1</span></span><br><span class="line"><span class="comment">		● String replace(char oldChar, char newChar)：返回一个新的字符串，用newChar替换此字符串中出现的所有oldChar（比如敏感词用*替代）</span></span><br><span class="line"><span class="comment">		● ★char[] toCharArray () ：将此字符串转换为新的字符数组。</span></span><br><span class="line"><span class="comment">		● ★byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span></span><br><span class="line"><span class="comment">		● String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">String类的注意事项：</span></span><br><span class="line"><span class="comment">	①Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。</span></span><br><span class="line"><span class="comment">	②字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改，即不可以修改字符串中的单个字符。</span></span><br><span class="line"><span class="comment">	③字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。</span></span><br><span class="line"><span class="comment">	④字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中，而new出来的不在字符串常量池中。</span></span><br><span class="line"><span class="comment">		对于基本类型来说，==是进行数值的比较（数据类型不一定要相同，会发生自动类型转换）。</span></span><br><span class="line"><span class="comment">		对于引用类型来说，==是进行【地址值】的比较。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// String中，==和equals方法的比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 直接创建的字符串在字符串常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);<span class="comment">// 通过字符数组创建的字符串不在字符串常量池中。</span></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false，对于引用类型来说，==是进行【地址值】的比较。</span></span><br><span class="line">        System.out.println(str1.equals(str3));<span class="comment">// true,string类中equals方法比较的是内容。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：输入一个字符串，统计其中的大写字母个数、小写字母个数、数字个数以及其他字符个数。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numbers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">others</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                lower++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numbers++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                others++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母有&quot;</span> + upper + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字母有&quot;</span> + lower + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字有&quot;</span> + numbers + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他字符有&quot;</span> + others + <span class="string">&quot;个&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串一旦创建，不可改变（优点是编译器可以让字符串共享）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        System.out.println(str);<span class="comment">// aaa</span></span><br><span class="line">        str = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        System.out.println(str);<span class="comment">// bbb，此时并不是字符串改变了，只是str不指向aaa，而指向一个新的字符串bbb了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：输入一个字符串，如果字符串中有“你大爷的”四个汉字，则用“****”替代。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);<span class="comment">// 输入：我可去你大爷的，真的醉了，你大爷的！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> string.replace(<span class="string">&quot;你大爷的&quot;</span>,<span class="string">&quot;****&quot;</span>);</span><br><span class="line">        System.out.println(string1);<span class="comment">// 输出：我可去****，真的醉了，****！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-StringBuffer、StringBuilder"><a href="#5-StringBuffer、StringBuilder" class="headerlink" title="5. StringBuffer、StringBuilder"></a>5. StringBuffer、StringBuilder</h2><p>String 类对象一旦创建不可改变，如果想要<u>对字符串进行修改，并且不产生新的对象</u>，可以使用 StringBuffer 和 StringBuilder 类。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">StringBuffer类的功能：线程安全的可变字符串。</span></span><br><span class="line"><span class="comment">StringBuffer类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.StringBuffer;//导包语句可以省略不写</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer();// 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer(String str);//指定字符串内容。</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer(int capacity);//指定初始容量</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● 增	  StringBuffer append(xxx)： 将任意数据类型参数的字符串表示形式追加到此序列，并返回当前对象自身。</span></span><br><span class="line"><span class="comment">			   StringBuffer insert(int offset, xxx)：将任意数据类型参数的字符串表示形式插入此序列中的指定位置。</span></span><br><span class="line"><span class="comment">		● 删   StringBuffer delete(int start, int end)：移除此序列指定位置的子字符串中的字符（左闭右开）。 </span></span><br><span class="line"><span class="comment">			   StringBuffer deleteCharAt(int index) ：移除此序列指定位置的char。 </span></span><br><span class="line"><span class="comment">		● 改   StringBuffer replace(int start, int end, String str) ：使用给定字符串替换序列子字符串中的字符。</span></span><br><span class="line"><span class="comment">        	   void setCharAt(int index, char ch)：将给定索引处的字符设置为 ch。 </span></span><br><span class="line"><span class="comment">		● 查    char charAt(int index)：返回此序列中指定索引处的char值。 </span></span><br><span class="line"><span class="comment">		● 反转  StringBuffer reverse()：将此字符序列用其反转形式取代。 </span></span><br><span class="line"><span class="comment">		● 长度  int length()：返回长度（字符数）。（实际值）</span></span><br><span class="line"><span class="comment">			    int capacity()：返回当前容量。 （理论值）</span></span><br><span class="line"><span class="comment">		● 遍历  String toString() ：返回此序列中数据的字符串表示形式。 </span></span><br><span class="line"><span class="comment">				// for() + charAt()</span></span><br><span class="line"><span class="comment">StringBuffer类的注意事项：</span></span><br><span class="line"><span class="comment">	① StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</span></span><br><span class="line"><span class="comment">	② String、StringBuilder和StringBuffer底层均为字符数组</span></span><br><span class="line"><span class="comment">	③ 执行效率：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">	④ StringBuffe对字符串进行修改时不产生新的对象。调用方法时，本身就被修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Arrays-类"><a href="#6-Arrays-类" class="headerlink" title="6. Arrays 类"></a>6. Arrays 类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arrays类的功能：用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，不需要创建对象，调用起来非常简单。</span></span><br><span class="line"><span class="comment">Arrays类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Arrays;</span></span><br><span class="line"><span class="comment">	②使用：</span></span><br><span class="line"><span class="comment">		Arrays.方法名</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）</span></span><br><span class="line"><span class="comment">		● static 新数组 copyOf(数组，长度)：会将数组赋值给新数组，第二个参数是新数组的长度(直接使用==的话，其实复制的是地址而不是值)，此方法还可以用于扩容。</span></span><br><span class="line"><span class="comment">		● static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序（直接对数组进行了排序，没有返回值，采用的是优化的快速排序）				</span></span><br><span class="line"><span class="comment">		● static &lt;T&gt; List&lt;T&gt;  asList(T... a) 返回一个受指定数组支持的固定大小的列表，【此方法有坑，易错】，</span></span><br><span class="line"><span class="comment">Arrays类的注意事项：</span></span><br><span class="line"><span class="comment">	①如果是数值，sort默认按照升序从小到大；</span></span><br><span class="line"><span class="comment">	②如果是字符串，sort默认按照字母升序；</span></span><br><span class="line"><span class="comment">	③如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建一个数组，并按照 [元素1, 元素2, 元素3...] 格式打印输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arrays));<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：创建一个数组，排序后打印输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            System.out.print(arrays[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//1 2 3 4 5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：asList的坑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(a);</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(b);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1,而不是3，它把整个数组当成了一个整体</span></span><br><span class="line">    System.out.println(integers.size());<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Math-类（包含-BigDecimal）"><a href="#7-Math-类（包含-BigDecimal）" class="headerlink" title="7. Math 类（包含 BigDecimal）"></a>7. Math 类（包含 BigDecimal）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Math类的功能：用于执行基本数学运算的方法，其所有方法均为静态方法，不需要创建对象，调用起来非常简单。</span></span><br><span class="line"><span class="comment">Math类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.Math;（位于java.lang包下，导包可以省略不写）</span></span><br><span class="line"><span class="comment">	②使用：</span></span><br><span class="line"><span class="comment">		Math.方法名</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● static double abs(double num)：获取绝对值。有多种重载。</span></span><br><span class="line"><span class="comment">		● static double ceil(double num)：向上取整。</span></span><br><span class="line"><span class="comment">        ● static double floor(double num)：向下取整。</span></span><br><span class="line"><span class="comment">		● static long round(double num)：四舍五入（注意返回值为整型）。</span></span><br><span class="line"><span class="comment">		● static double random()：返回带正号的double值，该值【大于等于】0.0且【小于】1.0。</span></span><br><span class="line"><span class="comment">		● static double pow(double x,double a)：返回x^a，幂运算，返回值类型为double</span></span><br><span class="line"><span class="comment">		● Math.PI代表近似的圆周率常量（double）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：使用Math中的常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println( Math.abs(-<span class="number">5.6</span>));<span class="comment">//5.6</span></span><br><span class="line">        System.out.println( Math.ceil(<span class="number">4.1</span>));<span class="comment">//5.0</span></span><br><span class="line">        System.out.println( Math.floor(<span class="number">4.9</span>));<span class="comment">//4.0</span></span><br><span class="line">        System.out.println( Math.round(<span class="number">4.6</span>));<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的:BigInteger和BigDecimal</span></span><br><span class="line"><span class="comment">BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算。</span></span><br><span class="line"><span class="comment">初始化：</span></span><br><span class="line"><span class="comment">	①使用静态的valueOf方法，将普通的数值转化为大数</span></span><br><span class="line"><span class="comment">		BigInteger a = BigInteger.valueOf(100)</span></span><br><span class="line"><span class="comment">	② 使用带字符串参数的构造器得到大数</span></span><br><span class="line"><span class="comment">		BigInteger b = new BigInteger(&quot;123456789123456789123456789&quot;)</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	● BigInteger add(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger subtract(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger multiply(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger devide(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger compareTo(BigInteger other)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">2.0</span>-<span class="number">1.1</span>;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">1.0</span>).subtract(BigDecimal.valueOf(<span class="number">0.1</span>));</span><br><span class="line">        System.out.println(a1); <span class="comment">// 0.8999999999999999</span></span><br><span class="line">        System.out.println(a2); <span class="comment">// 0.9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-包装类"><a href="#8-包装类" class="headerlink" title="8. 包装类"></a>8. 包装类</h2><p>为了使基本数据类型的变量具有类的特征，引入了包装类的概念。基本数据类型及其对应的包装类如下所示：</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left"><strong>Integer</strong></td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left"><strong>Character</strong></td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
</tbody></table>
<ul>
<li><input checked="" disabled="" type="checkbox"> 基本数据类型与对应的包装类对象之间的转换【记住自动装箱与自动拆箱】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★基本数据类型----&gt;包装对象【装箱】</span></span><br><span class="line"><span class="comment">	int i = 1;</span></span><br><span class="line"><span class="comment">	Integer i1 = new Integer(i);//通过包装类的构造方法实现</span></span><br><span class="line"><span class="comment">	Integer i2 = Integer.valueOf(i);//使用包装类中的valueOf方法</span></span><br><span class="line"><span class="comment">★包装对象----&gt;基本数据类型【拆箱】</span></span><br><span class="line"><span class="comment">	int num = i1.intValue();//调用包装类的.xxxValue()方法：</span></span><br><span class="line"><span class="comment">自动装箱与自动拆箱：从Java 1.5开始，【基本类型与包装类的装箱、拆箱动作可以自动完成(但类型必须匹配)】例如：</span></span><br><span class="line"><span class="comment">	int i = 1</span></span><br><span class="line"><span class="comment">	Integer i1 = i;//自动装箱。相当于Integer i = Integer.valueOf(i);</span></span><br><span class="line"><span class="comment">	int num = i1; //自动拆箱。 相当于 int num = i1.intValue();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> 基本数据类型与字符串之间的转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★基本数据类型----&gt;String</span></span><br><span class="line"><span class="comment">	方式一：调用字符串重载的valueOf()方法：</span></span><br><span class="line"><span class="comment">		String str = String.valueOf(2.34f);</span></span><br><span class="line"><span class="comment">	方式二：基本数据类型通过+号与””相连接</span></span><br><span class="line"><span class="comment">		String str = 1 + “”;</span></span><br><span class="line"><span class="comment">★String----&gt;基本数据类型</span></span><br><span class="line"><span class="comment">	方式一：通过包装类的构造器实现：</span></span><br><span class="line"><span class="comment">		int i = new Integer(“12”);//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">	方式二：通过包装类的parseXxx(String s)或者valueOf(String s)静态方法</span></span><br><span class="line"><span class="comment">		float f = Float.parseFloat(“12.1”)//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">		float f = Float.valueOf(“12.1”)//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。例如：</span></span><br><span class="line"><span class="comment">	int num = Integer.parseInt(&quot;abc&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>包装类是不可变的，即一旦构造了包装类，就不允许更改包装在其中的值，同时包装类还是 final，因此不能派生它们的子类。</p>
<h2 id="9-日期时间类"><a href="#9-日期时间类" class="headerlink" title="9. 日期时间类"></a>9. 日期时间类</h2><p><em>Date类</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Date类表示特定的瞬间，精确到毫秒。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public Date()：分配Date对象并初始化此对象，表示分配它的时间（即系统当前时间）。</span></span><br><span class="line"><span class="comment">	public Date(long date)：分配Date对象并初始化此对象，表示从基准时间（1970年1月1日00:00:00 GMT）以来的指定毫秒数。</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	★ getTime():返回自1970年1月1日00:00:00 GMT以来，此Date对象表示的毫秒数。</span></span><br><span class="line"><span class="comment">	★ toString():把此Date对象转换为以下形式的 String： 星期 月 日 时：分：秒 日期标准 年</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date); <span class="comment">//Sat Aug 01 11:09:31 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>DateFormat类</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.text.DateFormat是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。由于DateFormat为抽象类，不能直接使用，所以常用其子类java.text.SimpleDateFormat。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	SimpleDateFormat() ：用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 </span></span><br><span class="line"><span class="comment">	SimpleDateFormat(String pattern) ：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。日期和时间格式由日期和时间模式字符串指定。常用模式字母：y年、M月、d日、H时、m分、s秒。模式举例：SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;)</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	★ String format(Date date)：将Date对象按照给定模式格式化为字符串。</span></span><br><span class="line"><span class="comment">	★ Date parse(String source)：将字符串解析为Date对象。(需要异常处理，因为字符串可能没有按照指定模式创建)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);<span class="comment">//格式化日期之前：Sat Aug 01 11:34:53 CST 2020</span></span><br><span class="line">        System.out.println(s.format(date)); <span class="comment">//格式化日期之后：2020年08月01日 11:34:53</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           date = s.parse(<span class="string">&quot;2020年01月01日 00:00:00&quot;</span>);<span class="comment">//将指定模式的字符串解析为一个日期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date); <span class="comment">//解析后的结果：Wed Jan 01 00:00:00 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Calendar类</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Calendar是一个抽象类，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</span></span><br><span class="line"><span class="comment">获取Calendar实例的方法： </span></span><br><span class="line"><span class="comment">	①使用Calendar.getInstance()方法 </span></span><br><span class="line"><span class="comment">	②调用它的子类GregorianCalendar的构造器。</span></span><br><span class="line"><span class="comment">常用方法有：</span></span><br><span class="line"><span class="comment">	★ int get(int field)：返回给定日历字段的值。</span></span><br><span class="line"><span class="comment">	  常见字段YEAR年、MONTH月、HOUR时（12小时制）、MINUTE分、SECOND秒、DAY_OF_MONTH月中的天、HOUR_OF_DAY时（24小时		制）、DAY_OF_WEEK周中的天（周几，周日为1，可以-1使用）</span></span><br><span class="line"><span class="comment">	★ void set(int field, int value)：将给定的日历字段设置为给定值。</span></span><br><span class="line"><span class="comment">	★ abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</span></span><br><span class="line"><span class="comment">	★ Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 西方星期的开始为周日，即周日为1</span></span><br><span class="line"><span class="comment">	② 在Calendar类中，月份的表示是以0-11代表1-12月。</span></span><br><span class="line"><span class="comment">	③ 日期是有大小关系的，时间靠后，时间越大。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));<span class="comment">//2020</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(time);<span class="comment">//Sat Aug 01 16:42:09 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-java-比较器"><a href="#10-java-比较器" class="headerlink" title="10. java 比较器"></a>10. java 比较器</h2><p>在Java 中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题，此时不能直接通过关系运算符（&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;）进行比较，java 有三种实现对象比较的方法：</p>
<p>1）重写 Object 类的 equals() 方法，但不能比较大小，只能比较是否相等。</p>
<p>2）自然排序：继承 Comparable 接口，并实现 compareTo() 方法；</p>
<p>3）定制排序：定义一个单独的对象比较器，继承自 Comparator 接口，实现 compare() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*自然排序</span></span><br><span class="line"><span class="comment">Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 实现Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 </span></span><br><span class="line"><span class="comment">	② 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</span></span><br><span class="line"><span class="comment">    ③ 对于类C的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类C的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与equals一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个学生类，具有的属性为姓名，年龄，成绩，对于学生，首先按照成绩从低到高排序，如果成绩相同，再按照姓名自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.score &gt; s.score)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.score &lt; s.score)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] student = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">        student[<span class="number">0</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">12</span>,<span class="number">90</span>);</span><br><span class="line">        student[<span class="number">1</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">16</span>,<span class="number">80</span>);</span><br><span class="line">        student[<span class="number">2</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">14</span>,<span class="number">90</span>);</span><br><span class="line">        Arrays.sort(student);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; student.length; i++) &#123;</span><br><span class="line">            System.out.println(student[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">16</span>, score=<span class="number">80</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">14</span>, score=<span class="number">90</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">12</span>, score=<span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定制排序</span></span><br><span class="line"><span class="comment">当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序。 </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2 ；如果返回0，表示相等；返回负整数，表示o1 小于o2。</span></span><br><span class="line"><span class="comment">	② 可以将Comparator传递给sort方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</span></span><br><span class="line"><span class="comment">    ③ 可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个学生类，具有的属性为姓名，年龄，成绩，对于学生，首先按照成绩从低到高排序，如果成绩相同，再按照姓名自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;  <span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">                    <span class="keyword">if</span>(s1.score &gt; s2.score)&#123;</span><br><span class="line">                        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1.score &lt;s2.score)&#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型比较错误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Student[] student = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">        student[<span class="number">0</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">12</span>,<span class="number">90</span>);</span><br><span class="line">        student[<span class="number">1</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">16</span>,<span class="number">80</span>);</span><br><span class="line">        student[<span class="number">2</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">14</span>,<span class="number">90</span>);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(student,comparator);<span class="comment">//使用Arrays.sort进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; student.length; i++) &#123;</span><br><span class="line">            System.out.println(student[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">16</span>, score=<span class="number">80</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">14</span>, score=<span class="number">90</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">12</span>, score=<span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-异常"><a href="#六-异常" class="headerlink" title="六. 异常"></a>六. 异常</h1><h2 id="1-异常的概念"><a href="#1-异常的概念" class="headerlink" title="1. 异常的概念"></a>1. 异常的概念</h2><blockquote>
<p>异常是指程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。</p>
</blockquote>
<h2 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2. 异常的分类"></a>2. 异常的分类</h2><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162550.png" style="zoom:50%;" />

<p><code>Throwable</code>：Throwable 类是 Java 语言中所有错误或异常的超类。类中常用方法有：</p>
<ul>
<li><p><u>public void printStackTrace()</u>：打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><u>public String getMessage()</u> ：获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
</ul>
<p><code>Error</code>：程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。比如栈溢出、堆溢出等错误。</p>
<p><code>Exception</code>：程序本身可以捕获并且可以处理的异常。可以分为两大类：</p>
<ul>
<li><u>非受检异常（运行时异常）</u>：指 RuntimeException 类及其子类异常，编译器不会检查此类异常，并且不要求处理异常。程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。比如数组索引越界异常，空指针异常等等。</li>
<li><u>受检异常（编译时异常</u>）：是 RuntimeException 以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。</li>
</ul>
<h2 id="3-常见异常"><a href="#3-常见异常" class="headerlink" title="3. 常见异常"></a>3. 常见异常</h2><ul>
<li><p><code>java.lang.ArrayIndexOutOfBoundsException</code> 数组索引越界异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(array[<span class="number">10</span>]);<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.NullPointerException  </code>空指针异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*当应用程序试图在需要对象的地方使用null时，抛出该异常。这种情况包括：调用 null 对象的实例方法、访问或修改null对象的字段、将null作为一个数组，获得其长度、将null作为一个数组，访问或修改其时间片、将null作为Throwable值抛出。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(string.equals(<span class="literal">null</span>));<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.ClassCastException  </code>类型转换异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当试图将对象强制转换为不是实例的子类时，抛出该异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">//多态</span></span><br><span class="line">        <span class="type">Math</span> <span class="variable">math</span>  <span class="operator">=</span>  (Math) obj; <span class="comment">//编译不报错，但运行会报错</span></span><br><span class="line">        System.out.println(math);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.ArithmeticException</code> 算术异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">0</span>);<span class="comment">//除0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.NumberFormatException</code> 数字格式异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(string1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.valueOf(string2);<span class="comment">//编译不报错</span></span><br><span class="line">        System.out.println(integer1);</span><br><span class="line">        System.out.println(integer2);<span class="comment">//运行报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-异常的处理"><a href="#4-异常的处理" class="headerlink" title="4. 异常的处理"></a>4. 异常的处理</h2><p>异常的处理分为两步：</p>
<p>第一步：<code>抛出异常</code>。程序在正常执行的过程中，如果出现异常，会在异常代码处生成一个对应异常类的对象，并将此对象抛出，其后的代码就不再执行。对于异常对象的产生分为两种：① 系统自动生成的异常对象  ② 手动的生成一个异常对象，并抛出（throw）</p>
<p>第二步：<code>捕获异常</code>。捕获异常分为两种：① try…catch…finally 代码块直接处理  ② 通过 throws 进行声明，让调用者去处理。</p>
<h3 id="（1）try…catch…finally"><a href="#（1）try…catch…finally" class="headerlink" title="（1）try…catch…finally"></a>（1）try…catch…finally</h3><p>通过 try…catch…finally 代码块可以对出现的异常进行指定方式的处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">    try&#123;</span></span><br><span class="line"><span class="comment">        //可能发生异常的代码。</span></span><br><span class="line"><span class="comment">    &#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">        //对异常进行处理</span></span><br><span class="line"><span class="comment">    &#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    &#125;finally&#123;</span></span><br><span class="line"><span class="comment">        //一定要执行的代码</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果执行完try没有发生异常，则执行finally块和finally后面的代码（如果有的话），如果发生异常，则尝试去匹配catch块。</span></span><br><span class="line"><span class="comment">	② 每一个catch块用于捕获并处理一个特定的异常，或者此异常类型的子类。</span></span><br><span class="line"><span class="comment">	③ catch中的异常类型如果有子父类关系，则要求子类一定声明在父类的上面。否则，报错。</span></span><br><span class="line"><span class="comment">	④ 在try结构中声明的变量，再出了try结构以后，就不能再被调用</span></span><br><span class="line"><span class="comment">	⑤ finally块通常是可选的。</span></span><br><span class="line"><span class="comment">	⑥ 无论异常是否发生，异常是否匹配被处理，finally都会执行。</span></span><br><span class="line"><span class="comment">	⑦ finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a / b;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数相除的结果为：&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一条一定会执行的语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一条测试语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入被除数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">请输入除数：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at innerclass.Main.main(Main.java:<span class="number">17</span>)</span><br><span class="line">这是一条一定会执行的语句</span><br><span class="line">这是一条测试语句</span><br><span class="line"><span class="comment">//如果没有try...catch...finally代码块处理异常，那么测试语句则不会输出。</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）throws"><a href="#（2）throws" class="headerlink" title="（2）throws"></a>（2）throws</h3><p>如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常或者由调用者处理更好，则此方法应显示地通过 throws 关键字声明抛出异常，表明该方法本身将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;</span></span><br><span class="line"><span class="comment">    	代码体;</span></span><br><span class="line"><span class="comment">    &#125;	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//调用者自己处理异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> divide(a, b);</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相除的结果为：&quot;</span> + result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一条测试语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException &#123; <span class="comment">//自己进行处理，而是声明交给调用者处理</span></span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入被除数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">请输入除数：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at innerclass.Main.divide(Main.java:<span class="number">26</span>)</span><br><span class="line">	at innerclass.Main.main(Main.java:<span class="number">17</span>)</span><br><span class="line">这是一条测试语句</span><br></pre></td></tr></table></figure>

<h3 id="（3）throw"><a href="#（3）throw" class="headerlink" title="（3）throw"></a>（3）throw</h3><p>Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出 ，即通过 throw 语句手动显式的抛出一个异常。throw 语句的后面必须是一个异常对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用步骤：</span></span><br><span class="line"><span class="comment">	① 异常类名 对象名 = new 异常类名(参数); // 创建一个异常对象。封装一些提示信息(信息可自行编写)。</span></span><br><span class="line"><span class="comment">	  如：ArrayIndexOutOfBoundsException  e  = new ArrayIndexOutOfBoundsException(数组索引越界了！);</span></span><br><span class="line"><span class="comment">	② throw 对象名; // 在方法内使用关键字throw，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</span></span><br><span class="line"><span class="comment">	  如：throw e;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 注意：上述两步可以通过使用匿名对象合二为一，格式为：throw new 异常类名(参数);</span></span><br><span class="line"><span class="comment">	  如：throw new ArrayIndexOutOfBoundsException(数组索引越界了！);</span></span><br><span class="line"><span class="comment">	② throw 仅仅是将异常进行抛出，返回给该方法的调用者并没有进行处理，对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> value(arrays,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">value</span><span class="params">(<span class="type">int</span>[] arrays ,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt;= arrays.length)&#123; <span class="comment">//此时不能返回一个整数，可以考虑抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;数组角标越界了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arrays[num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw 和 throws 的区别：</p>
<p>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。<br>throws 属于异常处理的一种方式，声明在方法的声明处。</p>
<h2 id="5-自定义异常类"><a href="#5-自定义异常类" class="headerlink" title="5. 自定义异常类"></a>5. 自定义异常类</h2><p>在开发中根据自己业务的异常情况来自定义异常类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义步骤：</span></span><br><span class="line"><span class="comment">  ① 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment">  ③ 提供重载的构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 计算一个圆的面积，并自定义一个异常类 RediusException，当输入半径小于0时，抛出异常信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RediusException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RediusException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RediusException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入圆的半径：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">redius</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (redius &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RediusException</span>(<span class="string">&quot;圆的半径不能小于0！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + Math.PI * redius * redius);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(RediusException r)&#123;</span><br><span class="line">            r.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入圆的半径：</span><br><span class="line">-<span class="number">5</span></span><br><span class="line">commonexception.RediusException: 圆的半径不能小于<span class="number">0</span>！</span><br><span class="line">	at first.Main.main(Main.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h1 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h1><h2 id="1-程序、进程与线程"><a href="#1-程序、进程与线程" class="headerlink" title="1. 程序、进程与线程"></a>1. 程序、进程与线程</h2><blockquote>
<p><code>程序</code>：一组计算机能识别和执行的指令，运行于电子计算机上，满足人们某种需求的信息化工具。即一段静态的代码。</p>
<p><code>进程</code>：一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。进程是系统进行资源分配和调度的基本单位，</p>
<p><code>线程</code>：进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。线程是程序执行的最小单位。</p>
</blockquote>
<h2 id="2-多线程的创建"><a href="#2-多线程的创建" class="headerlink" title="2. 多线程的创建"></a>2. 多线程的创建</h2><ul>
<li><p>方式一：继承 Thread 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 创建一个继承于Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</span></span><br><span class="line"><span class="comment">	② 创建Thread子类的对象。</span></span><br><span class="line"><span class="comment">	③ 调用子类对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 启动一个线程，必须调用start()，不能调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">	② 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出异常“IllegalThreadStateException”。</span></span><br><span class="line"><span class="comment">	③ 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().</span></span><br><span class="line"><span class="comment">★Thread类的构造方法：</span></span><br><span class="line"><span class="comment">	Thread() :分配一个新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(String name) :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(Runnable target) :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</span></span><br><span class="line"><span class="comment">★Thread类的常用方法：</span></span><br><span class="line"><span class="comment">	String getName() :获取当前线程名称。</span></span><br><span class="line"><span class="comment">	void setName(String name) :改变线程名称，使之与参数 name 相同 </span></span><br><span class="line"><span class="comment">	void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</span></span><br><span class="line"><span class="comment">	void run() :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="comment">	void join() :等待该线程终止。（在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态） </span></span><br><span class="line"><span class="comment">	static void yield() :暂停当前正在执行的线程对象，并执行其他线程（释放当前CPU的执行权）。 </span></span><br><span class="line"><span class="comment">	static void sleep(long millis) :在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。</span></span><br><span class="line"><span class="comment">	static Thread currentThread() :返回对当前正在执行的线程对象的引用。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">// 第一步：创建一个继承于Thread类的子类，并重写该类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(); <span class="comment">// 第二步：创建Thread子类对象</span></span><br><span class="line">        m1.start(); <span class="comment">// 第三步：启动分线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：实现 Runnable 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span></span><br><span class="line"><span class="comment">	② 创建Runnable实现类的对象。	</span></span><br><span class="line"><span class="comment">	③ 将实现类对象作为Thread类构造方法的参数，创建Thread对象，该Thread对象才是真正的线程对象。</span></span><br><span class="line"><span class="comment">	④ 调用Thread对象的start()方法来启动线程。</span></span><br><span class="line"><span class="comment">注意：在开发中，相较于方式一，优先选择实现Runable接口的方式，因为可以实现“多继承”。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 第一步：定义Runnable接口的实现类，并重写该接口的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();<span class="comment">// 第二步：创建Runnable实现类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(m2); <span class="comment">// 第三步：创建Thread类的对象，构造方法参数为Runnable实现类对象</span></span><br><span class="line">        thread.start(); <span class="comment">// 第四步：通过start()方法启动线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：实现 Callable 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 创建Callable接口的实现类 ，并实现Call方法。</span></span><br><span class="line"><span class="comment">	② 创建Callable实现类的对象。</span></span><br><span class="line"><span class="comment">	③ 将Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line"><span class="comment">	④ 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象。</span></span><br><span class="line"><span class="comment">	⑤ 调用Thread对象的start()方法来启动线程。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① call()方法是有返回值的，可以通过FutureTask的get()方法获取返回值。</span></span><br><span class="line"><span class="comment">	② call()可以抛出异常，被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment">	③ Callable是支持泛型的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123; <span class="comment">// 第一步：创建Callable接口的实现类 ，并实现Call方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 注意有返回值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread3</span> <span class="variable">m3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>(); <span class="comment">// 第二步：创建Callable实现类的对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(m3);<span class="comment">// 第三步：创建FutureTask的对象，Callable实现类的对象为参数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);<span class="comment">// 第四步：创建Thread类的对象，FutureTask类的对象为参数</span></span><br><span class="line">        thread.start();<span class="comment">// 第五步：通过start()方法启动线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get()); <span class="comment">// 获取call()方法的返回值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式四：线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</span></span><br><span class="line"><span class="comment">好处：</span></span><br><span class="line"><span class="comment">	① 降低资源消耗。（减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务）</span></span><br><span class="line"><span class="comment">	② 提高响应速度。（当任务到达时，任务可以不需要等到线程创建就能立即执行）</span></span><br><span class="line"><span class="comment">	③ 提高线程的可管理性。（可以调整线程池中工作线线程的数目，防止内存消耗过多而出现故障）</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	1. 创建线程池对象。（提供指定线程数量的线程池）</span></span><br><span class="line"><span class="comment">	2. 创建 Runnable 接口子类对象。</span></span><br><span class="line"><span class="comment">	3. 提交 Runnable 接口子类对象。</span></span><br><span class="line"><span class="comment">	4. 关闭线程池。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//创建线程池对象</span></span><br><span class="line">	<span class="type">MyThread4</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread4</span>();<span class="comment">//创建Runnable接口子类对象。</span></span><br><span class="line">	service.submit(r);<span class="comment">//提交Runnable接口子类对象。</span></span><br><span class="line">	service.submit(r);</span><br><span class="line">    service.shutdown();<span class="comment">//关闭线程池。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h2><p>一个线程的生命周期包含 5 个状态：新建、就绪、运行、阻塞、死亡。</p>
<ul>
<li><p><code>新建（New）</code>：当线程对象对创建后（new），即进入了新建状态。</p>
</li>
<li><p><code>就绪（Runnable）</code>：当调用线程对象的 start() 方法后，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说此线程立即就会执行；</p>
</li>
<li><p><code>运行（Running）</code>：当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
<li><p><code>阻塞（Blocked）</code>：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行 wait() 方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的 sleep() 或 join() 或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p>
</li>
<li><p><code>死亡（Dead）</code>：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162603.png" style="zoom:80%;" /></li>
</ul>
<h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4. 线程的同步"></a>4. 线程的同步</h2><p>当多个线程共同操作同一块共享数据时，很有可能引发线程安全问题，从而造成数据异常。（一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。）</p>
<p><u>&#x2F;&#x2F; 经典案例：三个窗口共同卖10张票。</u></p>
<p>可能出现两个问题：</p>
<ul>
<li>三个窗口卖出同一张票（比如都卖出了第10号票） </li>
<li>卖出不应该存在的票（比如出现了第-1票）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第-<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>

<p>解决此类问题的思路：<u>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</u>。但是由于操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率比较低。</p>
<p>实现线程同步的方式：</p>
<ul>
<li><p>方式一：同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步代码块：在方法中的某个区块中使用synchronized关键字，表示只对这个区块的资源实行互斥访问。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	synchronized(同步锁)&#123; </span></span><br><span class="line"><span class="comment">		//需要同步操作的代码 </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 任意对象都可以作为同步锁，但是多个线程要使用同一把锁【重要】。</span></span><br><span class="line"><span class="comment">	② 在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)，当线程执行完对应代码块/代码块发生异常后自动释放锁。</span></span><br><span class="line"><span class="comment">	③ 同步代码块的锁除了自己指定外，很多时候也可以指定为this或类名.class</span></span><br><span class="line"><span class="comment">	④ 在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span></span><br><span class="line"><span class="comment">	⑤ 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。	</span></span><br><span class="line"><span class="comment">	⑥ 需要同步操作的代码范围不能太大，也不能太小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public synchronized void method()&#123; </span></span><br><span class="line"><span class="comment">		//可能会产生线程安全问题的代码 </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 对于非static方法,此时的同步锁就是this。</span></span><br><span class="line"><span class="comment">	② 对于static方法,此时的同步锁是方法所在类的字节码对象(类名.class)。</span></span><br><span class="line"><span class="comment">	③ 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123; <span class="comment">// 同步方法</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：Lock 锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lock锁机制：通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	//类中</span></span><br><span class="line"><span class="comment">		Lock 对象名 = new ReentrantLock();//创建对象</span></span><br><span class="line"><span class="comment">	//run方法中</span></span><br><span class="line"><span class="comment">		对象名.lock();//加同步锁</span></span><br><span class="line"><span class="comment">		try&#123;</span></span><br><span class="line"><span class="comment">			//同步代码块</span></span><br><span class="line"><span class="comment">		&#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">			//异常处理</span></span><br><span class="line"><span class="comment">		&#125;finally&#123;</span></span><br><span class="line"><span class="comment">			对象名.unlock();//释放同步锁</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① Lock实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，优先使用Lock锁。</span></span><br><span class="line"><span class="comment">	② java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</span></span><br><span class="line"><span class="comment">	③ ReentrantLock类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</span></span><br><span class="line"><span class="comment">	④ 锁定和取消锁定出现在不同作用范围中时，最好用try-【catch】-finally 加以保护，以确保在必要时释放锁。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();<span class="comment">// 加同步锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">// 释放同步锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure></li>
</ul>
<p>★ Synchronized 和 Lock 的对比：</p>
<ul>
<li>Lock 是显式锁（手动开启和关闭锁），synchronized 是隐式锁，出了作用域自动释放锁。</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ul>
<h2 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5. 线程的通信"></a>5. 线程的通信</h2><blockquote>
<p>多个线程在处理同一个资源时，处理的动作（线程的任务）不相同，线程之间进行通信用来保证线程协调运行，比如控制线程执行先后顺序、获取某个线程执行的结果等</p>
</blockquote>
<p><u>等待唤醒机制</u>：在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒。</p>
<ul>
<li><p><code>wait()</code>：令当前线程挂起，放弃CPU同步资源并等待（此时不会去竞争锁了，处于阻塞状态），使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用 notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p>
</li>
<li><p><code>notify()</code>：唤醒正在排队等待同步资源的线程，如果有多个会任意选择一个唤醒。</p>
</li>
<li><p><code>notifyAll ()</code>：唤醒正在排队等待资源的所有线程结束等待。</p>
</li>
</ul>
<p>注意：</p>
<p>​    ① wait 方法与 notify 方法必须由同一个锁对象调用。只有对应的锁对象可以通过 notify 唤醒使用同一个锁对象调用 wait 方法后的线程。</p>
<p>​    ② wait 方法与 notify 方法是属于 Object 类的方法的。</p>
<p>​    ③ wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用，否则会报异常。因为：必须要通过锁对象调用这2个方法。</p>
<p><u>&#x2F;&#x2F; 经典案例：生产者消费者问题（Producer-consumer problem）</u></p>
<blockquote>
<p>生产者负责生产产品，而消费者负责消费产品。两个线程同时运行，要求产品的个数要大于0个，并小于10个。<br>如果产品个数为0，那么消费者需要等待生产者进行生产（只要生产了1个，消费者就可以继续进行消费）。<br>如果产品个数为10，那么生产者需要等待消费者进行消费（只要消费了1个，生产者就可以继续进行生产）。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Amount</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123; <span class="comment">// 进行消费</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();  <span class="comment">// 如果数量小于等于0时，消费者就进行等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:消费第&quot;</span> + num +<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            num --;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>  &#123; <span class="comment">// 进行生产</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();  <span class="comment">// 如果数量大于等于10时，生产者就进行等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num ++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:生产第&quot;</span> + num +<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">    Amount amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Amount amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            amount.producer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">    Amount amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Amount amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.currentThread().yield();</span><br><span class="line">            amount.consumer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Amount</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amount</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(amount);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(amount);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★sleep() 和 wait()的异同</p>
<p>相同点：一旦执行，都可以使得当前的线程进入阻塞状态。</p>
<p>不同点：</p>
<p>​    1）两个方法声明的位置不同：Thread 类中声明 sleep() , Object 类中声明 wait()</p>
<p>​    2）调用的要求不同：sleep() 可以在任何需要的场景下调用。 wait() 必须使用在同步代码块或同步方法中</p>
<p>​    3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放锁，wait() 会释放锁。</p>
<h1 id="八-枚举"><a href="#八-枚举" class="headerlink" title="八. 枚举"></a>八. 枚举</h1><h2 id="1-自定义枚举类"><a href="#1-自定义枚举类" class="headerlink" title="1. 自定义枚举类"></a>1. 自定义枚举类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">class Season&#123;</span></span><br><span class="line"><span class="comment">    // 1.声明Season对象的属性：private final修饰</span></span><br><span class="line"><span class="comment">    private final String seasonName;</span></span><br><span class="line"><span class="comment">    private final String seasonDesc;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"><span class="comment">    private Season(String seasonName,String seasonDesc)&#123;</span></span><br><span class="line"><span class="comment">        this.seasonName = seasonName;</span></span><br><span class="line"><span class="comment">        this.seasonDesc = seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line"><span class="comment">    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line"><span class="comment">    public String getSeasonName() &#123;</span></span><br><span class="line"><span class="comment">        return seasonName;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getSeasonDesc() &#123;</span></span><br><span class="line"><span class="comment">        return seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // 4.其他诉求2：提供toString()</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public String toString() &#123;</span></span><br><span class="line"><span class="comment">        return &quot;Season&#123;&quot; +</span></span><br><span class="line"><span class="comment">                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意:	</span></span><br><span class="line"><span class="comment">	① 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰；</span></span><br><span class="line"><span class="comment">	② 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值；</span></span><br><span class="line"><span class="comment">	③ 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数；</span></span><br><span class="line"><span class="comment">	④ 如果枚举类中只一个对象，则可以作为单例模式的实现方式；</span></span><br><span class="line"><span class="comment">	⑤ 私有化类的构造器，保证不能在类的外部创建其对象。  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-enum关键字"><a href="#2-enum关键字" class="headerlink" title="2. enum关键字"></a>2. enum关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">enum Season1 &#123;</span></span><br><span class="line"><span class="comment">    // 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line"><span class="comment">    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),</span></span><br><span class="line"><span class="comment">    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;),</span></span><br><span class="line"><span class="comment">    AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;),</span></span><br><span class="line"><span class="comment">    WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2.声明Season对象的属性：private final修饰</span></span><br><span class="line"><span class="comment">    private final String seasonName;</span></span><br><span class="line"><span class="comment">    private final String seasonDesc;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    private Season1(String seasonName,String seasonDesc)&#123;</span></span><br><span class="line"><span class="comment">        this.seasonName = seasonName;</span></span><br><span class="line"><span class="comment">        this.seasonDesc = seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line"><span class="comment">    public String getSeasonName() &#123;</span></span><br><span class="line"><span class="comment">        return seasonName;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getSeasonDesc() &#123;</span></span><br><span class="line"><span class="comment">        return seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类</span></span><br><span class="line"><span class="comment">	② 枚举类的构造器只能使用 private 权限修饰符</span></span><br><span class="line"><span class="comment">	③ 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰</span></span><br><span class="line"><span class="comment">	④ 必须在枚举类的第一行声明枚举类对象</span></span><br><span class="line"><span class="comment">	⑤ 枚举类是线程安全的</span></span><br><span class="line"><span class="comment">	⑥ 每个枚举成员实际上是一个枚举实例。 </span></span><br><span class="line"><span class="comment">Enum类的主要方法：</span></span><br><span class="line"><span class="comment">	① values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</span></span><br><span class="line"><span class="comment">	② valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span></span><br><span class="line"><span class="comment">	③ toString()：返回当前枚举类对象常量的名称</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="九-注解"><a href="#九-注解" class="headerlink" title="九. 注解"></a>九. 注解</h1><blockquote>
<p><code>Annotation</code> 其实就是代码里的特殊标记，这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。注解类同于标签，标签为了解释事物，注解为了解释代码。(如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。)</p>
</blockquote>
<h2 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注解和class、interface一样也是一种类型，通过 @interface 关键字进行定义。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public @interface 注解名&#123;</span></span><br><span class="line"><span class="comment">		成员变量；</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 自定义注解自动继承了java.lang.annotation.Annotation</span></span><br><span class="line"><span class="comment">	② 注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。如：int id();</span></span><br><span class="line"><span class="comment">	③ 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</span></span><br><span class="line"><span class="comment">	④ 如果注解有成员，在使用注解时，需要指明成员的值。除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”。</span></span><br><span class="line"><span class="comment">	⑤ 【重要】自定义注解必须配上注解的信息处理流程(使用反射)才意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Java-预置的注解"><a href="#2-Java-预置的注解" class="headerlink" title="2. Java 预置的注解"></a>2. Java 预置的注解</h2><p><code>@Override</code>:：限定重写父类方法, 该注解只能用于方法<br><code>@Deprecated</code>： 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择<br><code>@SuppressWarnings</code>： 抑制编译器警告</p>
<h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3. 元注解"></a>3. 元注解</h2><p>元注解可以理解为注解的注解。有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p>
<p><code>@Retention </code>当 @Retention 应用到一个注解上的时候，它指定了所修饰的 Annotation 的生命周期，默认为CLASS。取值如下：</p>
<ul>
<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li>
<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li>
<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>
</ul>
<p>对于自定义注解，如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现目的，所以自定义注解中肯定是使用 **@Retention(RetentionPolicy.RUNTIME)**。</p>
<p><code>@Documented</code> 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。</p>
<p><code>@Target</code> 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。取值如下：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
<p><code>@Inherited  </code>  如果父类被 @Inherited 注解过的注解进行了注解，那么当其子类没有被任何注解应用，这个子类就继承了超类的注解。 </p>
<p><code>@Repeatable</code> 被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</p>
<h1 id="十-集合"><a href="#十-集合" class="headerlink" title="十. 集合"></a>十. 集合</h1><h2 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1. 集合概述"></a>1. 集合概述</h2><blockquote>
<p><strong>集合</strong>：java 中提供的一种容器，可以用来存储多个数据，所有集合类都位于 java.util 包下。</p>
</blockquote>
<p>集合和数组的区别：</p>
<ul>
<li>数组的长度不可变，而集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
<li>数组进行插入和删除操作较为麻烦，而集合很方便。</li>
</ul>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p>
<p><code>Collection</code> 接口：单列数据，定义了存取一组对象的方法的集合，它有两个重要的子接口：</p>
<ul>
<li>List：元素有序且可重复的集合，主要实现类有 <strong>ArrayList</strong>  、<strong>LinkedList</strong> 和 Vector 。</li>
<li>Set： 元素无序且不可重复的集合，主要实现类有 <strong>HashSet</strong> 、LinkedHashSet 和 TreeSet  。</li>
</ul>
<p><code>Map</code> 接口：双列数据，保存具有映射关系“key-value”的集合，主要实现类有 <strong>HashMap</strong>，LinkedHashMap，TreeMap。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162634.PNG" style="zoom: 60%;" />

<h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><ul>
<li><p>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</p>
</li>
<li><p>JDK 不提供 Collection 接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</p>
</li>
<li><p>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合( List 和 Set )通用的一些方法，这些方法可用于操作所有的单列集合，常用方法如下：</p>
<ul>
<li><p><code> boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</p>
</li>
<li><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定  collection 中的所有元素都添加到此 collection 中）。</p>
</li>
<li><p><code>void clear()</code> :清空集合中所有的元素。</p>
</li>
<li><p><code>boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</p>
</li>
<li><p><code>boolean removeAll(Collection&lt;?&gt; c)</code> ：移除此 collection 中那些也包含在指定 collection 中的所有元素（差集）。</p>
</li>
<li><p><code>boolean contains(E e)</code>: 通过元素的 equals 方法判断当前集合中是否包含给定的对象。</p>
</li>
<li><p><code>boolean isEmpty()</code>: 判断当前集合是否为空。</p>
</li>
<li><p><code>int size()</code>: 返回集合中有效元素的个数。</p>
</li>
<li><p><code>Object[] toArray()</code>: 把集合中的元素，存储到数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(collection); <span class="comment">//[aaa, bbb, ccc]</span></span><br><span class="line">        <span class="comment">//删</span></span><br><span class="line">        collection.remove(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(collection);<span class="comment">//[aaa, ccc]</span></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        System.out.println(collection.size());<span class="comment">//2</span></span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        collection.clear();</span><br><span class="line">        System.out.println(collection);<span class="comment">//[]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Collection 集合的遍历</p>
<ul>
<li><p>方式一：Iterator 迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	① Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</span></span><br><span class="line"><span class="comment">	② Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</span></span><br><span class="line"><span class="comment">	③ Iterator仅用于遍历集合，本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</span></span><br><span class="line"><span class="comment">	④ 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line"><span class="comment">	⑤ 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></span><br><span class="line"><span class="comment">	⑥ Iterator接口的常用方法如下：</span></span><br><span class="line"><span class="comment">		public E next():返回迭代的下一个元素。</span></span><br><span class="line"><span class="comment">		public boolean hasNext():如果仍有元素可以迭代，则返回 true。</span></span><br><span class="line"><span class="comment">		注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，则会发生异常。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	Iterator 对象名 = 集合名.iterator(); </span></span><br><span class="line"><span class="comment">	while(对象名.hasnext())&#123;  </span></span><br><span class="line"><span class="comment">		System.out.println(iterator.next()); </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//使用多态方式 创建对象</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 添加元素到集合</span></span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator(); <span class="comment">//创建迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            System.out.println(iterator.next()); <span class="comment">//输出迭代出的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：增强 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	① 增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</span></span><br><span class="line"><span class="comment">	② 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	for(元素的数据类型  变量名 : Collection集合or数组)&#123; </span></span><br><span class="line"><span class="comment">  		System.out.println(变量名);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//使用多态方式 创建对象</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 添加元素到集合</span></span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj : collection)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h2><h3 id="（1）List-接口概述"><a href="#（1）List-接口概述" class="headerlink" title="（1）List 接口概述"></a>（1）List 接口概述</h3><blockquote>
<p>List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为 List 集合。List 作为 Collection集合的子接口，不但继承了 Collection 接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。</p>
</blockquote>
<p>List接口特点：</p>
<ul>
<li>元素存取有序。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>带有索引，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的 equals 方法，来比较是否为重复的元素。</li>
</ul>
<h3 id="（2）List-接口常用方法"><a href="#（2）List-接口常用方法" class="headerlink" title="（2）List 接口常用方法"></a>（2）List 接口常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增：</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>： 向列表的尾部添加指定的元素。</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>:  在列表的指定位置插入指定元素</span><br><span class="line">删：</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>: 从此列表中移除第一次出现的指定元素（如果存在）</span><br><span class="line">	E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span><br><span class="line">改：</span><br><span class="line">	E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span><br><span class="line">查：</span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>:返回集合中指定位置的元素。</span><br><span class="line">长度：</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中有效元素的个数。</span><br><span class="line">遍历：</span><br><span class="line">	① Iterator迭代器方式</span><br><span class="line">	② 增强<span class="keyword">for</span>循环</span><br><span class="line">	③ 普通的循环</span><br></pre></td></tr></table></figure>

<h3 id="（3）List接口实现类"><a href="#（3）List接口实现类" class="headerlink" title="（3）List接口实现类"></a>（3）List接口实现类</h3><ul>
<li><p><code>ArrayList</code>：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 Object[] elementData 存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList类的功能：用于实现长度可变的数组。</span></span><br><span class="line"><span class="comment">ArrayList类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.ArrayList;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		ArrayList&lt;引用数据类型&gt; 对象名 = new ArrayList&lt;&gt;();//构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment">		ArrayList&lt;引用数据类型&gt; 对象名 = new ArrayList&lt;&gt;(int initialCapacity);//构造有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">	③使用</span></span><br><span class="line"><span class="comment">    	增删改查长度遍历</span></span><br><span class="line"><span class="comment">ArrayList类的注意事项：</span></span><br><span class="line"><span class="comment">	①对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型，E取自Element（元素）的首字母。使用一种引用数据类型将E其替换即可。</span></span><br><span class="line"><span class="comment">	②泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。（泛型只能是引用类型，不能是基本类型。）</span></span><br><span class="line"><span class="comment">	③对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[]</span></span><br><span class="line"><span class="comment">	④对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合来说，add添加动作不一定成功。</span></span><br><span class="line"><span class="comment">	⑤如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</span></span><br><span class="line"><span class="comment">	⑥ArrayList元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：生成3个范围为[1,10]的随机数字，添加到ArrayList集合中，并遍历输出。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;集合中的元素为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinkedList</code>：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高；底层使用双向链表存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增方法：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。 </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Vector</code>：作为 List 接口的古老实现类；线程安全的，效率低；底层使用 Object[] elementData 存储</p>
<p>与 ArrayList 相似，但是 Vector 是同步的。所以说 Vector 是线程安全的动态数组。它的操作与 ArrayList 几乎一样。</p>
</li>
</ul>
<p> ★ ArrayList 和 LinkedList 的异同</p>
<p>二者都线程不安全，相对线程安全的 Vector，执行效率高。此外，ArrayList 是实现了基于动态数组的数据结构。LinkedList 基于链表的数据结构。对于随机访问 get 和 set，ArrayList 优于 LinkedList，因为 LinkedList 要移动针。对于新增和删除操作 add(特指插入)和 remove，LinkedList 比较占优势，因为 ArrayList 要移动数据。</p>
<h2 id="4-Set-接口"><a href="#4-Set-接口" class="headerlink" title="4. Set 接口"></a>4. Set 接口</h2><h3 id="（1）Set-接口概述"><a href="#（1）Set-接口概述" class="headerlink" title="（1）Set 接口概述"></a>（1）Set 接口概述</h3><blockquote>
<p>Set 接口和 List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。与 List 接口不同的是，Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
</blockquote>
<p>Set 接口特点：</p>
<ul>
<li>元素存取无序。不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是<strong>根据数据的哈希值决定的。</strong></li>
<li>集合中不可以有重复的元素。<strong>保证添加的元素照 equals() 判断时，不能返回 true。</strong></li>
</ul>
<h3 id="（2）Set接口实现类"><a href="#（2）Set接口实现类" class="headerlink" title="（2）Set接口实现类"></a>（2）Set接口实现类</h3><ul>
<li><p><code>HashSet</code>：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值。</p>
<ul>
<li><p>java.util.HashSet 底层的实现其实是一个 java.util.HashMap 支持。</p>
</li>
<li><p>HashSet 是<strong>根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能</strong>。保证元素唯一性的方式依赖于：<u>hashCode与equals方法。两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</u></p>
</li>
<li><p><strong>对于存放在 Set 容器中的对象，对应的类一定要重写 equals() 和 hashCode(Object obj) 方法，以实现对象相等规则。</strong></p>
</li>
<li><p><u>向HashSet中添加元素的过程</u></p>
<ol>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会<strong>调用该对象的 hashCode()方法来得到该对象的hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。</strong>（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</li>
<li><strong>如果两个元素的 hashCode 值相等，会再继续调用 equals 方法，如果 equals 方法结果为 true，添加失败；如果为 false，那么会保存该元素，若该数组的位置已经有元素了，那么会通过链表的方式继续链接。</strong></li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功【因此当重写了 equals 后一定要重写 hashCode】。</li>
</ol>
</li>
<li><p><u>重写 hashCode() 方法的基本原则</u></p>
<ul>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</li>
<li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
</li>
<li><p><u>重写 equals() 方法的基本原则</u></p>
<p> 当一个类有自己特有的“逻辑相等”概念，当改写 equals() 的时候，总是要改写 hashCode()，根据一个类的equals 方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据 Object.hashCode() 方法，它们仅仅是两个对象。因此，违反了“相等的对象必须具有相等的散列码”。 </p>
<p>结论：<strong>重写 equals 方法的时候一般都需要同时复写 hashCode方法</strong>。通常参与计算 hashCode 的对象的属性也应该参与到 equals() 中进行计算。</p>
</li>
<li><p><u>HashSet集合存储数据的结构（哈希表）</u></p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一 hash 值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过 key 值依次查找的效率较低。而 JDK1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  <span class="comment">//自定义学生类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写hashcode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj: hashSet)&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历结果为：<span class="comment">//不可重复，不按插入顺序输出</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;王二&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">20</span>&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinkedHashSet</code>：作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历。</p>
<ul>
<li>LinkedHashSet 是 HashSet 的子类。</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的，在遍历时会按照插入顺序输出。</li>
<li>LinkedHashSet 插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet 不允许集合元素重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  <span class="comment">//自定义学生类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写hashcode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">linkedHashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedHashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历结果为：<span class="comment">//不可重复，按插入顺序输出</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;王二&#x27;</span>, age=<span class="number">24</span>&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TreeSet</code>：可以照添加对象的指定属性，进行排序。</p>
<ul>
<li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</li>
<li>TreeSet 底层使用 红黑树结构存储数据。</li>
<li>TreeSet 支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造 TreeSet时，若使用不带参数的构造函数，则 TreeSet 的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</li>
<li>注意 TreeSet 集合不是通过 hashcode 和 equals 函数来比较元素的。它是通过 compare 或者 comparaeTo 函数来判断元素是否相等。compare 函数通过判断两个对象的 id，相同的 id 判断为重复元素，不会被加入到集合中。</li>
<li>向 TreeSet 中添加的数据，要求是相同类的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自然排序：TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小，然后将集合元素按升序(默认情况)排列。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;  <span class="comment">//先按照学生的age进行排序，如果age相同，再按照姓名自然排序</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; s.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; s.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定制排序，要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; <span class="comment">//先按学生的age排序，如果age相同，再按照姓名自然排序</span></span><br><span class="line">                    <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student  &amp;&amp; o2 <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) o1;</span><br><span class="line">                        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) o2;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (s1.age &gt; s2.age)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1.age &lt; s2.age)&#123;</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(comparator);  <span class="comment">//定制排序</span></span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-Map-接口"><a href="#5-Map-接口" class="headerlink" title="5. Map 接口"></a>5. Map 接口</h2><h3 id="（1）Map-接口概述"><a href="#（1）Map-接口概述" class="headerlink" title="（1）Map 接口概述"></a>（1）Map 接口概述</h3><p> Map 与 Collection 并列存在。用于保存具有映射关系的数据：key-value。</p>
<p>List 接口特点：</p>
<ul>
<li>key 和 value 都可以是任何引用类型的数据</li>
<li>key 用 Set 来存放， 不允许重复，即<strong>同一个 Map 对象所对应的类，必须重写hashCode()和equals()方法</strong>。</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li>
</ul>
<h3 id="（2）Map接口常用方法"><a href="#（2）Map接口常用方法" class="headerlink" title="（2）Map接口常用方法"></a>（2）Map接口常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增：</span><br><span class="line">	V <span class="title function_">put</span><span class="params">(K key, V value)</span>: 把指定的键与指定的值添加到Map集合中。  </span><br><span class="line">删：</span><br><span class="line">	V <span class="title function_">remove</span><span class="params">(Object key)</span>: 移除指定key的key-value对，并返回value(如果存在)</span><br><span class="line">改：</span><br><span class="line">	V <span class="title function_">put</span><span class="params">(K key, V value)</span>: 将指定key-value修改当前map对象中。</span><br><span class="line">查：</span><br><span class="line"> 	V <span class="title function_">get</span><span class="params">(Object key)</span>: 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回<span class="literal">null</span>, 并把指定的键值添加到集合中。 </span><br><span class="line">长度：</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回此映射中的键-值映射关系数。 。</span><br><span class="line">遍历：</span><br><span class="line">	Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="line">	Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</span></span><br><span class="line"><span class="comment">既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</span></span><br><span class="line"><span class="comment"> K getKey()：获取Entry对象中的键。</span></span><br><span class="line"><span class="comment"> V getValue()：获取Entry对象中的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 遍历方式一：KeySet() + get()    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王二&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        Set&lt;String&gt; set = map.keySet(); <span class="comment">//获取所有的键</span></span><br><span class="line">        <span class="keyword">for</span> (String str: set)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key：&quot;</span> + str + <span class="string">&quot;,value：&quot;</span> + map.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">key：李四,value：<span class="number">80</span></span><br><span class="line">key：张三,value：<span class="number">90</span></span><br><span class="line">key：王二,value：<span class="number">90</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 遍历方式二：entrySet() + getkey() getValue()  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王二&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry str: set)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key：&quot;</span> + str.getKey() + <span class="string">&quot;,value：&quot;</span> + str.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">key：李四,value：<span class="number">80</span></span><br><span class="line">key：张三,value：<span class="number">90</span></span><br><span class="line">key：王二,value：<span class="number">90</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）Map接口实现类"><a href="#（3）Map接口实现类" class="headerlink" title="（3）Map接口实现类"></a>（3）Map接口实现类</h3><ul>
<li><p><code>HashMap</code>：作为 Map 的主要实现类；线程不安全的，效率高；可以存储 null 的 key 和 value</p>
<ul>
<li><p>允许使用 null 键和 null 值，与 HashSet 一样，不保证映射的顺序。</p>
</li>
<li><p>所有的 key 构成的集合是 Set：无序的、不可重复的。所以，<u>key所在的类要重写：equals()和hashCode()</u>。</p>
</li>
<li><p>所有的 value 构成的集合是 Collection：无序的、可以重复的。所以，value 所在的类要重写：equals()。</p>
</li>
<li><p>一个 key-value 构成一个 entry，所有的 ntry构成的集合是 Set:无序的、不可重复的</p>
</li>
<li><p>HashMap 判断两个 key 相等的标准是：<u>两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</u></p>
</li>
<li><p>HashMap 判断两个 value 相等的标准是：<u>两个 value 通过 equals() 方法返回 true。</u></p>
</li>
<li><p><u>HashMap 在 jdk7 中实现原理</u>：</p>
<ul>
<li><p>HashMap map &#x3D; new HashMap(); 在实例化以后，底层创建了长度是 16 的一维数组 Entry[] table</p>
</li>
<li><p>map.put(key1,value1); </p>
</li>
<li><p>首先：调用 key1 所在类的 <code>hashCode()</code> 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到</p>
<p>在Entry数组中的存放位置。</p>
<ul>
<li>如果此位置上的数据为空，此时的 key1-value1 添加成功。 【情况1】</li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在))，比较 key1和已经存在的一个或多个数据的哈希值：</li>
<li>如果key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功。【情况2】</li>
<li>如果key1 的哈希值和已经存在的某一个数据 (key2-value2) 的哈希值相同，继续比较：调用 key1 所在类 <code>equals(key2) </code>方法：<ul>
<li>如果equals() 返回false：此时key1-value1添加成功。【情况3】</li>
<li>如果equals() 返回 true：使用 value1 替换 value2。【情况】</li>
</ul>
</li>
</ul>
</li>
<li><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</p>
</li>
</ul>
</li>
<li><p><u>HashMap 在 jdk8 中相较于 jdk7 在底层实现方面的不同</u></p>
<ul>
<li>new HashMap(); 底层默认创建一个长度为16的数组</li>
<li>首次调用put()方法时，底层创建长度为16的数组，jdk8底层的数组是：Node[]，而非Entry[]</li>
<li>jdk7 底层结构：数组+链表。jdk8 中底层结构：<strong>数组+链表+红黑树</strong>。</li>
<li>形成链表时（jdk7：新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ul>
</li>
<li><p><u>HashMap底层典型属性的属性的说明</u></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li>
<li>threshold：扩容的临界值，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li>
</ul>
</li>
</ul>
</li>
<li><pre><code> `LinkedHashMap`：LinkedHashMap 是 HashMap 的子类。在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序，与 LinkedHashSet 类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致。
</code></pre>
</li>
<li><pre><code> `TreeMap`： 保证照添加的 key-value 对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树。
 
 - 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。
 - 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口。
 - TreeMap判断 两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0。
</code></pre>
</li>
<li><pre><code> `Hashtable`：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value，Hashtable 实现原理、功能和 HashMap 相同。
</code></pre>
</li>
</ul>
<h3 id="（4）Collections-工具类"><a href="#（4）Collections-工具类" class="headerlink" title="（4）Collections 工具类"></a>（4）Collections 工具类</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类，就像 Arrays 是操作数组的工具类一样。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法，常用方法如下：</p>
<ul>
<li><p><code>static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>：将所有指定元素添加到指定 collection 中。</p>
</li>
<li><p><code>static void shuffle(List&lt;?&gt; list) </code>：对 List 集合元素进行随机排序。</p>
</li>
<li><p><code>static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：根据元素的自然顺序对指定列表按升序进行排序。</p>
</li>
<li><p><code>static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>：根据指定比较器产生的顺序对指定列表进行排序。</p>
</li>
<li><p><code>static void swap(List&lt;?&gt; list,  int i, int j)</code> ：在指定列表的指定位置处交换元素</p>
</li>
<li><p><code>static void reverse(List&lt;?&gt; list)</code> ：反转指定列表中元素的顺序</p>
</li>
<li><p><code>static Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</p>
</li>
<li><p><code>static Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素。</p>
</li>
<li><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。使用<code>synchronizedList(List list）</code> 和 <code>synchronizedMap(Map map）</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[2, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转</span></span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 3, 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最大小值</span></span><br><span class="line">        System.out.println(Collections.max(arrayList));<span class="comment">//3</span></span><br><span class="line">        System.out.println(Collections.min(arrayList));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机排序</span></span><br><span class="line">        Collections.shuffle(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        Collections.swap(arrayList,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 3, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十一-泛型"><a href="#十一-泛型" class="headerlink" title="十一. 泛型"></a>十一. 泛型</h1><h2 id="1-泛型的概念"><a href="#1-泛型的概念" class="headerlink" title="1. 泛型的概念"></a>1. 泛型的概念</h2><blockquote>
<p>泛型，即“参数化类型”，把类型当作是参数一样传递。就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</p>
</blockquote>
<h2 id="2-泛型的好处"><a href="#2-泛型的好处" class="headerlink" title="2. 泛型的好处"></a>2. 泛型的好处</h2><ul>
<li>泛型将代码安全性检查提前到编译期（程序更加健壮）</li>
<li>泛型能够省去类型强制转换（代码更加简洁）</li>
<li>在编写的时候，就限定了类型（可读性和稳定性更好）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个集合，不使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//没有使用泛型，任何数据类型都可以存储，</span></span><br><span class="line">        arrayList.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) arrayList.get(i);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ① 此程序编译正常，运行时就会出现ClassCastException的异常。</span></span><br><span class="line"><span class="comment">// ② 获取数据元素时，需要类型强制转换。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义一个集合，使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//        arrayList.add(123); //编译报错</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line"><span class="comment">//            String str = (String) arrayList.get(i);</span></span><br><span class="line">            <span class="type">String</span>  <span class="variable">str</span> <span class="operator">=</span> arrayList.get(i); <span class="comment">// 不需要再强制类型转换</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-泛型的定义与使用"><a href="#3-泛型的定义与使用" class="headerlink" title="3. 泛型的定义与使用"></a>3. 泛型的定义与使用</h2><h3 id="（1）泛型类的定义与使用"><a href="#（1）泛型类的定义与使用" class="headerlink" title="（1）泛型类的定义与使用"></a>（1）泛型类的定义与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于类的定义中，被称为泛型类，用户使用该类的时候，才把类型明确下来。</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 class 类名&lt;泛型类型变量&gt; &#123;  </span></span><br><span class="line"><span class="comment">		//代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 一些常用的泛型类型变量：</span></span><br><span class="line"><span class="comment">		E：元素（Element），多用于java集合框架</span></span><br><span class="line"><span class="comment">		K：关键字（Key）</span></span><br><span class="line"><span class="comment">		N：数字（Number）</span></span><br><span class="line"><span class="comment">		T：类型（Type）</span></span><br><span class="line"><span class="comment">		V：值（Value）</span></span><br><span class="line"><span class="comment">	② 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</span></span><br><span class="line"><span class="comment">	③ 泛型类的构造器如下：public GenericClass()&#123;&#125;。而public GenericClass&lt;E&gt;()&#123;&#125;是错误的。</span></span><br><span class="line"><span class="comment">	④ 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</span></span><br><span class="line"><span class="comment">	⑤ 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理，但不等价于 Object。 </span></span><br><span class="line"><span class="comment">	⑥ &lt;数据类型&gt; 只能是引用类型</span></span><br><span class="line"><span class="comment">泛型类的实例化：</span></span><br><span class="line"><span class="comment">	类名&lt;数据类型&gt; 对象名 = new 类名&lt;&gt;(参数列表);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt;  &#123;</span><br><span class="line">    <span class="keyword">private</span> T phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhoneNumber</span><span class="params">(T phoneNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;();</span><br><span class="line">        Student&lt;Long&gt; s2 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;();</span><br><span class="line">        s1.setPhoneNumber(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line"><span class="comment">//      s1.setPhoneNumber(123456789);// 编译报错，类型必须是String</span></span><br><span class="line">        s2.setPhoneNumber(<span class="number">987654321L</span>);</span><br><span class="line">        <span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> s1.getPhoneNumber();<span class="comment">// 不再需要强制类型转换</span></span><br><span class="line">        <span class="type">Long</span>  <span class="variable">str2</span> <span class="operator">=</span> s2.getPhoneNumber();<span class="comment">// 不再需要强制类型转换</span></span><br><span class="line">        System.out.println(str1);<span class="comment">// 123456789</span></span><br><span class="line">        System.out.println(str2);<span class="comment">// 987654321</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）泛型接口的定义与使用"><a href="#（2）泛型接口的定义与使用" class="headerlink" title="（2）泛型接口的定义与使用"></a>（2）泛型接口的定义与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于接口的定义中，被称为泛型接口。</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 interface 接口名&lt;泛型类型变量&gt;&#123;  </span></span><br><span class="line"><span class="comment">		//代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">实现泛型接口：</span></span><br><span class="line"><span class="comment">	方式一：定义类时确定泛型的类型</span></span><br><span class="line"><span class="comment">		修饰符 class 类名 implements 接口名&lt;具体数据类型&gt;&#123;</span></span><br><span class="line"><span class="comment">			//方法重写</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	方式二：定义类时不确定泛型的类型(直到创建对象时，才确定泛型的类型)</span></span><br><span class="line"><span class="comment">		修饰符 class 类名&lt;泛型类型变量&gt; implements 接口名&lt;泛型类型变量&gt;&#123;</span></span><br><span class="line"><span class="comment">			//方法重写</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 自定义泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equipment</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;的USB正在使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Equipment</span> <span class="variable">equipment</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Equipment</span>();</span><br><span class="line">        equipment.use(<span class="string">&quot;电脑&quot;</span>);<span class="comment">// 电脑的USB正在使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）泛型方法的定义与使用"><a href="#（3）泛型方法的定义与使用" class="headerlink" title="（3）泛型方法的定义与使用"></a>（3）泛型方法的定义与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于方法的定义中，被称为泛型方法。</span></span><br><span class="line"><span class="comment">	泛型类，是在实例化类的时候指明泛型的具体类型；</span></span><br><span class="line"><span class="comment">	泛型方法，是在调用方法的时候指明泛型的具体类型 </span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 &lt;泛型类型变量&gt; 返回值类型 方法名(参数) &#123;  </span></span><br><span class="line"><span class="comment">		//方法体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自定义泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;	<span class="comment">// 泛型方法</span></span><br><span class="line">        <span class="keyword">if</span>(t <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个String类型&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个Integer类型&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这既不是一个String类型，也不是一个Integer类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.show(<span class="string">&quot;张三&quot;</span>);<span class="comment">// 这是一个String类型</span></span><br><span class="line">        student.show(<span class="number">123</span>);<span class="comment">// 这是一个Integer类型</span></span><br><span class="line">        student.show(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]);<span class="comment">//这既不是一个String类型，也不是一个Integer类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。</p>
<p>无界通配符：<code>类型名称 &lt;?&gt; 对象名称</code> （可以接收任何类型）</p>
<p>上界通配符：<code>类型名称 &lt;? extends 类 &gt; 对象名称</code> （只能接收该类型及其子类）</p>
<p>下界通配符： <code>类型名称 &lt;? super 类 &gt; 对象名称</code> （只能接收该类型及其父类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</span></span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 测试无界通配符</span></span><br><span class="line">        getElement(list1);</span><br><span class="line">        getElement(list2);</span><br><span class="line">        getElement(list3);</span><br><span class="line">        getElement(list4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试上界通配符</span></span><br><span class="line">        getElement1(list1);</span><br><span class="line"><span class="comment">//      getElement1(list2);// 编译报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line"><span class="comment">//      getElement1(list4);// 编译报错</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 测试下界通配符</span></span><br><span class="line"><span class="comment">//      getElement2(list1);// 编译报错</span></span><br><span class="line"><span class="comment">//      getElement2(list2);// 编译报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无界通配符：任意都可以接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上界通配符：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下界通配符：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二-IO-流"><a href="#十二-IO-流" class="headerlink" title="十二. IO 流"></a>十二. IO 流</h1><h2 id="1-File-类的使用"><a href="#1-File-类的使用" class="headerlink" title="1. File 类的使用"></a>1. File 类的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。  </span></span><br><span class="line"><span class="comment">	public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的File实例。</span></span><br><span class="line"><span class="comment">	public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的File实例。。</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	获取</span></span><br><span class="line"><span class="comment">		public String getAbsolutePath() ：返回此File的绝对路径名字符串。</span></span><br><span class="line"><span class="comment">		public String getPath() ：将此File转换为路径名字符串。 </span></span><br><span class="line"><span class="comment">		public String getName() ：返回由此File表示的文件或目录的名称。  </span></span><br><span class="line"><span class="comment">		public String getParent()：获取上层文件目录路径。若无，返回null。</span></span><br><span class="line"><span class="comment">		public long length() ：返回由此File表示的文件的长度。</span></span><br><span class="line"><span class="comment">	判断</span></span><br><span class="line"><span class="comment">		public boolean exists() ：此File表示的文件或目录是否实际存在。</span></span><br><span class="line"><span class="comment">		public boolean isDirectory() ：此File表示的是否为目录。</span></span><br><span class="line"><span class="comment">		public boolean isFile() ：此File表示的是否为文件。</span></span><br><span class="line"><span class="comment">	创建</span></span><br><span class="line"><span class="comment">		public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </span></span><br><span class="line"><span class="comment">		public boolean mkdir() ：创建由此File表示的目录。</span></span><br><span class="line"><span class="comment">		public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录（如果父目录不存在，一并创建）。</span></span><br><span class="line"><span class="comment">	删除</span></span><br><span class="line"><span class="comment">		public boolean delete() ：删除由此File表示的文件或目录。</span></span><br><span class="line"><span class="comment">    目录的遍历</span></span><br><span class="line"><span class="comment">		public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span></span><br><span class="line"><span class="comment">		public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 一个File对象代表硬盘中实际存在的一个文件或者目录。无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span></span><br><span class="line"><span class="comment">	② File类中涉及到关于文件或文件目录的创建、删除、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</span></span><br><span class="line"><span class="comment">	③ 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的&quot;终点&quot;。</span></span><br><span class="line"><span class="comment">	④ 路径的分类：</span></span><br><span class="line"><span class="comment">		相对路径：相较于某个路径下，指明的路径。（如果用IDEA开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下，如果使用main()测试，相对路径即为当前的Project下）。</span></span><br><span class="line"><span class="comment">		绝对路径：包含盘符在内的文件或文件目录的路径</span></span><br><span class="line"><span class="comment">	⑤ 对于delete方法，如果此File表示目录，则目录必须为空才能删除，且java的删除不走回收站。</span></span><br><span class="line"><span class="comment">	⑥ 路径分隔符</span></span><br><span class="line"><span class="comment">		windows和DOS系统默认使用“\”来表示</span></span><br><span class="line"><span class="comment">		UNIX和URL使用“/”来表示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.getName());  <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file.getParent()); <span class="comment">// D:\IO</span></span><br><span class="line">        System.out.println(file.getAbsolutePath()); <span class="comment">// D:\IO\Hello.txt</span></span><br><span class="line">        System.out.println(file.length()); <span class="comment">// 0,文件是空的，所以长度为0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file.exists()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">// false</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">            System.out.println(newFile);<span class="comment">// false，因为文件已经存在</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> file.delete();</span><br><span class="line">        System.out.println(delete);<span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">                <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹的名称(如果目录下没文件和文件夹，则会报NullPointerException异常)</span></span><br><span class="line">        String[] list = file1.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = file1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-IO-概述"><a href="#2-IO-概述" class="headerlink" title="2. IO 概述"></a>2. IO 概述</h2><h3 id="（1）基本概念-1"><a href="#（1）基本概念-1" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h3><blockquote>
<p>I&#x2F;O 是 Input&#x2F;Output 的缩写， I&#x2F;O 技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。Java程序中，对于数据的输入&#x2F;输出操作以 “流(stream)” ” 的方式进行。</p>
<p>流代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。</p>
</blockquote>
<h3 id="（2）流的分类"><a href="#（2）流的分类" class="headerlink" title="（2）流的分类"></a>（2）流的分类</h3><ul>
<li><p>按数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><p><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </p>
</li>
<li><p><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</p>
</li>
</ul>
</li>
<li><p>按处理数据单位不同分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><p><strong>字节流</strong> ：以字节为单位，读写数据的流（用于操作图片、视频等非文本文件，建议不要操作文本文件，可能会乱码）。</p>
</li>
<li><p><strong>字符流</strong> ：以字符为单位，读写数据的流（只能操作文本文件，不能操作图片，视频等非文本文件。）。</p>
</li>
</ul>
</li>
<li><p>按功能不同分为：<strong>节点流</strong>、<strong>处理流</strong></p>
<ul>
<li><p><strong>节点流</strong>：以从或向一个特定的地方（节点）读写数据。如 FileInputStream</p>
</li>
<li><p><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。<u>处理流的构造方法总是要带一个其他的流对象做参数</u>。一个流对象经过其他流的多次包装。</p>
</li>
</ul>
</li>
</ul>
<p>所有的流都继承下面四个抽象基类，且子类名称是以其父类名作为子类名后缀。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">InputStream</td>
<td align="center">OutputStream</td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">Reader</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<p>IO流体系</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">字节输入流</th>
<th align="center">字节输出流</th>
<th align="center">字符输入流</th>
<th align="center">字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td align="center"><strong><code>InputStream</code></strong></td>
<td align="center"><strong><code>OutputStream</code></strong></td>
<td align="center"><strong><code>Reader</code></strong></td>
<td align="center"><strong><code>Writer</code></strong></td>
</tr>
<tr>
<td>访问文件</td>
<td align="center"><strong><code>FileInputStream</code></strong></td>
<td align="center"><strong><code>FileOutputStream</code></strong></td>
<td align="center"><strong><code>FileReader</code></strong></td>
<td align="center"><strong><code>FileWriter</code></strong></td>
</tr>
<tr>
<td>访问数组</td>
<td align="center">ByteArrayInputStream</td>
<td align="center">ByteArrayOutputStream</td>
<td align="center">CharArrayReader</td>
<td align="center">CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td align="center">PipedInputStream</td>
<td align="center">PipedOutputStream</td>
<td align="center">PipedReader</td>
<td align="center">PipedWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td align="center"><strong><code>BufferedInputStream</code></strong></td>
<td align="center"><strong><code>BufferedOutputStream</code></strong></td>
<td align="center"><strong><code>BufferedReader</code></strong></td>
<td align="center"><strong><code>BufferedWriter</code></strong></td>
</tr>
<tr>
<td>转换流</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong><code>InputStreamReader</code></strong></td>
<td align="center"><strong><code>InputStreamWriter</code></strong></td>
</tr>
<tr>
<td>对象流</td>
<td align="center"><strong><code>ObjectInputStream</code></strong></td>
<td align="center"><strong><code>ObjectOutputStream</code></strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td></td>
<td align="center">FilterInputStream</td>
<td align="center">FilterOutputStream</td>
<td align="center">FilterReader</td>
<td align="center">FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td align="center"></td>
<td align="center">PrintStream</td>
<td align="center"></td>
<td align="center">PrintWriter</td>
</tr>
<tr>
<td>特殊流</td>
<td align="center">DataInputStream</td>
<td align="center">DataOutputStream</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="3-抽象基类"><a href="#3-抽象基类" class="headerlink" title="3. 抽象基类"></a>3. 抽象基类</h2><h3 id="（1）InputStream"><a href="#（1）InputStream" class="headerlink" title="（1）InputStream"></a>（1）InputStream</h3><p>java.io.InputStream 类是字节输入流所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>void close() </code>：关闭此输入流并释放与此流相关联的任何系统资源。(<strong>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应显式关闭文件 IO 资源</strong>。)  </li>
<li><code>abstract int read()</code> ：从输入流读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</li>
<li><code>int read(byte[] b)</code>：从输入流中读取最多 b.length 一些字节数，<u>并将它们存储到字节数组 b 中</u>。如果<u>因为已经到达流末尾而没有可用的字节，则返回值 -1</u>。否则以整数形式返回实际读取的字节数。</li>
<li><code>int read(byte[] b, int off, int len)</code>：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。<u>如果因为流位于文件末尾而没有可用的字节，则返回值 -1</u></li>
</ul>
<h3 id="（2）OutputStream"><a href="#（2）OutputStream" class="headerlink" title="（2）OutputStream"></a>（2）OutputStream</h3><p>java.io.OutputStream 类是字节输出流所有类的超类，将指定字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li>
<li><code>void flush() </code>：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>void write(byte[] b) </code>：将 b.length 字节从指定的字节数组写入此输出流。 </li>
<li><code>void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  </li>
<li><code>abstract void write(int b) </code>：将指定的字节写入此输出流。</li>
</ul>
<h3 id="（3）Reader"><a href="#（3）Reader" class="headerlink" title="（3）Reader"></a>（3）Reader</h3><p>java.io.Reader 类是用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>int read() </code>： 从输入流读取一个字符，自动提升为int类型。 范围在 0 到 65535 之间 ，如果已到达流的末尾，则返回 -1</li>
<li><code>int read(char[] cbuf)</code> ： 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li>
<li><code>int read(char[] cbuf,int off,int len)</code> : 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li>
</ul>
<h3 id="（4）Writer"><a href="#（4）Writer" class="headerlink" title="（4）Writer"></a>（4）Writer</h3><p>java.io.Writer 类是用于写出字符流的所有类的超类，将指定字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> : 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>: 写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>: 写入字符数组的某一部分，off为开始索引，len为字符个数。 入len个字符部分到文件写入器， 从偏移量 off 的位置读取字符数组。</li>
<li><code>void write(String str) </code> : 写入字符串。 </li>
<li><code>void write(String str, int off, int len) </code>:  写入字符串的某一部分，off字符串的开始索引，len写的字符个数。</li>
<li><code>void flush() </code> : 刷新该流的缓冲。  </li>
<li><code>void close()</code> : 关闭此流，但要先刷新它。</li>
</ul>
<h2 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4. 文件流"></a>4. 文件流</h2><h3 id="（1）FileReader类"><a href="#（1）FileReader类" class="headerlink" title="（1）FileReader类"></a>（1）FileReader类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。   </span></span><br><span class="line"><span class="comment">	FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称（底层会调用上面一个构造方法）。</span></span><br><span class="line"><span class="comment">读取文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将已存在的一个文件加载进流。</span></span><br><span class="line"><span class="comment">	② 读入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 在读取文件时，必须保证该文件已存在，否则报异常。</span></span><br><span class="line"><span class="comment">	② 为了能够确定的关闭流，应该使用try-catch-finally处理异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//将一个文件的内容输出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);<span class="comment">// 文本内容为HelloWorld！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读入操作</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fileReader.read(chars)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len)); <span class="comment">// HelloWorld！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流资源</span></span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）FileWriter类"><a href="#（2）FileWriter类" class="headerlink" title="（2）FileWriter类"></a>（2）FileWriter类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。   </span></span><br><span class="line"><span class="comment">	FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。</span></span><br><span class="line"><span class="comment">	FileWriter(String fileName,true)： 创建一个新的 FileWriter，给定要读取的文件的名称。</span></span><br><span class="line"><span class="comment">写入文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将一个文件加载进流（文件可以存在，也可以不存在）。</span></span><br><span class="line"><span class="comment">	② 写入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果不关闭流资源,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">	② 因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush方法了。</span></span><br><span class="line"><span class="comment">		flush ：刷新缓冲区，流对象可以继续使用。</span></span><br><span class="line"><span class="comment">		close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</span></span><br><span class="line"><span class="comment">	③ 在写入一个文件时，如果使用构造器FileWriter(file,false) / FileWriter(file)，则目录下有同名文件将被覆盖。</span></span><br><span class="line"><span class="comment">	④ 如果使用构造器FileWriter(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将abcdefghijklmnopqrstuvwxyz追加到Hello.txt文件末尾，注意不是覆盖。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.写入操作</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;abcdefghijklm&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;nopqrstuvwxyz&quot;</span>);<span class="comment">// 继续写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流资源</span></span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本文件的复制，将Hello.txt文件复制一份为Hello1.txt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建流对象</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcfile);</span><br><span class="line">            fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destfile);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 2.读出写入操作</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len);</span><br><span class="line">                fileWriter.write(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.关闭流资源</span></span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）FileInputStream类"><a href="#（3）FileInputStream类" class="headerlink" title="（3）FileInputStream类"></a>（3）FileInputStream类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileInputStream 类是文件输入流，从文件中读取字节。</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	FileInputStream(File file)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象file命名。 </span></span><br><span class="line"><span class="comment">	FileInputStream(String name)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</span></span><br><span class="line"><span class="comment">读取文件步骤</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将已存在的一个文件加载进流。</span></span><br><span class="line"><span class="comment">	② 读入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）FileOutputStream类"><a href="#（4）FileOutputStream类" class="headerlink" title="（4）FileOutputStream类"></a>（4）FileOutputStream类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。 </span></span><br><span class="line"><span class="comment">	public FileOutputStream(String name) ：创建文件输出流以指定的名称写入文件。</span></span><br><span class="line"><span class="comment">写入文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将一个文件加载进流（文件可以存在，也可以不存在）。</span></span><br><span class="line"><span class="comment">	② 写入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 流的关闭原则：先开后关，后开先关。</span></span><br><span class="line"><span class="comment">	② 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。</span></span><br><span class="line"><span class="comment">	③ 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 非文本文件的复制。将Test.jpg图片复制一份为Test1.jpg</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建流对象</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.读出写入操作</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fileOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.关闭流资源</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5. 缓冲流"></a>5. 缓冲流</h2><p>使用缓冲流的好处是，能够高效的读写信息，原理是<strong>在创建流对象时，会创建一个内置的默认大小（8Kb）的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</li>
<li><input checked="" disabled="" type="checkbox"> 当使用 BufferedInputStream 读取字节文件时，BufferedInputStream 会一次性从文件中读取 8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个 8192 个字节数组。</li>
<li><input checked="" disabled="" type="checkbox"> 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream 才会把缓冲区中的数据一次性写到文件里。使用方法 flush() 可以强制将缓冲区的内容全部写入输出流。</li>
<li><input checked="" disabled="" type="checkbox"> 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。</li>
<li><input checked="" disabled="" type="checkbox"> flush() 方法的使用：手动将buffer中内容写入文件。</li>
<li><input checked="" disabled="" type="checkbox"> 如果是带缓冲区的流对象的 close() 方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</li>
</ul>
<h3 id="（1）字节缓冲流"><a href="#（1）字节缓冲流" class="headerlink" title="（1）字节缓冲流"></a>（1）字节缓冲流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字节缓冲流：BufferedInputStream，BufferedOutputStream </span></span><br><span class="line"><span class="comment">构造方法:</span></span><br><span class="line"><span class="comment">	public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。 </span></span><br><span class="line"><span class="comment">	public BufferedOutputStream(OutputStream out)：创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 非文本文件的复制。将Test.mkv视频（1.15G）复制一份</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 方式一：使用文件流进行大文件的复制</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.mkv&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test1.mkv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.造流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile1);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.复制操作</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = fileInputStream1.read(bytes1))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream1.write(bytes1,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        fileInputStream1.close();</span><br><span class="line">        fileOutputStream1.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end1 - start1);<span class="comment">//5404</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用缓冲流进行大文件的复制</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.mkv&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test2.mkv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.造流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile2);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile2);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream2);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.复制操作</span></span><br><span class="line">        <span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span>((len2 = bufferedInputStream.read(bytes2))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(bytes2,<span class="number">0</span>,len2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end2 - start2);<span class="comment">// 1390，可见缓冲流的效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）字符缓冲流"><a href="#（2）字符缓冲流" class="headerlink" title="（2）字符缓冲流"></a>（2）字符缓冲流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符缓冲流：BufferedReader，BufferedWriter</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public BufferedReader(Reader in) ：创建一个新的缓冲输入流。 </span></span><br><span class="line"><span class="comment">	public BufferedWriter(Writer out)：创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="comment">特有方法：</span></span><br><span class="line"><span class="comment">	★ BufferedReader：public String readLine(): 读一行文字，包含该行内容的字符串，不包含任何行终止符，如果已到达流末		尾，则返回null </span></span><br><span class="line"><span class="comment">	★ BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-转换流"><a href="#6-转换流" class="headerlink" title="6. 转换流"></a>6. 转换流</h2><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。</p>
<p>编码：字符(能看懂的)–字节(看不懂的)</p>
<p>解码：字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li>InputStreamReader ：将InputStream 转换为Reader（字节到字符的桥梁）</li>
<li>OutputStreamWriter ：将Writer 转换为OutputStream（字符到字节的桥梁）</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效。</li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</li>
</ul>
<h3 id="（1）InputStreamReader-类"><a href="#（1）InputStreamReader-类" class="headerlink" title="（1）InputStreamReader 类"></a>（1）InputStreamReader 类</h3><p>转换流<code>java.io.InputStreamReader</code>，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<p>在 IDEA 中，使用<code>FileReader</code> 读取项目中的文本文件。由于 IDEA 的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。可以通过转换流读取 GBK 编码文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </span></span><br><span class="line"><span class="comment">	InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 读取一个GBK编码文件，输出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 方式一：用FileReader类读一个GBK编码文件（会出现乱码问题）</span></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.读操作</span></span><br><span class="line">        <span class="type">char</span>[] chars1 = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = fileReader.read(chars1)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars1,<span class="number">0</span>,len1));<span class="comment">//����һ��GBK�����ļ���</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        fileReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：用InputStreamReader类读取一个GBK编码文件</span></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>)), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.读操作</span></span><br><span class="line">        <span class="type">char</span>[] chars2 = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span>((len2 = inputStreamReader.read(chars2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars2,<span class="number">0</span>,len2));<span class="comment">//这是一个GBK编码文件！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）OutputStreamWriter-类"><a href="#（2）OutputStreamWriter-类" class="headerlink" title="（2）OutputStreamWriter 类"></a>（2）OutputStreamWriter 类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </span></span><br><span class="line"><span class="comment">	OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将一个GBK编码文件复制一份为UTF-8编码文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO1.txt&quot;</span>));</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fileOutputStream,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.读写操作</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStreamWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-对象流（序列化流）"><a href="#7-对象流（序列化流）" class="headerlink" title="7. 对象流（序列化流）"></a>7. 对象流（序列化流）</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>
<p>ObjectOutputStream：内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程</p>
<p>ObjectInputStream：存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</p>
<p>对象的序列化机制：</p>
<blockquote>
<p>对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</p>
</blockquote>
<h3 id="（1）ObjectOutputStream-类"><a href="#（1）ObjectOutputStream-类" class="headerlink" title="（1）ObjectOutputStream 类"></a>（1）ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream </code> 类，将 Java 对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public ObjectOutputStream(OutputStream out) ：创建一个指定OutputStream的ObjectOutputStream。</span></span><br><span class="line"><span class="comment">序列化操作</span></span><br><span class="line"><span class="comment">	一个对象要想序列化，必须满足下面条件:</span></span><br><span class="line"><span class="comment">	① 该类必须实现java.io.Serializable接口，Serializable是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException。</span></span><br><span class="line"><span class="comment">	② 当前类提供一个全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment">	③ 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰。</span></span><br><span class="line"><span class="comment">写出对象方法</span></span><br><span class="line"><span class="comment">	public final void writeObject (Object obj): 将指定的对象写出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将一个Student对象存储到Test.txt文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">684979447754667710L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.txt&quot;</span>));</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">// 2.写操作</span></span><br><span class="line">        objectOutputStream.writeObject(student);</span><br><span class="line">        <span class="comment">// 3.关闭流对象</span></span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）ObjectInputStream类"><a href="#（2）ObjectInputStream类" class="headerlink" title="（2）ObjectInputStream类"></a>（2）ObjectInputStream类</h3><p>ObjectInputStream 反序列化流，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。</span></span><br><span class="line"><span class="comment">反序列化操作：</span></span><br><span class="line"><span class="comment">	如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：</span></span><br><span class="line"><span class="comment">	public final Object readObject () : 读取一个对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将Test.txt文件中的数据读出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.txt&quot;</span>));</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="comment">// 2.写操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(o); <span class="comment">//Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line">        <span class="comment">// 3.关闭流对象</span></span><br><span class="line">        objectInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三-网络编程"><a href="#十三-网络编程" class="headerlink" title="十三. 网络编程"></a>十三. 网络编程</h1><h2 id="1-IP-地址和端口号"><a href="#1-IP-地址和端口号" class="headerlink" title="1. IP 地址和端口号"></a>1. IP 地址和端口号</h2><h3 id="（1）IP-地址"><a href="#（1）IP-地址" class="headerlink" title="（1）IP 地址"></a>（1）IP 地址</h3><blockquote>
<p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。</p>
</blockquote>
<p><u>IP 地址分类</u></p>
<ul>
<li><p>IPv4：是一个 32 位的二进制数，通常被分为 4 个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中 a、b、c、d 都是 0~255 之间的十进制整数，那么最多可以表示 42 亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><u>特殊的 IP 地址</u></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="（2）端口号"><a href="#（2）端口号" class="headerlink" title="（2）端口号"></a>（2）端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说 <strong>IP 地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。 端口与 号与IP 地址的组合得出一个网络套接字：Socket。</p>
<blockquote>
<p>端口号标识正在计算机上运行的进程（程序），用两个字节表示的整数，它的取值范围是 0~65535。</p>
</blockquote>
<p><u>端口分类</u>：</p>
<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP 占用端口 80，FTP 占用端口 21，Telnet 占用端口23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat 占用端口 8080，MySQL 占用端口 3306）</li>
<li>动态&#x2F; 私有端口：49152~65535。</li>
</ul>
<h3 id="（3）InetAddress-类"><a href="#（3）InetAddress-类" class="headerlink" title="（3）InetAddress 类"></a>（3）InetAddress 类</h3><p>InetAddress 类：此类的一个对象就代表着一个具体的 IP 地址，拥有两个子类：Inet4Address、Inet6Address。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress 实例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getLocalHost</span><span class="params">()</span><span class="comment">// 返回本地主机。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getByName</span><span class="params">(String host)</span><span class="comment">// 在给定主机名的情况下确定主机的 IP 地址。</span></span><br><span class="line"><span class="comment">// InetAddress类提供了如下几个常用的方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getHostAddress</span><span class="params">()</span> ：返回IP地址字符串（以文本表现形式）。</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getHostName</span><span class="params">()</span> ：获取此IP地址的主机名</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReachable</span><span class="params">(<span class="type">int</span> timeout)</span>： 测试是否可以达到该地址</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// 返回IP地址字符串（以文本表现形式）</span></span><br><span class="line">        System.out.println(localHost.getHostAddress());</span><br><span class="line">        <span class="comment">// 获取此IP地址的主机名</span></span><br><span class="line">        System.out.println(localHost.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2. 网络协议"></a>2. 网络协议</h2><h3 id="（1）TCP-协议和-UDP-协议"><a href="#（1）TCP-协议和-UDP-协议" class="headerlink" title="（1）TCP 协议和 UDP 协议"></a>（1）TCP 协议和 UDP 协议</h3><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议 (User Datagram Protocol)。UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。</p>
<p>特点:</p>
<ul>
<li>数据被限制在 64kb 以内，超出这个范围就不能发送了。</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
</ul>
</li>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP 协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<p>特点：</p>
<ul>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
<li>TCP 协议进行通信的两个应用进程：客户端、服务端。</li>
</ul>
</li>
</ul>
<h3 id="（2）TCP-通信"><a href="#（2）TCP-通信" class="headerlink" title="（2）TCP 通信"></a>（2）TCP 通信</h3><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p>两端通信时步骤：</p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p>在Java中，提供了两个类用于实现TCP通信程序：</p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接</li>
</ol>
<h3 id="（3）Socket-类"><a href="#（3）Socket-类" class="headerlink" title="（3）Socket 类"></a>（3）Socket 类</h3><blockquote>
<p>Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public Socket(String host, int port)：创建套接字对象并将其连接到指定主机上的指定端口号。</span></span><br><span class="line"><span class="comment">	public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定IP地址的指定端口号</span></span><br><span class="line"><span class="comment">成员方法</span></span><br><span class="line"><span class="comment">	public InputStream getInputStream() ：返回此套接字的输入流。可以用于接收网络消息</span></span><br><span class="line"><span class="comment">	public OutputStream getOutputStream() ： 返回此套接字的输出流。可以用于发送网络消息</span></span><br><span class="line"><span class="comment">	public void close() ：关闭此套接字。一旦一个socket被关闭，它不可再使用。关闭此socket也将关闭相关的InputStream和	 OutputStream。 </span></span><br><span class="line"><span class="comment">	public void shutdownOutput() ： 禁用此套接字的输出流。任何先前写出的数据将被发送，随后终止输出流。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 网络通信其实就是Socket间的通信。</span></span><br><span class="line"><span class="comment">	② Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）ServerSocket类"><a href="#（4）ServerSocket类" class="headerlink" title="（4）ServerSocket类"></a>（4）ServerSocket类</h3><blockquote>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</span></span><br><span class="line"><span class="comment">成员方法：</span></span><br><span class="line"><span class="comment">	public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）简单的TCP通信实例"><a href="#（5）简单的TCP通信实例" class="headerlink" title="（5）简单的TCP通信实例"></a>（5）简单的TCP通信实例</h3><p><u>客户端</u> Socket 的工作过程包含以下四个基本的步骤 ：</p>
<ul>
<li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 Socket 的输入&#x2F; 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输。</li>
<li>按照一定的协议对 Socket 进行读&#x2F; 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li>
<li>关闭 Socket：断开客户端到服务器的连接，释放线路</li>
</ul>
<p><u>服务器</u>程序的工作过程包含以下四个基本的步骤：</p>
<ul>
<li>调用 ServerSocket(int port) ： 创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 accept()： 监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用该 Socket 类对象的 getOutputStream() 和 和 getInputStream ()： 获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭 ServerSocket 和 Socket 对象：客户端访问结束，关闭通信套接字。</li>
</ul>
<p>★<u> TCP 通信分析流程</u></p>
<ol>
<li><p>【服务端】启动,创建 ServerSocket 对象，等待连接。</p>
</li>
<li><p>【客户端】启动,创建 Socket 对象，请求连接。</p>
</li>
<li><p>【服务端】接收连接,调用 accept 方法，并返回一个 Socket 对象。</p>
</li>
<li><p>【客户端】Socket 对象，获取 OutputStream，向服务端写出数据。</p>
</li>
<li><p>【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据。</p>
</li>
<li><p>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</p>
</li>
<li><p>【客户端】Scoket对象，获取InputStream，解析回写数据。</p>
</li>
<li><p>【客户端】释放资源，断开连接。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 【服务端】启动,创建ServerSocket对象，等待连接。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【服务端】接收连接,调用accept方法，并返回一个Socket对象。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));<span class="comment">//这是客户端向服务器发送的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//*************************************************************</span></span><br><span class="line">        <span class="comment">// 【服务端】Socket对象，获取OutputStream，向客户端回写数据。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;这是服务器回写的内容&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        accept.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 【客户端】启动,创建Socket对象，请求连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【客户端】Socket对象，获取OutputStream，向服务端写出数据。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;这是客户端向服务器发送的内容&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭数据的输出[如果不关闭输出，那么客户机收不到服务器发送的消息，因为服务器仍然继续等待客户机发送内容]</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//*************************************************************</span></span><br><span class="line">        <span class="comment">// 【客户端】Scoket对象，获取InputStream，解析回写数据。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));<span class="comment">//这是服务器回写的内容</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【客户端】释放资源，断开连接</span></span><br><span class="line">        socket.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四-反射"><a href="#十四-反射" class="headerlink" title="十四. 反射"></a>十四. 反射</h1><blockquote>
<p>Java 的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p>
</blockquote>
<h2 id="1-Class-类的理解"><a href="#1-Class-类的理解" class="headerlink" title="1. Class 类的理解"></a>1. Class 类的理解</h2><p>类的加载过程：</p>
<p>程序经过 javac.exe 命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用 java.exe 命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为 Class 的一个实例。换句话说，Class 的实例就对应着一个运行时类。加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p>
<h2 id="2-获取反射中的-Class-对象"><a href="#2-获取反射中的-Class-对象" class="headerlink" title="2. 获取反射中的 Class 对象"></a>2. 获取反射中的 Class 对象</h2><p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<ul>
<li><p>方法一：<u>使用 Class.forName 静态方法</u>：若已知一个类的全路径名（包名.类名），可通过 Class 类的静态方法forName() 获取，可能抛出异常。例如：Class clz &#x3D; Class.forName(“java.lang.String”);</p>
<p>将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</p>
</li>
<li><p>方法二：<u>使用 .class 方法</u>。若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。例如：Class clz &#x3D; String.class;</p>
<p>多用于参数的传递</p>
</li>
<li><p>方法三：<u>使用类对象的 getClass() 方法</u>。若已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象。<br>例如：String str &#x3D; new String(“Hello”); Class clz &#x3D; str.getClass();</p>
<p>getClass() 方法在 Object 类中定义着。多用于对象的获取字节码的方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 方法一：使用 Class.forName 静态方法。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflectiontest.Student&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法二：使用.class方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 方法三：使用类对象的 getClass()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> student.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建运行时类的对象"><a href="#3-创建运行时类的对象" class="headerlink" title="3. 创建运行时类的对象"></a>3. 创建运行时类的对象</h2><p>通过反射创建类对象主要有两种方法：</p>
<ul>
<li><p>方法一：<u>通过 Class 对象的 newInstance() 方法。</u>内部调用了运行时类的空参的构造器。要求：<br>① 运行时类必须提供空参的构造器<br>② 空参的构造器的访问权限得够。通常，设置为 public。</p>
</li>
<li><p>方法二：<u>通过 Constructor 对象的 newInstance() 方法。</u>通过 Constructor 对象创建类对象可以选择特定构造方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一：通过 Class 对象的 newInstance() 方法。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        System.out.println(o);<span class="comment">// Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二：通过 Constructor 对象的 newInstance() 方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor1</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> declaredConstructor1.newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> declaredConstructor2.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">        System.out.println(o2);<span class="comment">// Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-获取类属性、方法、构造器"><a href="#4-获取类属性、方法、构造器" class="headerlink" title="4. 获取类属性、方法、构造器"></a>4. 获取类属性、方法、构造器</h2><h3 id="（1）获取类属性"><a href="#（1）获取类属性" class="headerlink" title="（1）获取类属性"></a>（1）获取类属性</h3><ul>
<li><p><u>获取类的全部属性</u></p>
<p>使用 Class 对象的 <code>public Field[] getFields() </code>方法可以获取 Class 类的所有 public 属性，无法获取私有属性。</p>
<p>使用 Class 对象的 <code>public Field[] getDeclaredFields() </code>方法则可以获取包括私有属性在内的所有属性。</p>
</li>
<li><p><u>获取类的指定属性</u></p>
<p><code>public Field getField(String name)</code> 返回此 Class 对象表示的类或接口的指定的 public 的 Field。</p>
<p><code>public Field getDeclaredField(String name)</code> 返回此 Class 对象表示的类或接口的指定的 Field。</p>
<p>在反射机制中，可以直接通过 Field 类操作类中的属性，通过 Field 类提供的 set() 和 get() 方法就可以完成设置和取得属性内容的操作。<br><code>public Object get (Object obj)</code>  取得指定对象 obj 上此 Field 的属性内容<br><code>public void set (Object obj,Object value)</code>  设置指定对象 obj 上此 Field 的属性内容。</p>
<p>★注意：</p>
<p>对于私有属性，使用 get，set 时，先使用 <code>Filed对象.setAccessible(true)</code>; 以保证当前属性是可访问的，如果不设置，则不能访问私有属性。</p>
<ul>
<li>Method 和 Field、Constructor 对象都有 setAccessible() 方法。</li>
<li>setAccessible 启动和禁用访问安全检查的开关。</li>
<li>参数值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true。使得原本无法访问的私有成员也可以访问</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有属性&quot;</span>);</span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f :fields)&#123;</span><br><span class="line">            System.out.println(f);<span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部属性&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:declaredFields)&#123;</span><br><span class="line">            System.out.println(f);<span class="comment">// private java.lang.String reflectiontest.Student.name </span></span><br><span class="line">            					  <span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有属性&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(age);<span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        age.set(student,<span class="number">18</span>);</span><br><span class="line">        System.out.println(age.get(student));<span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意属性&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);<span class="comment">// private java.lang.String reflectiontest.Student.name</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);<span class="comment">// 暴力反射，保证当前属性是可访问的，如果不设置，则不能访问私有属性★</span></span><br><span class="line">        name.set(student,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(name.get(student));<span class="comment">// 张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）获取类方法"><a href="#（2）获取类方法" class="headerlink" title="（2）获取类方法"></a>（2）获取类方法</h3><ul>
<li><p><u>获取类的全部方法</u></p>
<p><code>public Method[] getDeclaredMethods()</code> 返回此 Class 对象所表示的类或接口的全部方法。</p>
<p><code>public Method[] getMethods()</code> 返回此 Class 对象所表示的类或接口的 public 的方法（包含其父类和父接口的 public 方法）。</p>
</li>
<li><p><u>获取类的指定方法</u></p>
<p>通过反射，调用类中的方法，通过 Method 类完成。步骤：</p>
<ul>
<li><p>使用<code>public Method getMethod(String name,Class…parameterTypes)</code> 返回此 Class 对象表示的类或接口的指定的 public 的 Method。参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</p>
<p>或使用<code>public Method getDeclaredMethod(String name,Class…parameterTypes)</code> 返回此 Class 对象表示的类或接口的指定的 Method。</p>
</li>
<li><p>之后使用 <code>Object invoke (Object obj, Object[] args) </code> 进行调用，并向方法中传递要设置的 obj对象的参数信息</p>
<p>说明：<br>① Object 对应原方法的返回值，若原方法无返回值，此时返回 null<br>② 若原方法若为静态方法，此时形参 Object obj 可为 null<br>③ 若原方法形参列表为空，则Object[] args为null<br>④ <u>若原方法声明为 private，则需要在调用此 invoke() 方法前，显式调用方法对象的 setAccessible(true)方法，才可访问。</u></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有方法&quot;</span>);</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部方法&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有方法&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">sleep</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(sleep);<span class="comment">// public void reflectiontest.Student.sleep()</span></span><br><span class="line">        sleep.invoke(student);<span class="comment">// 学生在睡觉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意方法&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">study</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;study&quot;</span>);</span><br><span class="line">        System.out.println(study);<span class="comment">// private void reflectiontest.Student.study()</span></span><br><span class="line">        study.setAccessible(<span class="literal">true</span>);<span class="comment">// 保证当前方法是可访问的，如果不设置，则不能访问私有方法★</span></span><br><span class="line">        study.invoke(student);<span class="comment">// 学生在学习</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（3）获取类构造器"><a href="#（3）获取类构造器" class="headerlink" title="（3）获取类构造器"></a>（3）获取类构造器</h3><ul>
<li><p><u>获取类的全部构造器</u></p>
<p><code>public Constructor&lt;T&gt;[] getConstructors()</code> 返回此 Class 对象所表示的类的所有 public 构造方法。</p>
<p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code> 返回此 Class 对象表示的类声明的所有构造方法。</p>
</li>
<li><p><u>获取类的指定构造器</u></p>
<p><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>  返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。参数指明构造器的参数列表</p>
<p><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</p>
</li>
<li><p>调用构造方法：</p>
<p>Constructor–&gt;newInstance(Object… initargs)</p>
<p>newInstance是 Constructor类的方法（管理构造函数的类）</p>
<p>api 的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p>
<p>它的返回值是 T 类型，所以 newInstance 是创建了一个构造方法的声明类的新实例对象，并为之调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有构造器&quot;</span>);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            System.out.println(c);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部构造器&quot;</span>);</span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有构造器&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor);<span class="comment">// public reflectiontest.Student(java.lang.String,int)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(o);<span class="comment">// Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意构造器&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(declaredConstructor);<span class="comment">// public reflectiontest.Student(java.lang.String,int)</span></span><br><span class="line"><span class="comment">//        declaredConstructor.setAccessible(true);// 保证当前方法是可访问的，如果不设置，则不能访问私有构造器★</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> declaredConstructor.newInstance(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// Student&#123;name=&#x27;李四&#x27;, age=20&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
