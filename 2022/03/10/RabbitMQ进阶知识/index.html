<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tiger_32_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tiger_16_16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"snipercoding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 消息可靠性可靠性是评估消息队列优劣的一个重要标准之一，在一些核心业务，尤其是一些涉及到 money 方面的一些业务中，可靠性至关重要！消息队列在传递消息的过程中要保证消息的不丢失。在消息的传递过程中，涉及到生产者、RabbitMQ和消费者，那么消息可能在哪些情况下丢失呢？主要有以下三个方面：">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ进阶知识">
<meta property="og:url" content="https://snipercoding.github.io/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="SniperCoding的个人博客">
<meta property="og:description" content="1. 消息可靠性可靠性是评估消息队列优劣的一个重要标准之一，在一些核心业务，尤其是一些涉及到 money 方面的一些业务中，可靠性至关重要！消息队列在传递消息的过程中要保证消息的不丢失。在消息的传递过程中，涉及到生产者、RabbitMQ和消费者，那么消息可能在哪些情况下丢失呢？主要有以下三个方面：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220224.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220215.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220210.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220203.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220200.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220153.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220145.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220139.png">
<meta property="article:published_time" content="2022-03-10T06:52:38.000Z">
<meta property="article:modified_time" content="2022-03-20T14:17:51.191Z">
<meta property="article:author" content="SniperCoding">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220224.png">

<link rel="canonical" href="https://snipercoding.github.io/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ进阶知识 | SniperCoding的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
 
   <script async type="text/javascript" src="/js/fireworks.js"></script>    

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SniperCoding的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://snipercoding.github.io/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SniperCoding">
      <meta itemprop="description" content="请不要假装很努力，因为结果不会陪你演戏！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SniperCoding的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ进阶知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-10 14:52:38" itemprop="dateCreated datePublished" datetime="2022-03-10T14:52:38+08:00">2022-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-20 22:17:51" itemprop="dateModified" datetime="2022-03-20T22:17:51+08:00">2022-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RabbitMQ/" itemprop="url" rel="index"><span itemprop="name">RabbitMQ</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-消息可靠性"><a href="#1-消息可靠性" class="headerlink" title="1. 消息可靠性"></a>1. 消息可靠性</h1><p>可靠性是评估消息队列优劣的一个重要标准之一，在一些核心业务，尤其是一些涉及到 money 方面的一些业务中，可靠性至关重要！消息队列在传递消息的过程中要保证消息的不丢失。在消息的传递过程中，涉及到生产者、RabbitMQ和消费者，那么消息可能在哪些情况下丢失呢？主要有以下三个方面：</p>
<span id="more"></span>

<ul>
<li><strong>消息在生产者到 RabbitMQ 的传递之间丢失。</strong></li>
<li><strong>RabbitMQ 宕机，导致消息丢失。</strong></li>
<li><strong>消费者发生异常，导致消息丢失。</strong></li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220224.png" alt="image-20220319100542408" style="zoom: 80%;" />

<p>相对应的解决方案如下：</p>
<ul>
<li>生产者丢失消息<ul>
<li>开启 RabbitMQ 事务（同步）</li>
<li>开启 confirm 机制（异步，推荐）</li>
</ul>
</li>
<li>RabbitMQ 丢失消息：开启 RabbitMQ 持久化</li>
<li>消费者丢失消息：采用 ack 机制。</li>
</ul>
<h2 id="1-1-生产者丢失消息"><a href="#1-1-生产者丢失消息" class="headerlink" title="1.1 生产者丢失消息"></a>1.1 生产者丢失消息</h2><blockquote>
<p>在生产者将消息投递给消息队列时，可能出现以下问题：</p>
<ol>
<li>外界环境问题导致：发生<u>网络丢包、网络故障</u>等造成消息丢失。</li>
<li>代码层面，配置层面，考虑不全导致消息丢失，比如<u>发送给不存在的交换器、发送给路由不到的队列。</u></li>
</ol>
</blockquote>
<p>一般来说，可采用以下两个方案解决消息丢失问题：</p>
<p><strong>事务机制</strong></p>
<ul>
<li>RabbitMQ 提供了事务功能，生产者发送数据之前开启 RabbitMQ 事务 <code>channel.txSelect()</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，中间出现了某些问题，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback()</code> ，重新发送消息；如果 RabbitMQ 收到了消息，那么可以提交事务 <code>channel.txCommit()</code> 。</li>
<li>优点在于事务操作可以保证消息一定能够发送到RabbitMQ中，发送端不会出现消息丢失的情况；</li>
<li>缺点在于事务机制是阻塞（同步）的，每次发送消息必须要等到mq回应之后才能继续发送消息，<u>生产者生产消息的吞吐量和性能都会大大降低。</u></li>
</ul>
<p><strong>confirm 机制（推荐）</strong></p>
<ul>
<li><p>由于事务操作会大大降低生产者的性能，RabbitMQ 提供了一种<code>confirm</code>机制来避免消息发送给 MQ 的过程中出现丢失情况，并且这种机制是『异步的』，<u>在发送完一个消息后可以继续发送下一个消息，MQ 接收到消息后会异步回调接口告知消息接收结果</u>，克服了事务『同步』所固有的缺点。</p>
</li>
<li><p>具体而言，生产者开启 <code>confirm</code> 机制后，为每个消息指定一个唯一的id，如果消息成功发送到了 MQ 中，那么 MQ 就会返回 一个 <strong>ack</strong> 消息，表示消息接收成功，反之会返回一个 <strong>nack</strong> 消息，表示消息接收失败，可以进行重试。依据这个机制，我们可以维护每个消息 id 的状态，如果超过一定时间还是没有接收到 MQ 的回调，那么就重发消息。</p>
</li>
<li><p>在 SpringBoot 配置文件中，配置以下内容</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启消息到达exchange的回调，发送成功失败都会触发回调</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span>	<span class="comment"># 开启消息从exhcange路由到queue的回调，只有路由失败时才会触发回调</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span>	<span class="comment"># 如果exchange根据routingKey将消息路由到queue时找不到匹配的queue，触发return回调，为false时，exchange直接丢弃消息。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>publisher-confirm-type  </code>可以设置为三种类型：simple、correlated,、none;</p>
<ul>
<li>NONE 值是禁用发布确认模式，默认值。</li>
<li>CORRELATED 值是<strong>发布消息成功&#x2F;失败到交换器后会触发回调方法 ConfirmCallback</strong>。</li>
<li>SIMPLE 值是同步等待 confirm 结果，直到超时。</li>
</ul>
<p>我们可以在 RabbitTemplate 配置 ConfirmCallBack 回调函数，用于接收 MQ 返回的回调信息。可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么可以重发消息。</p>
</li>
<li><p><code>publish-returns</code>：开启消息<strong>从交换机到队列的回调</strong>，只有路由失败时才会触发回调。我们可以在 RabbitTemplate 配置 ReturnCallback 回调函数。</p>
</li>
<li><p><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</p>
</li>
<li><p>总结：</p>
<ul>
<li>消息正确到达<u>交换机</u>，触发ConfirmCallback 回调，返回 ack，消息没有正确到达交换机，触发ConfirmReturnCallback 回调，返回 nack，并带有异常信息（比如交换机不存在）；</li>
<li>当消息正确发送交换机后，如果消息正确的从交换机路由到<u>队列</u>，不触发 ReturnCallback 回调，而消息没有正确的从交换机路由到队列，在设置 mandory&#x3D;true 的情况下，触发 ReturnCallback 回调（比如队列不存在）；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;exchange-name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String exchangeName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 配置ConfirmCallBack 回调函数</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback((correlationData, ack, cause)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;消息&#123;&#125;接收成功&quot;</span>,correlationData.getId());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;消息&#123;&#125;接收失败，原因&#123;&#125;&quot;</span>,correlationData.getId(),cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">// 2.配置ReturnCallback 回调函数</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey)-&gt;&#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息&#123;&#125;发送失败，应答码&#123;&#125;，原因&#123;&#125;，交换机&#123;&#125;，路由键&#123;&#125;&quot;</span>,message.toString(),replyCode,replyText,exchange,routingKey);</span><br><span class="line">        &#125;);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 3.发送消息，注意每个消息要指定一个唯一的id</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">            rabbitTemplate.convertAndSend(exchangeName,<span class="string">&quot;&quot;</span>,<span class="string">&quot;消息==&gt;&quot;</span>+i,correlationData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>注意：事务机制和确认机制二者不能共存！</p>
<h2 id="1-2-RabbitMQ-丢失消息"><a href="#1-2-RabbitMQ-丢失消息" class="headerlink" title="1.2 RabbitMQ 丢失消息"></a>1.2 RabbitMQ 丢失消息</h2><blockquote>
<p>RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的。如果消息已经由生产者传递到了 RabbitMQ 的队列中，而消费者还没来得及消费时，RabbitMQ 意外宕机，此时消息就会丢失。</p>
</blockquote>
<p>解决方法就是<strong>开启 RabbitMQ 持久化功能</strong>。消息到达队列后，将其持久化到磁盘中，那么即使 RabbitMQ 意外宕机了，也能在重启后自动从磁盘中读取数据，恢复原始消息。</p>
<p>持久化分为以下三个步骤：</p>
<ol>
<li><p><strong>交换机设置持久化。</strong></p>
<p>SpringAMQP 中可以通过以下代码指定交换机持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">simpleExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;simple.direct&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 声明的交换机都是持久化的，不用特意指定。</p>
</li>
<li><p><strong>队列设置持久化。</strong></p>
<p>SpringAMQP 中可以通过代码指定交换机持久化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">simpleQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 使用QueueBuilder构建队列，durable就是持久化的</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;simple.queue&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 声明的队列都是持久化的，不用特意指定。</p>
</li>
<li><p><strong>消息设置持久化。</strong></p>
<p>利用 SpringAMQP 发送消息时，可以设置消息的属性（MessageProperties），指定 delivery-mode：</p>
<ul>
<li>1 代表非持久化（NON_PERSISTENT）</li>
<li>2 代表持久化（PERSISTENT）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDurableMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello, spring&quot;</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class="line">        .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 2.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，默认情况下，由 SpringAMQP 发出的消息都是持久化的，不用特意指定。</p>
</li>
</ol>
<p>注意：即使 RabbitMQ 开启了持久化机制，也<u>存在丢失数据的一种可能</u>，即消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。解决方案是持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code> ，那么生产者也可以重发消息。</p>
<h2 id="1-3-消费者丢失消息"><a href="#1-3-消费者丢失消息" class="headerlink" title="1.3 消费者丢失消息"></a>1.3 消费者丢失消息</h2><blockquote>
<p>如果消费者收到消息后没来得及处理或者在处理过程中出现了异常（比如重启或断电等），此时消费者进程挂掉了，而 RabbitMQ 不知道消费者挂掉了，以为消息已经成功被消费了，就会从队列中删除消息，从而导致消息丢失。</p>
</blockquote>
<p>解决方法是<strong>采用 RabbitMQ 提供的 ack 确认机制</strong>。当消费者获取消息后，需要向 RabbitMQ 发送 <code>ack</code> 回执，表明自己已经处理消息。没有收到 ACK 的消息，消费者断开连接后，RabbitMQ 会把这条消息发送给其他消费者。如果没有其他消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑。其中 <code>ack</code> 在 AMQP 中有三种确认模式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  <span class="comment"># none，关闭ack；manual，手动ack；auto：自动ack</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>manual</strong>：手动 ack，需要在业务代码结束后，调用 api （basicAck&#x2F;basicNack ）发送 ack&#x2F;nack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;&quot;$&#123;queue-name&#125;&quot;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">msgConsumer</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            log.info(<span class="string">&quot;消息&#123;&#125;消费成功&quot;</span>,msg);</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;接收消息过程中出现异常，执行nack&quot;</span>);</span><br><span class="line">            <span class="comment">// 第三个参数为true表示异常消息重新返回队列，会导致一直在刷新消息，且返回的消息处于队列头部，影响后续消息的处理</span></span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>auto</strong>：自动 ack（默认），由 spring 监测 listener 代码是否出现异常，没有异常则返回 ack，反之返回 nack。</p>
<p>注意：如果消费者执行异常的话，就相当于执行了 nack 方法，消息会requeue（重新入队）到队列头部，然后再次发送给消费者，但是可能消费者继续出现异常，周而复始，消息会被无限期的执行，从而导致后续的消息无法消费。发生这种原因所在便是因为 RabbitMQ的<code>消息失败重试机制</code>。但是在很多情况下，我们并不想无限重试，而是重试到一定阈值后，就认为此消息无法被正确处理，就放弃处理或专用人工处理等。</p>
<p>为了解决这一问题，我们可以在配置文件中对 RabbitMQ 的消息重试（retry）进行重新配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span>  	<span class="comment"># 消费者自动ack消息确认</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>            	<span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="number">1000</span>  	<span class="comment"># 初始失败重试间隔</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">3</span>				<span class="comment"># 失败的等待时长配置，下次重试间隔= multiplier * initial-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">4</span>   		<span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure>

<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：</p>
<ul>
<li>RejectAndDontRequeueRecoverer：（默认）重试耗尽后，直接 reject，丢弃消息。</li>
<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回 nack，消息重新入队</li>
<li>RepublishMessageRecoverer：（推荐）重试耗尽后，将失败消息投递到指定的交换机</li>
</ul>
<p>可以看出前两种实现都不太好，推荐第三种方式，当重试几次后，仍然得不到好的处理，就将无法被正确处理的消息投递到指定的交换机中，然后在存储到专门用于存储异常消息的队列中，后续可采取人工方式进行集中处理！</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220215.png" alt="image-20220319155905258" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常消息的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常消息的队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定异常交换机和队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorMessageBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorMessageExchange()).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置失败消息投递到指定的交换机和Routing key</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>none</strong>：关闭 ack，MQ 在消息投递后会立即删除消息。</p>
</li>
</ul>
<h1 id="2-消息有效期"><a href="#2-消息有效期" class="headerlink" title="2. 消息有效期"></a>2. 消息有效期</h1><p>默认情况下，RabbitMQ中的消息是不会过期的，即使消息没被消费掉，也会一直存储在队列中。</p>
<h2 id="2-1-TTL"><a href="#2-1-TTL" class="headerlink" title="2.1 TTL"></a>2.1 TTL</h2><p>如果我们想给消息指定一个有效时间，那么通过指定TTL（<strong>Time-To-Live，即存活时间</strong>）来实现，当消息在队列中的存活时间超过指定的 TTL 时（注意是从入队时开始算），这个消息就会被清除。</p>
<p>RabbitMQ 支持以下两种方式设置 TTL：</p>
<ul>
<li><p>在声明队列时，<u>指定此队列中消息的有效期</u>，那么所有进入该队列的消息都会有一个相同的有效期。</p>
<p><u>当消息过期了就会被立马删除</u>，因为消息进入 RabbitMQ 后是存在一个消息队列中，队列的头部是最早要过期的消息，所以 RabbitMQ 只需要一个定时任务，从头部开始扫描是否有过期消息，有的话就直接删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定队列中消息的有效期，下面两种方式均可以</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">        .durable(<span class="string">&quot;ttl.queue&quot;</span>)</span><br><span class="line">        .ttl(<span class="number">10000</span>)  <span class="comment">// 指定队列中消息的过期时间为10s</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;ttl.queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在发送消息时，<u>指定此消息的有效期</u>，那么不同的消息就具有不同的有效期。</p>
<p><u>当消息过期后并不会立马被删除</u>，而是当消息要投递给消费者的时候才会去删除，因为每条消息的过期时间都不一样，想要知道哪条消息过期，必须要遍历队列中的所有消息才能实现，当消息比较多时这样就比较耗费性能，因此针对这种情况，消息要投递给消费者的时候才去删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定消息的有效期</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello TTL message&quot;</span>.getBytes())</span><br><span class="line">    .setExpiration(<span class="string">&quot;10000&quot;</span>)  <span class="comment">// 设置消息的过期时间为10s</span></span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果两种方式 TTL 同时指定，会以时间短的为准。</p>
<h2 id="2-2-死信交换机"><a href="#2-2-死信交换机" class="headerlink" title="2.2 死信交换机"></a>2.2 死信交换机</h2><p>当一个消息过期后，它实际上会成为一个死信(dead-lettered)，不仅如此，以下几种情况均会使得消息成为死信：</p>
<ul>
<li><p>消费者拒收消息（basic.reject&#x2F;basic.nack）并且没有重新入队 requeue&#x3D;false。</p>
</li>
<li><p>消息 TTL 过期</p>
</li>
<li><p>队列达到最大长度，已经堆积满了，最早的消息被丢弃</p>
</li>
</ul>
<p>当一个消息成为死信时：</p>
<ol>
<li><p>如果当前队列配置了<code>dead-letter-exchange</code> 属性，指定了一个死信交换机（Dead-Letter-Exchange，DLX），那么它就会被投递到这个交换机中，之后发送到绑定死信交换机的死信队列中。</p>
<p>可以利用死信交换机收集所有消费者处理失败的消息（死信），交由人工处理，进一步提高消息队列的可靠性（注意和消费者消息重试的 RepublishMessageRecoverer 区分）。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220210.png" alt="image-20220319171652756" style="zoom:80%;" />
</li>
<li><p>如果当前队列没有指定交换机，这个消息就会被丢弃。</p>
</li>
</ol>
<p>实际上，DLX 本身就是一个普通交换机，我们可以为任意队列指定 DLX，当该队列中存在死信时，RabbitMQ 就会自动的将这个死信投递到 DLX 上去，进而被路由到死信队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置死信交换机和死信队列</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 正常交换机、队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机、队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dl_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信的交换机、队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;dlExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">dlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(DL_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;dlQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">dlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DL_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明正常的交换机、队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;normalExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">normalExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(NORMAL_EXCHANGE).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;normalQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 正常队列绑定死信交换机</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DL_EXCHANGE); <span class="comment">// x-dead-letter-exchange：死信交换机的名称</span></span><br><span class="line">        params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;dl.message&quot;</span>); <span class="comment">// x-dead-letter-routing-key：死信交换机的路由键,注意这个key要能够使得死信交换机和死信队列之间绑定的key生效</span></span><br><span class="line">        params.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>); <span class="comment">// 设置过期时间</span></span><br><span class="line">        params.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">10</span>); <span class="comment">// 设置队列的最大长度</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(NORMAL_QUEUE).withArguments(params).build();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         // 下面方式也可以</span></span><br><span class="line"><span class="comment">         return QueueBuilder.durable(NORMAL_QUEUE) // 指定队列名称，并持久化</span></span><br><span class="line"><span class="comment">        	.ttl(10000) // 设置队列的超时时间，10秒</span></span><br><span class="line"><span class="comment">        	.deadLetterExchange(DL_EXCHANGE) // 指定死信交换机</span></span><br><span class="line"><span class="comment">        	.build();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常队列和正常交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;normalQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;normalExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;normal.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列和死信交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">dlQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;dlQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;dlExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dl.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-延迟队列"><a href="#3-延迟队列" class="headerlink" title="3. 延迟队列"></a>3. 延迟队列</h1><blockquote>
<p>延迟队列是⼀种带有延迟功能的消息队列， 生产者将消息发送到消息队列服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某⼀个时间投递到消费者进行消费，该消息即定时消息。</p>
</blockquote>
<p>我们经常在业务中需要用到延迟功能，比如：</p>
<ul>
<li>比如在电商交易中，当用户下单后，需要在 30 分钟之内付款，否则订单将被自动取消。</li>
<li>在会议预定成功后，会在会议开始前几分钟通知所有预定该会议的用户。</li>
<li>用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。</li>
<li>…</li>
</ul>
<p>RabbitMQ默认没有延迟队列，但可以通过以下两种方式实现延迟队列：</p>
<ul>
<li>死信队列 + TTL</li>
<li>官方插件 <strong><a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">rabbitmq-delayed-message-exchange</a></strong></li>
</ul>
<h2 id="3-1-死信队列-TTL"><a href="#3-1-死信队列-TTL" class="headerlink" title="3.1 死信队列 + TTL"></a>3.1 死信队列 + TTL</h2><p>我们在前面已经介绍过死信队列和 TTL 的概念与用法，通过这两个东西我们可以巧妙的实现延迟队列功能。基本思想是：</p>
<ul>
<li>给一个设置有 TTL 的队列 Q1 指定一个死信交换机 DLX。</li>
<li>让一个死信队列 Q2 绑定此死信交换机 DLX。</li>
<li>对于Q1，我们不添加任何消费者对其进行消费，那么一旦生产者发送消息投递到 Q1 中后，由于没有消费者进行消费，那么消息一定会超时，从而会被投递到 DLX，从而被投递到 Q2中，我们设置消费者用于对 Q2 进行消费，此时就实现了生产者与消费者之间消息的延迟接收。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220203.png" alt="image-20220319175550818" style="zoom:80%;" />

<h2 id="3-2-官方插件"><a href="#3-2-官方插件" class="headerlink" title="3.2  官方插件"></a>3.2  官方插件</h2><p>因为延迟队列的需求非常多，所以 RabbitMQ 的官方也推出了一个 DelayExchange 插件，用于支持延迟队列效果。通过安装插件，自定义交换机，让交换机拥有延迟发送消息的能力，从而实现延迟消息。</p>
<p>与死信队列 + TTL 实现延迟队列的方式相比：</p>
<ul>
<li>延迟插件方式只需创建一个交换机和一个队列，而死信队列方式需要创建两个交换机（死信队列交换机+处理队列交换机）、两个队列（死信队列+处理队列）。</li>
<li>死信队列的方式不需要格外安装任何内容，而延迟插件需要额外下载插件并安装。</li>
<li>延迟交换机主要是变更了消息存储的维度到交换机，但是假如消息正在交换机中存储，但是还未路由到队里中，一旦服务宕机，延迟交换机中存储的消息直接就丢失了。只适用于对于数据少量丢失容忍性比较强的业务场景。</li>
</ul>
<p>延迟插件开源地址为：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delaed-message-exchange">https://github.com/rabbitmq/rabbitmq-delaed-message-exchange</a></p>
<p>选择合适的版本，我的 RabbitMQ 版本为3.8.15，那么插件可以选择<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/tag/3.8.9">3.8.9版本</a>，然后下载 .ez文件</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220200.png" alt="image-20220319214015332" style="zoom:80%;" />

<p>将.ez文件传到服务器，并复制到 docker 容器内部</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">cp</span> rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez rabbitmq_study:/plugins</span><br><span class="line"><span class="comment"># 这里的rabbitmq_study是我的rabbitmq容器的名称（按自己的名称来），也可以用容器id代替</span></span><br></pre></td></tr></table></figure>

<p>进入 rabbitmq 容器内部，并启动插件功能</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it rabbitmq_study /bin/bash</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>

<p>此时我们在 RabbitMQ 的管理页面创建交换机时，就会发现多了一个 <code>x-delayed-message</code> 类型。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220153.png" alt="image-20220319214751218" style="zoom:80%;" />

<p>从名称上就可以看出 <code>rabbitmq-delaed-message-exchange</code>实际上是针对交换机做的延迟，而不是队列，其原理。当我们发送消息到类型为 <code>x-delayed-message</code> 的交换机时，此交换机会有以下处理步骤：</p>
<ol>
<li>接收消息</li>
<li>判断消息 header 中是否具备 x-delay 属性，如果有 x-delay 属性，说明是延迟消息，则将持久化到硬盘，并读取 x-delay 值，作为延迟时间。如果没有就按正常消息处理。</li>
<li>当 x-delay 时间到期后，再将消息投递到指定队列，实现消息的延迟发送。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建延迟交换机</span></span><br><span class="line"><span class="comment">// 方式1：注解的方式，将delayed属性设置为true即可</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayExchange</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到了delay.queue的延迟消息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：Bean的方式设置 delayed属性为true即可</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(RDELAYED_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">     directExchange.setDelayed(<span class="literal">true</span>);</span><br><span class="line">     <span class="keyword">return</span> directExchange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者发送消息，注意需要在请求头中设置消息的延迟时间</span></span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody((<span class="string">&quot;hello Delay Exchange&quot;</span>).getBytes(<span class="string">&quot;UTF-8&quot;</span>)).setHeader(<span class="string">&quot;x-delay&quot;</span>, <span class="number">10000</span>).build();</span><br></pre></td></tr></table></figure>

<h1 id="4-消息堆积"><a href="#4-消息堆积" class="headerlink" title="4. 消息堆积"></a>4. 消息堆积</h1><blockquote>
<p><strong>消息堆积</strong>是指当生产者发送消息的速度大于消费者处理消息的速度，不可避免的会导致队列中消息越来越多，不断堆积，直到队列存储到达上限。</p>
</blockquote>
<p>针对于消息堆积，一般的解决方案为：</p>
<ol>
<li>排查消费者内部逻辑，分析出性能瓶颈（比如消费者可能出现异常宕机了），并且可以采取<u>多线程</u>形式提升消息处理速度。</li>
<li>增加<u>多个消费者</u>，从而增加处理速度。</li>
<li>扩大队列的容量，提升存储上限。</li>
<li>惰性队列。</li>
</ol>
<p>惰性队列与普通队列的区别：</p>
<ul>
<li><strong>普通队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。</strong>即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。</li>
<li><strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中</strong>。它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。<ul>
<li>lazy queue 消息不持久化 ， 但是这种模式还是会把消息放到硬盘里，RAM的使用率会一直很稳定，但是重启后一样会丢失消息。</li>
<li>lazy queue 消息持久化，这种方式无疑是最佳搭配，消息放到硬盘并且不会因为服务器重启而丢失，面对高并发也是从容不已。</li>
</ul>
</li>
<li>惰性队列减少了内存的消耗，但会增加 I&#x2F;O 的使用，相当于以<strong>空间换时间</strong>，当然惰性队列的发送速度不一定比普通队列慢，尤其在高并发场景下可能比普通队列还快，原因是普通队列会由于内存不足而不得不将消息换页至磁盘。</li>
</ul>
<p>在队列声明的时候可以通过<code>x-queue-mode</code>参数来设置队列的模式，取值为『default』和『lazy』，其中 lazy 就是定义惰性队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Springboot 声明队列为LazyQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">        .lazy()  <span class="comment">// 惰性队列</span></span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;lazy.queue&quot;, durable = &quot;true&quot;,arguments = @Argument(name = &quot;x-queue-mode&quot;,value = &quot;lazy&quot;)),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;lazy.direct&quot;),</span></span><br><span class="line"><span class="meta">    key = &quot;lazy&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者接收到了lazy.queue的延迟消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-消费端限流"><a href="#5-消费端限流" class="headerlink" title="5. 消费端限流"></a>5. 消费端限流</h1><blockquote>
<p>在业务高峰时期，可能会出现生产者发送消息的速度远超消费者处理消息的速度的情况，比如双十一时，大量的订单涌入，此时消息队列就会囤积大量的消息，而<u>如果此时消费者一次取出大量的消息， 但是又无法同时处理这么多消息， 就可能导致服务崩溃， 所以需要对消费端进行限流。</u></p>
</blockquote>
<p>RabbitMQ 提供了一种 <strong>qos</strong> （服务质量保证）功能，<strong>在手动确认消息的前提下</strong>，如果指定 Qos 数目的消息没有被确认前，不会消费新的消息。</p>
<p>可以在 springboot 配置类中配置 <code>prefetch=n</code>，此值表示消费端每次从 MQ 拉 n 条消息消费，直到手动确认消费完毕后，才会继续拉去下一条消息。比如将 perfetch 设置为1000，那么一次拉 1000 条消息，等待手动确认后，再拉取 1000 条消息，就可以实现消息的削峰限流。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span>  <span class="comment"># 手动确认消息</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1000</span>	<span class="comment"># 一次最多取消息的个数</span></span><br></pre></td></tr></table></figure>

<h1 id="6-幂等性（消息重复消费）"><a href="#6-幂等性（消息重复消费）" class="headerlink" title="6. 幂等性（消息重复消费）"></a>6. 幂等性（消息重复消费）</h1><blockquote>
<p> 消息的幂等性是指对于同一个系统，在同样条件下，<strong>一次请求和重复多次请求对资源的影响是一致的</strong>，不会因为多次点击而产生了副作用。</p>
</blockquote>
<p>生活中常见要求幂等性的场景如：</p>
<ol>
<li>用户支付时，一笔订单应当只能扣一次钱，无论是网络问题或者其他问题而重新付款，都只应该扣一次钱；</li>
<li>用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；</li>
<li>用户对一篇文章进行点赞，无论点了多少次，最终实际上也能将点赞数+1；</li>
<li>前端重复提交选中的数据，后台也只会产生对应这个数据的一个反应结果。</li>
</ol>
<p>增删改查的幂等性：</p>
<ul>
<li><code>Get </code> 用于获取资源，不会对系统资源进行改变，因此是幂等的。</li>
<li><code>Delete</code> 用于删除资源，虽然改变了系统资源，但是第一次和第N次删除操作对系统的作用是相同的，所以是幂等的。比如要删除一个 id 为 1 的资源，可能第一次调用时会删除，而后面所有调用的时候由于系统中已经没有这个 id 的资源了，就无法进行删除了。但是第一次操作和后面的操作对系统的作用是相同的，所以这也是幂等的，调用者可以多次调用这个接口不必担心错误。</li>
<li><code>Post </code> 用于新增资源，这意味着每次调用都会在系统中产生新的资源，所以该操作注定不是幂等操作。</li>
<li><code>Put </code> 用于修改资源，如果是设置具体值，则是幂等的，比如设置用户张三的分数为98，那么无论修改一次还是多次，最终结果都一样。但如果是增量修改，则可能不是幂等的，比如将用户张三的分数减10，那么多次修改和一次修改的效果是完全不同的。</li>
</ul>
<p>RabbitMQ 的幂等性问题</p>
<ul>
<li><p><strong>消息重复投递</strong>。生产者发送消息到 broker后，broker在confirm 确认的时候出现网络故障，使得生产者没收到该消息ACk 而重新发送消息到 broker 中。</p>
</li>
<li><p><strong>消息重复消费</strong>。<u>消费者处理完一条消息后，在向 MQ 发送 ack 确认时出现了网络故障，使得 MQ 没有收到此 ack 确认， 那么 MQ 并不会将该条消息删除，而是重新发送给其他的消费者或者当重新建立起连接后，再次发送给该消费者，这就造成了消息的重复消费。</u></p>
</li>
<li><p>解决了消息重复消费的问题其实就解决了消息重复投递的问题。</p>
</li>
</ul>
<p>解决方案：</p>
<ul>
<li><p>&#x3D;&#x3D;全局唯一ID + 唯一索引&#x3D;&#x3D;</p>
<p>通过时间戳或者UUID或按自己的规则生成一个全局唯一id，每次消费消息时用该id先判断该消息是否已消费过。比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。不过在高并发时，如果是单个数据库就会有写入性能瓶颈（可采用分库分表提升性能）。</p>
</li>
<li><p>&#x3D;&#x3D;Redis原子性&#x3D;&#x3D;</p>
<p>利用 redis 执行 setnx 命令，天然具有幂等性。从而实现不重复消费，如果 ack 失败，在 RabbitMQ 将消息交给其他的消费者时，先执行 setnx，如果 key 已经存在（说明之前有人消费过该消息），获取他的值，如果是 0，当前消费者就什么都不做，如果是 1，直接 ack。</p>
</li>
</ul>
<h1 id="7-集群（高可用）"><a href="#7-集群（高可用）" class="headerlink" title="7. 集群（高可用）"></a>7. 集群（高可用）</h1><blockquote>
<p>使用了 MQ 后，整个系统会依赖于MQ的可靠性、安全性、吞吐能力，比如若MQ宕机，整个系统都会崩溃。因而会降低系统的可用性，那么如何改善这一缺点呢？答案是搭建集群环境。</p>
</blockquote>
<p>RabbitMQ的集群有两种模式：</p>
<ul>
<li><strong>普通集群【无高可用】</strong>：是一种分布式集群，将队列分散到集群的各个节点，从而提高整个集群的并发能力。</li>
<li><strong>镜像集群【高可用】</strong>：是一种主从集群，普通集群的基础上，添加了主从备份功能，提高集群的数据可用性。</li>
</ul>
<h2 id="7-1-普通集群"><a href="#7-1-普通集群" class="headerlink" title="7.1 普通集群"></a>7.1 普通集群</h2><p>普通集群模式是使用多台服务器，在每台服务器中启动一个 RabbitMQ 实例，我们创建的每一个队列 Queue，它的元数据（主要就是 Queue 的一些配置信息）会在所有的 RabbitMQ 实例中进行同步，但是<strong>队列中的消息只会存在于一个 RabbitMQ 实例上</strong>，而不会同步。</p>
<p>当消费者拉取消息时，如果连接到了另外一个实例，那么此实例实际会通过元数据定位到 队列所在的位置，之后访问队列所在的实例，并拉取数据发送给消费者。</p>
<p>可见，这种集群<strong>可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用</strong>，因为一旦一个 RabbitMQ 实例挂了，其中的消息就访问不到了，其他实例中并不会保存挂掉的实例中的消息。</p>
<ul>
<li>如果 MQ 做了持久化，那么实例恢复后，才可以继续访问；</li>
<li>如果 MQ 没做持久化，那么消息就丢了。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220145.png" alt="image-20220320204329857" style="zoom:80%;" />

<h2 id="7-2-镜像集群"><a href="#7-2-镜像集群" class="headerlink" title="7.2 镜像集群"></a>7.2 镜像集群</h2><p>由于普通集群并没有实现 RabbitMQ 的高可用，实际生产条件下一般不会使用，而是会使用镜像集群。</p>
<p>相较于普通集群，<strong>镜像集群会将队列的所有数据（包括实际消息）同时存储在多台机器上，而不是仅仅存储队列的元数据。</strong>每个 RabbitMQ 实例都有一份镜像数据（副本数据）。在每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。</p>
<p>本质上是主从结构，创建队列的节点被称为该队列的<strong>主节点，</strong>备份到的其它节点叫做该队列的<strong>镜像</strong>节点。一旦某个 RabbitMQ 示例挂机了，那么其镜像节点就会成为新的主节点。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/pictures1/20220320220139.png" alt="image-20220320205249660" style="zoom:80%;" />

<p>镜像集群模式并不需要额外搭建，只需要我们在普通集群的基础上将队列配置为镜像队列即可。</p>

    </div>

    
    
    
	<div>
	    
	    <div style="text-align:center;color:#ccc;font-size:20px;margin-top:30px">
		-------本 文 结 束 <i class="fa fa-paw"></i> 感 谢 您 的 阅 读-------
	    </div>
	    
	</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>SniperCoding
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://snipercoding.github.io/2022/03/10/RabbitMQ%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/" title="RabbitMQ进阶知识">https://snipercoding.github.io/2022/03/10/RabbitMQ进阶知识/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/10/RabbitMQ%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="prev" title="RabbitMQ基础知识">
      <i class="fa fa-chevron-left"></i> RabbitMQ基础知识
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-text">1. 消息可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="nav-text">1.1 生产者丢失消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-RabbitMQ-%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="nav-text">1.2 RabbitMQ 丢失消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF"><span class="nav-text">1.3 消费者丢失消息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%B6%88%E6%81%AF%E6%9C%89%E6%95%88%E6%9C%9F"><span class="nav-text">2. 消息有效期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-TTL"><span class="nav-text">2.1 TTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-text">2.2 死信交换机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="nav-text">3. 延迟队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97-TTL"><span class="nav-text">3.1 死信队列 + TTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%AE%98%E6%96%B9%E6%8F%92%E4%BB%B6"><span class="nav-text">3.2  官方插件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF"><span class="nav-text">4. 消息堆积</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81"><span class="nav-text">5. 消费端限流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%88%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%89"><span class="nav-text">6. 幂等性（消息重复消费）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E9%9B%86%E7%BE%A4%EF%BC%88%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%89"><span class="nav-text">7. 集群（高可用）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4"><span class="nav-text">7.1 普通集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4"><span class="nav-text">7.2 镜像集群</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SniperCoding"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SniperCoding</p>
  <div class="site-description" itemprop="description">请不要假装很努力，因为结果不会陪你演戏！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SniperCoding" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SniperCoding" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SniperCoding</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">135k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:03</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'uEQlOTKrhpXHePOJS3OgRs6i-gzGzoHsz',
      appKey     : 'eO4nhfbFpC6pbqpfrYlQ3zcl',
      placeholder: "撰写你的评论叭~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
    // �����������ݣ�ɾ��Powered By Valine
    var infoEle = document.querySelector('.vpower');
    if (infoEle){
        infoEle.parentNode.removeChild(infoEle);
    }
  });
});
</script>
</body>
</html>
