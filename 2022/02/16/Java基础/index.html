<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/tiger_32_32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/tiger_16_16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"snipercoding.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一. Java 开发环境 JVM（Java Virtual Machine）java 虚拟机 主要负责将Java程序经过编译之后生成的和平台无关的字节码文件解释成具体的平台能够识别的机器指令。  JRE（Java Runtime Environment）Java 运行环境 JRE &#x3D; JVM +  Java程序执行所需要的核心类库。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识">
<meta property="og:url" content="https://snipercoding.github.io/2022/02/16/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="SniperCoding的个人博客">
<meta property="og:description" content="一. Java 开发环境 JVM（Java Virtual Machine）java 虚拟机 主要负责将Java程序经过编译之后生成的和平台无关的字节码文件解释成具体的平台能够识别的机器指令。  JRE（Java Runtime Environment）Java 运行环境 JRE &#x3D; JVM +  Java程序执行所需要的核心类库。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162329.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162400.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162516.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162550.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162603.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162634.PNG">
<meta property="article:published_time" content="2022-02-16T07:52:32.000Z">
<meta property="article:modified_time" content="2022-02-16T07:52:32.000Z">
<meta property="article:author" content="SniperCoding">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162329.png">

<link rel="canonical" href="https://snipercoding.github.io/2022/02/16/Java%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础知识 | SniperCoding的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>
 
   <script async type="text/javascript" src="/js/fireworks.js"></script>    

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SniperCoding的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长点滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://snipercoding.github.io/2022/02/16/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SniperCoding">
      <meta itemprop="description" content="请不要假装很努力，因为结果不会陪你演戏！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SniperCoding的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-16 15:52:32" itemprop="dateCreated datePublished" datetime="2022-02-16T15:52:32+08:00">2022-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">评论数：</span>
    
    <a title="valine" href="/2022/02/16/Java%E5%9F%BA%E7%A1%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/16/Java%E5%9F%BA%E7%A1%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="一-Java-开发环境"><a href="#一-Java-开发环境" class="headerlink" title="一. Java 开发环境"></a>一. Java 开发环境</h1><ol>
<li><p><code>JVM</code>（Java Virtual Machine）java 虚拟机</p>
<p>主要负责将Java程序经过编译之后生成的和平台无关的字节码文件解释成具体的平台能够识别的机器指令。</p>
</li>
<li><p><code>JRE</code>（Java Runtime Environment）Java 运行环境</p>
<p>JRE &#x3D; JVM +  Java程序执行所需要的核心类库。</p>
<span id="more"></span>
</li>
<li><p><code>JDK</code>（Java Development Kit）Java 开发工具包<br>JDK &#x3D; JRE + 开发工具（java、javac…）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162329.png" style="zoom: 50%;" /></li>
</ol>
<blockquote>
<p>JVM 是整个 java 实现跨平台的最核心的部分，但是只有 JVM 并不能运行程序；</p>
<p>如果想要运行一个 Java 程序，可以只安装 JRE，不安装 JDK；</p>
<p>如果想要开发一个 Java 程序 ，必须安装 JDK；</p>
</blockquote>
<h1 id="二-Java-语法规范"><a href="#二-Java-语法规范" class="headerlink" title="二. Java 语法规范"></a>二. Java 语法规范</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<h2 id="2-Java-关键字"><a href="#2-Java-关键字" class="headerlink" title="2. Java 关键字"></a>2. Java 关键字</h2><blockquote>
<p>关键字 ：是指在程序中，Java 已经定义好的单词，具有特殊含义。如 public、class、int 等等（关键字中所有字母都为小写）。</p>
</blockquote>
<h2 id="3-Java-标识符"><a href="#3-Java-标识符" class="headerlink" title="3. Java 标识符"></a>3. Java 标识符</h2><blockquote>
<p>标识符：程序中的我们给类、变量以及方法所起的名字。</p>
</blockquote>
<p>Java中的类、变量、方法的名称不是随便都可以起的，需要满足一些<strong>规则</strong>：</p>
<p>​    ① 标识符可以包含名称只能由字母、数字、下划线、$ 符号 。</p>
<p>​    ② 所有的标识符都应该名称只能由字母、下划线、$ 符号开头，不能以数字开头。</p>
<p>​    ③ 标识符不能是关键字。</p>
<p>为了使得程序的可读性更好，一般编写Java程序时，也要满足一定的<strong>规范</strong>：</p>
<p>​    ① <u>类名</u>建议采用大驼峰式（首字母大写，后面每个单词首字母大写）。</p>
<p>​    ② <u>方法名和变量名</u>建议采用小驼峰式（首字母小写，后面每个单词首字母大写）。</p>
<p>​    ③ <u>常量名</u>建议全部大写，单词之间用下划线分割。</p>
<p>​    ④ <u>包名、模块名、项目名</u>建议所有字母都小写。</p>
<h2 id="4-Java-编程的注意事项"><a href="#4-Java-编程的注意事项" class="headerlink" title="4. Java 编程的注意事项"></a>4. Java 编程的注意事项</h2><ul>
<li>Java 是大小写敏感的。</li>
<li><strong>源文件名必须和类名相同</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li>所有的 Java 程序由 public static void main(String[] args) 方法开始执行。</li>
</ul>
<h1 id="三-Java-基础语法"><a href="#三-Java-基础语法" class="headerlink" title="三. Java 基础语法"></a>三. Java 基础语法</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><blockquote>
<p>单行注释: 以 &#x2F;&#x2F; 开头 换行结束<br>多行注释: 以 &#x2F;* 表示注释开始 ， 以*&#x2F;表示注释结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"><span class="comment">/* 这是</span></span><br><span class="line"><span class="comment">   一个</span></span><br><span class="line"><span class="comment">   多行</span></span><br><span class="line"><span class="comment">   注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>Java 数据类型分为两大类。</p>
<p><u>① 基本类型（4 类 8 种）</u></p>
<ul>
<li>整数型（byte、short、int、long）</li>
<li>浮点型（float double）</li>
<li>字符型（char）</li>
<li>布尔型（boolean）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">关键字</th>
<th align="center">内存占用&#x2F;字节</th>
<th align="center">取值范围</th>
<th align="center">最小值符号</th>
<th align="center">最大值符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节型</td>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128 ~ +127</td>
<td align="center">Byte.MIN_VALUE</td>
<td align="center">Byte.MAX_VALUE</td>
</tr>
<tr>
<td align="center">短整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-32768 ~ +32767</td>
<td align="center">Short.MIN_VALUE</td>
<td align="center">Short.MAX_VALUE</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2^31 ~ 2^31-1（超过20亿）</td>
<td align="center">Integer.MIN_VALUE</td>
<td align="center">Integer.MAX_VALUE</td>
</tr>
<tr>
<td align="center">长整型</td>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-2^63 ~ 2^63-1</td>
<td align="center">Long.MIN_VALUE</td>
<td align="center">Long.MAX_VALUE</td>
</tr>
<tr>
<td align="center">单精度浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">1.4E-45 ~ 3.4028235E38（有效位数6~7位）</td>
<td align="center">Float.MIN_VALUE</td>
<td align="center">Float.MAX_VALUE</td>
</tr>
<tr>
<td align="center">双精度浮点型</td>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">4.9E-324~1.7977E+308（有效位数15位）</td>
<td align="center">Double.MIN_VALUE</td>
<td align="center">Double.MAX_VALUE</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">0 ~ 65535</td>
<td align="center">Character.MIN_VALUE</td>
<td align="center">Character.MAX_VALUE</td>
</tr>
<tr>
<td align="center">布尔型</td>
<td align="center">Boolean</td>
<td align="center">1</td>
<td align="center">true、false</td>
<td align="center">*</td>
<td align="center">*</td>
</tr>
</tbody></table>
<p><strong>Java 没有任何无符号 (unsigned) 形式的 int、long、short 或 byte 类型，但可以通过其包装类转换得到。</strong></p>
<p>基本数据类型必须进行初始化，没有默认值。</p>
<p>基本类型之间可以进行转换，分为自动类型转换和强制类型转换。</p>
<ul>
<li><p><code>自动类型转换</code>（将容量小的数据类型转换为容量大的数据类型）</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162400.png" style="zoom: 75%;" />

<p>注意：</p>
<ul>
<li><input disabled="" type="checkbox"> 不能对 boolean 类型进行类型转换。</li>
<li><input disabled="" type="checkbox"> <strong>byte,short,char 之间不会相互转换，他们三者在计算时首先转换为int类型。</strong></li>
<li><input disabled="" type="checkbox"> 当把任何基本数据类型的值和字符串 (String) 进行连接运算时 (+)，基本数据类型的值将自动转化为字符串(String) 类型。</li>
</ul>
</li>
<li><p><code>强制类型转换</code>（将容量大的数据类型转换为容量小的数据类型）</p>
<p>格式：级别低的数据类型  变量名 &#x3D; (级别低的数据类型) 级别高的数据类型;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">10.5</span>；<span class="comment">// 结果为 10，直接砍掉小数部分。</span></span><br></pre></td></tr></table></figure>

<p>注意：强制类型转换可能造成精度降低或溢出</p>
</li>
</ul>
<p><u>② 引用类型</u></p>
<ul>
<li>类（class）</li>
<li>接口（interface）</li>
<li>数组（array）</li>
</ul>
<h2 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h2><blockquote>
<p>常量是在程序运行时不能被修改的量。通常使用大写字母表示常量。</p>
<p>在 Java 中，利用关键字 final 指示常量，比如 final int a &#x3D; 10;</p>
</blockquote>
<ul>
<li><p>整数常量</p>
<p>十进制： 正常的写法，如 5，-125 等。</p>
<p>二进制： 在数字前面加前缀 0B 或 0b，如 0B11，0B110等。</p>
<p>八进制： 在数字前面加前缀 0，如 05，01等。</p>
<p>十六进制： 在数字前面加前缀 0x 或 0X，如 0XA，0x3等。</p>
</li>
<li><p>浮点数常量：如 0.1，10.8等等。</p>
</li>
<li><p>字符常量： 如 ‘A’，’C’ 等。</p>
</li>
<li><p>字符串常量： 如 “zhang”,”A” 等。</p>
</li>
<li><p>布尔常量： 只有 true 和 false。</p>
</li>
<li><p>空常量： null。</p>
</li>
</ul>
<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h2><blockquote>
<p>变量是在程序运行时能被修改的量。通常变量名采用小驼峰式（首字母小写，后面每个单词首字母大写）。</p>
</blockquote>
<p>变量的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则：数据类型 变量名;</span></span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure>

<p>变量的初始化一般有两种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  第一种变量赋值方法，在声明的时候直接赋值。</span></span><br><span class="line"><span class="comment">	规则：数据类型 变量名 = 要赋的值;	*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>；</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*  第二种变量赋值方法，先声明，后赋值。</span></span><br><span class="line"><span class="comment">	规则：数据类型 变量名;</span></span><br><span class="line"><span class="comment">		 变量名 = 要赋的值;	*/</span></span><br><span class="line"><span class="type">int</span> a;  </span><br><span class="line">a = <span class="number">10</span>;    </span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 整数默认为 int 类型，如果需要的数据类型是 long，那么需要在数据后加后缀 L 或 l，如 long a &#x3D; 10L;</li>
<li><input checked="" disabled="" type="checkbox"> 浮点数默认为 double 类型，如果需要的数据类型是 float，那么需要在数据后加后缀 F 或 f，如 float a &#x3D; 0.5F;</li>
<li><input checked="" disabled="" type="checkbox"> 变量未赋值时不可使用；</li>
<li><input checked="" disabled="" type="checkbox"> 不可重复定义变量。</li>
<li><input checked="" disabled="" type="checkbox"> 从Java 10 开始，对于<u>局部变量</u>，如果可以从变量的初始值推断出它的类型，就不再需要声明类型。只需要使用关键字 var 而无需指定类型，比如：var vacationDays &#x3D;12; 整型</li>
</ul>
<h2 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5. 运算符"></a>5. 运算符</h2><p><strong>① 运算符的分类</strong></p>
<ul>
<li><p>算数运算符（+、-、*、&#x2F;、%、++、–）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：整数除法的结果仍然会是整数，规则是直接砍掉小数取整，而不是四舍五入。*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符（&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注意：关系运算符用于比较两个数据的大小，结果会产生一个布尔（boolean）值。如果关系为真，则结果为 true，如果关系为假，则结果为false。*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符（&amp;&amp;、||、!）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意：逻辑运算符的运算结果只能是一个布尔值（true/false）; &amp;&amp; 和 || 具有短路现象，</span></span><br><span class="line"><span class="comment">当&amp;&amp;时，如果第一个表达式已经为false，不管第二个表达式为true/false，结果一定为false ，此时第二个表达式将不会再执行。</span></span><br><span class="line"><span class="comment">当||时，如果第一个表达式已经为true，不管第二个表达式为true/false，结果一定为true，此时第二个表达式将不会再执行。*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (<span class="number">3</span>&gt;<span class="number">5</span>) &amp;&amp; (++a == <span class="number">6</span> )</span><br><span class="line">    System.out.println(a);<span class="comment">//由于短路现象，++a表达式并没有被执行，因此输出结果为5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符（也称三目运算符）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  条件运算符语法规则： 数据类型 变量名 = 布尔表达式？结果1:结果2;</span></span><br><span class="line"><span class="comment"> 	条件运算符含义：如果布尔表达式为true，则执行变量名=结果1，否则执行变量名=结果2。  */</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">2</span>,b=<span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> a &lt; b ? a : b;<span class="comment">//因为a&lt;b为真，故将执行结果1，即num=a，则可得结果为num=2</span></span><br><span class="line"><span class="comment">/*条件运算符相比于if else语句更加简洁，且执行效率更高，但运算完必须要有一个结果。而if else运算完不需要一个结果。比如三元运算符内不能单独列出输出表达式。凡是可以使用三元运算符的地方，都可以改写为if-else；反之，不成立。*/</span></span><br><span class="line"><span class="keyword">if</span> (num  &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num是正数&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num是负数&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//不能使用条件运算符代替</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值运算符（&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a + = b; 等价于  a = a + b ;  */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算符（&amp;、|、~、^、&lt;&lt;、&gt;&gt;）</p>
</li>
</ul>
<p><strong>② 运算符的优先级</strong>（算、关、逻、条、赋）</p>
<h2 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6. 流程控制"></a>6. 流程控制</h2><h3 id="（1）顺序结构"><a href="#（1）顺序结构" class="headerlink" title="（1）顺序结构"></a>（1）顺序结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顺序执行，即根据编写的顺序，从上到下运行，没有跳转。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）选择结构"><a href="#（2）选择结构" class="headerlink" title="（2）选择结构"></a>（2）选择结构</h3><ul>
<li><p>if 选择结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：if，如果布尔表达式为真，则执行语句体，否则不执行。</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 第二种：if-else，如果布尔表达式为真，则执行语句体1，否则执行语句体2.</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 第三种：if—else if—...-else</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 选择结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> 常量n:</span><br><span class="line">		语句体n;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>case 标签可以为：</p>
<ul>
<li>类型为 char、byte、short、或 int 的常量表达式</li>
<li>枚举常量</li>
<li>从Java 7开始，还可以是字符串字面量。</li>
</ul>
</li>
</ul>
<h3 id="（3）循环结构"><a href="#（3）循环结构" class="headerlink" title="（3）循环结构"></a>（3）循环结构</h3><ul>
<li><p><code>for </code>循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">for(初始化表达式①;布尔表达式②;递进表达式③)&#123;</span></span><br><span class="line"><span class="comment">	循环体④;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	执行顺序：①②④③-②④③-②④③-...</span></span><br><span class="line"><span class="comment">	当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span>+sum);<span class="comment">// 1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while </code>循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while(布尔表达式)&#123;</span></span><br><span class="line"><span class="comment">	循环体;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span> + sum);<span class="comment">// 1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do while</code> 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do&#123;</span></span><br><span class="line"><span class="comment">	循环体;</span></span><br><span class="line"><span class="comment">&#125;while(布尔表达式);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	do while中的循环体至少执行一次；</span></span><br><span class="line"><span class="comment">	当布尔表达式为假时，循环结束，执行后续语句。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：计算1+2+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;=<span class="number">100</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;1+2+..+100的结果为：&quot;</span> + sum);<span class="comment">//1+2+..+100的结果为为：5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>break </code> 和 <code>continue</code></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> break 和 continue 均为循环控制语句；</li>
<li><input checked="" disabled="" type="checkbox"> break 用于终止当前整个循环；</li>
<li><input checked="" disabled="" type="checkbox"> continue 用于跳出本次循环，转而去判断是否需要执行下次循环。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：计算2+4+..+100的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>( i % <span class="number">2</span>!=<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2+4+..+100的结果为：&quot;</span> + sum);<span class="comment">//2+4+..+100的结果为：2550</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-数组"><a href="#7-数组" class="headerlink" title="7. 数组"></a>7. 数组</h2><blockquote>
<p>数组是一组有序的具有相同数据类型的元素序列。</p>
</blockquote>
<p><strong>数组的特点：</strong></p>
<ul>
<li>数组是一种引用数据类型；</li>
<li>数组当中的多个数据，类型必须统一；</li>
<li>数组的长度一旦指定，不可更改。</li>
</ul>
<p><strong>数组的初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★一维数组：</span></span><br><span class="line"><span class="comment">1.动态初始化（指定长度）：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = new 数组存储的数据类型[长度];</span></span><br><span class="line"><span class="comment">	格式说明：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型：创建的数组中要存储的数据类型，可以是基本数据类型，也可以是引用数据类型。</span></span><br><span class="line"><span class="comment">		[] : 表示定义的是数组。</span></span><br><span class="line"><span class="comment">		数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字来操作数组，数组的命名一般使用小驼峰式。</span></span><br><span class="line"><span class="comment">		new ：关键字，创建数组使用的关键字。</span></span><br><span class="line"><span class="comment">		[长度]：数组的长度，表示数组中可以存储多少个元素。</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] array = new int[10];</span></span><br><span class="line"><span class="comment">2.静态初始化（指定内容）：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,元素3...&#125;;//静态定义的标准格式</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[] 数组名 = &#123;元素1,元素2,元素3...&#125;; //静态定义的省略格式</span></span><br><span class="line"><span class="comment">	格式说明：</span></span><br><span class="line"><span class="comment">		&#123;&#125;中是数组中想要存储的元素，在定义数组的同时，对数组进行了初始化。</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] array = new int[]&#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">★二维数组：（二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组）</span></span><br><span class="line"><span class="comment">1.动态初始化</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = new 数组存储的数据类型[行数][【列数】];</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		String[][] array = new String[3][2];//二维数组中有3个一维数组，每一个一维数组中有2个元素</span></span><br><span class="line"><span class="comment">		String[][] arr = new String[3][];//只定义行数，然后可以自行定义每一行的列数，不必都是规则矩阵形式</span></span><br><span class="line"><span class="comment">		arr[0] = new String[3]; arr[1] = new String[1]; arr[2] = new String[2];</span></span><br><span class="line"><span class="comment">2.静态初始化</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = new 数据类型&#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;.....&#125;;</span></span><br><span class="line"><span class="comment">		数组存储的数据类型[][] 数组名 = &#123;&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;,&#123;元素1,元素2...&#125;.....&#125;;</span></span><br><span class="line"><span class="comment">	定义示例：</span></span><br><span class="line"><span class="comment">		int[] arr4[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="comment">		int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的使用：</strong></p>
<p>数组元素的引用方式：数组名[数组元素下标]；</p>
<ul>
<li>数组元素下标（也称为索引）从 0 开始；长度为 n 的数组合法下标取值范围: 0~n-1；</li>
<li>数组的长度：通过使用【数组名 .length】 可以获取数组的长度；</li>
<li>数组名是该数组所在内存的地址值；</li>
<li>new 出来的东西在内存的堆区；</li>
<li><strong>数组如果没有初始化，会有默认值（数字默认全为0，boolen默认为false）</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义一个数组，存放1,2,3,4,5，并将数组元素遍历打印。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组中的元素为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot; &quot;</span>+array[i]);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四-Java-面向对象"><a href="#四-Java-面向对象" class="headerlink" title="四. Java 面向对象"></a>四. Java 面向对象</h1><h2 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1. 类和对象"></a>1. 类和对象</h2><h3 id="（1）基本概念"><a href="#（1）基本概念" class="headerlink" title="（1）基本概念"></a><strong>（1）基本概念</strong></h3><ul>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。</li>
<li><strong>属性</strong> ：一个类的状态信息，对应类中的成员变量。</li>
<li><strong>行为</strong> ：一个类能够做什么，对应类中的成员方法</li>
</ul>
<h3 id="（2）类的定义"><a href="#（2）类的定义" class="headerlink" title="（2）类的定义"></a><strong>（2）类的定义</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 class 类名&#123;</span></span><br><span class="line"><span class="comment">		成员变量;//即类的属性</span></span><br><span class="line"><span class="comment">    	成员方法;//即类的行为</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	1. 定义类（考虑修饰符、类名）</span></span><br><span class="line"><span class="comment">	2. 编写类的成员变量（考虑修饰符、变量类型、变量名、初始化值）</span></span><br><span class="line"><span class="comment">	3. 编写类的成员方法（考虑修饰符、返回值类型、方法名、形参等）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建学生类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">introduce</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;我是：&quot;</span>+name+<span class="string">&quot;,年龄：&quot;</span>+age); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）对象的创建与使用"><a href="#（3）对象的创建与使用" class="headerlink" title="（3）对象的创建与使用"></a><strong>（3）对象的创建与使用</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建对象：</span></span><br><span class="line"><span class="comment">	类名 对象名 = new 类名();</span></span><br><span class="line"><span class="comment">使用对象访问类中的成员:</span></span><br><span class="line"><span class="comment">	对象名.成员变量;</span></span><br><span class="line"><span class="comment">	对象名.成员方法();</span></span><br><span class="line"><span class="comment">匿名对象：</span></span><br><span class="line"><span class="comment">	格式：</span></span><br><span class="line"><span class="comment">		new 类名();（不定义对象的句柄，而直接调用这个对象的方法）</span></span><br><span class="line"><span class="comment">	使用情况：</span></span><br><span class="line"><span class="comment">		①如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</span></span><br><span class="line"><span class="comment">		②我们经常将匿名对象作为实参传递给一个方法调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建一个学生对象，并访问类中成员。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        student.age = <span class="number">18</span>;</span><br><span class="line">        student.introduce();<span class="comment">// 我是：张三,年龄：18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）成员变量"><a href="#（4）成员变量" class="headerlink" title="（4）成员变量"></a><strong>（4）成员变量</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 数据类型 成员变量名 = 初始化值;</span></span><br><span class="line"><span class="comment">格式说明：</span></span><br><span class="line"><span class="comment">	常用的权限修饰符有：public、private、缺省、protected</span></span><br><span class="line"><span class="comment">	 其他修饰符：static、final</span></span><br><span class="line"><span class="comment">	数据类型可以是任何基本数据类型或任何引用数据类型。</span></span><br><span class="line"><span class="comment">	成员变量名的规则同一般变量名。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>★ 成员变量与局部变量的区别：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">在类中的位置</th>
<th align="center">作用范围</th>
<th align="center">初始化值</th>
<th align="center">修饰符</th>
<th align="center">内存位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center">成员变量</td>
<td align="center">类中，方法外</td>
<td align="center">类中</td>
<td align="center">有默认值</td>
<td align="center">public、private、static、final 等</td>
<td align="center">堆区</td>
</tr>
<tr>
<td align="center">局部变量</td>
<td align="center">方法中或者方法声明上 (形式参数)</td>
<td align="center">方法中</td>
<td align="center">没有默认值。必须先定义，赋值，最后使用</td>
<td align="center">不能用权限修饰符修饰，可以用 final 修饰</td>
<td align="center">栈区</td>
</tr>
</tbody></table>
<h3 id="（5）成员方法"><a href="#（5）成员方法" class="headerlink" title="（5）成员方法"></a><strong>（5）成员方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 返回值类型 方法名 ( 参数类型 形参1, 参数类型 形参2, … )&#123;</span></span><br><span class="line"><span class="comment">		方法体;</span></span><br><span class="line"><span class="comment">		return 返回值;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">格式说明：</span></span><br><span class="line"><span class="comment">	 修饰符：告诉编译器如何调用该方法。定义了该方法的访问类型。有public, 缺省,private, protected等</span></span><br><span class="line"><span class="comment">	 如果没有返回值，那么返回值类型写void，并且不需要return 返回值;</span></span><br><span class="line"><span class="comment">	  如果有返回值，返回值类型就是return 返回值;这一语句的返回值的类型，可以是任意数据类型。</span></span><br><span class="line"><span class="comment">	 方法名的命名规则同变量名;</span></span><br><span class="line"><span class="comment">	 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用逗号隔开；</span></span><br><span class="line"><span class="comment">	 return：将方法执行后的结果带给调用者，方法执行到return语句后，整体方法运行结束。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 返回值类型，必须要和return语句返回的类型相同，否则编译失败 。</span></span><br><span class="line"><span class="comment">	② 不能在return语句后面写代码， return意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</span></span><br><span class="line"><span class="comment">	③ 没有返回值时，方法体中可以不必使用return语句。如果使用，仅用来结束方法，格式为：return;</span></span><br><span class="line"><span class="comment">	④ 方法中只能调用方法或属性，不可以在方法内部定义方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><u>方法的的重载：</u></p>
<ul>
<li>概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>特点：与返回值类型无关，只看参数列表，且参数列表必须不同（个数不同 &#x2F; 数据类型不同 &#x2F; 顺序不同）。</li>
<li>调用：通过方法的参数列表，调用不同的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：创建一个sum方法，可以计算两个整数或三个整数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overloading</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//3</span></span><br><span class="line">        System.out.println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 计算两个整数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 方法重载，计算三个整数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>形参个数可变的方法：</u></p>
<ul>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的；</li>
<li>可变参数：方法参数部分指定类型的参数个数是可变多个：<u>0个</u>，1个或多个；</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载；</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后；</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：定义形参可变的方法，并与定义数组形式的新参方法做对比。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">// 定义了形参个数可变的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(String... str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            System.out.print(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义了数组形式的形参方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(String[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            System.out.print(str[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test1(<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>);<span class="comment">// 张三丰 张无忌 张翠山</span></span><br><span class="line">        test2(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张翠山&quot;</span>&#125;);<span class="comment">// 使用了匿名对象，结果为：张三丰 张无忌 张翠山</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>方法的<strong>参数传递机制</strong>：</u></p>
<ul>
<li>Java 里方法的参数传递方式只有一种：值传递。（即将实际参数值的副本传入方法内，而参数本身不受影响。）</li>
<li>如果形参是基本数据类型，则将实参基本数据类型变量的“<code>数据值</code>”传递给形参；</li>
<li>如果形参是引用数据类型，则将实参引用数据类型变量的“<code>地址值</code>”传递给形参；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;值传递前的值为：&quot;</span>+num);<span class="comment">//5</span></span><br><span class="line">        change(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;值传递后的值为：&quot;</span>+num);<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义一个方法，将传入的参数值修改为0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;改变值的方法被调用了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）static-关键字"><a href="#（6）static-关键字" class="headerlink" title="（6）static 关键字"></a>（6）static 关键字</h3><p>static 关键字可以用来修饰：属性、方法、内部类、代码块；<strong>被修饰的成员是从属于类的</strong>，而不是单单是属于某个对象的。既然属于类，就可以不靠创建对象来调用了，而直接通过类进行调用。</p>
<ul>
<li><p><u>静态变量</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">	当static修饰成员变量时，该变量称为静态变量，也称为类变量。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	static 数据类型 变量名;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。</span></span><br><span class="line"><span class="comment">	② 任何对象都可以更改静态变量的值，但也可以在不创建该类的对象的情况下，通过【类.属性】的方式对静态变量进行操作。</span></span><br><span class="line"><span class="comment">	③ 当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</span></span><br><span class="line"><span class="comment">	④ 静态变量随着类的加载而加载，它的加载要早于对象的创建。由于类只会加载一次，则静态变量在内存中也只会存在一份，而且是存在方法区的静态域中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Test.num = <span class="number">20</span>;</span><br><span class="line">        test1.num = <span class="number">30</span>;</span><br><span class="line">        test2.num = <span class="number">40</span>;</span><br><span class="line">        System.out.println(Test.num);   <span class="comment">//40</span></span><br><span class="line">        System.out.println(test1.num);  <span class="comment">//40</span></span><br><span class="line">        System.out.println(test2.num);  <span class="comment">//40</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★ 静态变量与普通成员变量的区别</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">所属</th>
<th align="center">存储区域</th>
<th align="center">生命周期</th>
<th align="center">调用方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">静态变量</td>
<td align="center">类</td>
<td align="center">方法区</td>
<td align="center">与类的生命周期相同</td>
<td align="center">类.属性 &#x2F; 对象.属性</td>
</tr>
<tr>
<td align="center">普通成员变量</td>
<td align="center">某个对象</td>
<td align="center">堆区</td>
<td align="center">与其所属对象的生命周期相同</td>
<td align="center">所属对象.属性</td>
</tr>
</tbody></table>
</li>
<li><p><u>静态方法</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：</span></span><br><span class="line"><span class="comment">	当static修饰成员方法时，该变量称为静态方法，也称为类方法。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 static 返回值类型 方法名 (参数列表)&#123;</span></span><br><span class="line"><span class="comment">		方法体;     </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 在静态的方法内，不能使用this关键字、super关键字。</span></span><br><span class="line"><span class="comment">	② 静态方法随着类的加载而加载，可以通过【类名.静态方法】进行调用，也可以通过【对象名.静态方法】调用。</span></span><br><span class="line"><span class="comment">	③ 静态方法中，只能调用静态的方法或变量。</span></span><br><span class="line"><span class="comment">	④ 非静态方法中，既可以调用非静态的方法或变量，也可以调用静态的方法或变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        Test.staticMethod(); <span class="comment">// 这是一个静态方法</span></span><br><span class="line">        test.staticMethod(); <span class="comment">// 这是一个静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2. 封装"></a>2. 封装</h2><h3 id="（1）高内聚低耦合"><a href="#（1）高内聚低耦合" class="headerlink" title="（1）高内聚低耦合"></a>（1）高内聚低耦合</h3><p>好的程序设计应该具有的特性：</p>
<ul>
<li><code>高内聚</code> ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li><code>低耦合</code> ：仅对外暴露少量的方法用于使用。</li>
</ul>
<h3 id="（2）封装的好处"><a href="#（2）封装的好处" class="headerlink" title="（2）封装的好处"></a>（2）封装的好处</h3><ul>
<li>良好的封装能够减少耦合。</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性以及安全性。</li>
<li>可以对成员变量进行更精确的控制。（使用者对类内部定义的属性直接操作可能会导致数据的错误、混乱或安全性问题。）</li>
</ul>
<h3 id="（3）访问权限修饰符"><a href="#（3）访问权限修饰符" class="headerlink" title="（3）访问权限修饰符"></a>（3）访问权限修饰符</h3><p>Java 权限修饰符 public、protected、default(缺省)、private 置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<ul>
<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>
<li><strong>default</strong> (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>
<li><strong>private</strong> : 在同一类内可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>
<li><strong>protected</strong> : 对同一包内的类和所有子类可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>
</ul>
<p>以下是访问控制级别：</p>
<p>public &gt; protected &gt; (default) &gt; private</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">同一个类</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">default（缺省）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>注意：对于 class 的权限修饰只可以用 public 和 default(缺省)。</p>
<h3 id="（4）实现封装的步骤"><a href="#（4）实现封装的步骤" class="headerlink" title="（4）实现封装的步骤"></a>（4）实现封装的步骤</h3><ul>
<li>使用 private 关键字来修饰成员变量（成员变量私有化）。</li>
<li>对需要访问的成员变量，提供对应的一对公共的（public）setter 方法 、getter 方法实现对该成员变量的操作（提供对外接口）。<ul>
<li>setter、getter 方法的名称应该为 private 修饰的成员变量的首字母大写，并在前面添加 get、set，比如一个private的成员变量名为 age，那么其 setter、getter 方法的名称为 setAge、getAge。</li>
<li>对于 setter 来说，不能有返回值，参数类型和成员变量对应（用于给变量赋值）</li>
<li>对于 getter 来说，不能有参数，返回值类型和成员变量对应（用于获取变量值）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以学生类为示例，说明封装的步骤</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> age;<span class="comment">// 将年龄age定义为private，只能被Student类内部访问   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义setAge方法，并定义为public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">200</span>)&#123;</span><br><span class="line">            age = -<span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄大小输入不符合实际！请重新设置一次&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            age = i; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义getAge方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：定义一个Test类，创建Student对象，并给对象赋值为张三，18岁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        <span class="comment">// student age = 18; 此语句是错误的，因为Student类中的age修饰符为private，只能在Student类中使用。</span></span><br><span class="line">        student.setAge(<span class="number">18</span>);<span class="comment">// 通过setAge()方法对年龄赋值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+ student.name );<span class="comment">// 姓名：张三</span></span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + student.getAge());<span class="comment">// 年龄：18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）构造方法"><a href="#（5）构造方法" class="headerlink" title="（5）构造方法"></a>（5）构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：	</span></span><br><span class="line"><span class="comment"> 	1.创建对象（当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员变量赋初始值。当我们通过关键字new来创建对象时，其实就是在调用构造方法）</span></span><br><span class="line"><span class="comment">	2.初始化对象的信息。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public 类名称(参数类型 参数名称) &#123;</span></span><br><span class="line"><span class="comment">    	方法体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	①构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</span></span><br><span class="line"><span class="comment">	②构造方法不要写返回值类型，连void都不写</span></span><br><span class="line"><span class="comment">	③不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值</span></span><br><span class="line"><span class="comment">	④如果没有编写任何构造方法，那么编译器将会默认提供一个构造方法，没有参数、方法体什么事情都不做。public Student() &#123;&#125;</span></span><br><span class="line"><span class="comment">	 也就是在Java语言中，每个类都至少有一个构造方法</span></span><br><span class="line"><span class="comment">	⑤一旦编写了至少一个构造方法，那么编译器将不再提供空的构造方法。</span></span><br><span class="line"><span class="comment">	⑥构造方法可以进行重载。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：定义一个学生类，并构造一个无参构造函数和全参构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个无参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个全参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String str , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        name = str;</span><br><span class="line">        age  = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        age = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义getter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）this关键字"><a href="#（6）this关键字" class="headerlink" title="（6）this关键字"></a>（6）this关键字</h3><ul>
<li>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，会优先使用局部变量。如果需要访问本类当中的成员变量，需要使用格式：<code>this.成员变量名</code></li>
<li>this 关键字指向的是当前对象的引用（this 理解为：当前对象或当前正在创建的对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用this关键字区分局部变量和成员变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;<span class="comment">// 姓名  </span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">// 年龄</span></span><br><span class="line">    <span class="comment">// 定义一个全参的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="comment">// name = name;错误，此时根据就近原则，两个name都是局部变量，并不能给成员变量初始化</span></span><br><span class="line">        <span class="comment">// age  = age;</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// this.name指成员变量，name指局部变量</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）标准代码——JavaBean"><a href="#（7）标准代码——JavaBean" class="headerlink" title="（7）标准代码——JavaBean"></a>（7）标准代码——JavaBean</h3><p>JavaBean 是一种可重用的Java组件，它可以被 Applet、Servlet、JSP 等 Java 应用程序调用，也可以可视化地被Java开发工具使用。</p>
<p>一个标准的类（也叫做JavaBean）通常要拥有下面四个组成部分：</p>
<ul>
<li>所有的成员变量都要使用 private 关键字修饰；</li>
<li>为每一个成员变量编写一对儿 getter&#x2F;setter 方法；</li>
<li>编写一个无参数的构造方法；</li>
<li>编写一个全参数的构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个标准的学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="comment">// 定义成员变量，都用private修饰</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义无参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//定义全参数的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//定义gettter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义gettter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义setter方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）代码块"><a href="#（8）代码块" class="headerlink" title="（8）代码块"></a>（8）代码块</h3><blockquote>
<p>在 Java 中，使用{}大括号括起来的代码被称为代码块。</p>
</blockquote>
<ul>
<li><p><u>普通代码块</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见的一种代码块，有方法名称，即类中方法的方法体，可以控制变量的生命周期，提高内存利用率。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Method</span><span class="params">()</span> &#123;  <span class="comment">// 普通代码块</span></span><br><span class="line">      System.out.println(<span class="string">&quot;这是一个普通代码块&quot;</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(test.Method);<span class="comment">// 这是一个普通代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>构造代码块</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义：</span></span><br><span class="line"><span class="comment">	在类中直接定义没有任何修饰符、前缀、后缀的代码块即为构造代码块，其可以给所有对象进行初始化。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	&gt;构造代码块内部可以输出语句；</span></span><br><span class="line"><span class="comment">	&gt;每创建一个对象，就执行一次构造代码块，再执行构造方法；</span></span><br><span class="line"><span class="comment">	&gt;如果一个类中定义了多个构造代码块，则按照声明的先后顺序执行，（一般也不会构造多个）；</span></span><br><span class="line"><span class="comment">	&gt;构造代码块内可以调用静态变量、静态方法、普通成员变量、普通成员方法。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	&#123; <span class="comment">//构造代码块</span></span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个构造代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(test.num);<span class="comment">//这是一个构造代码块\n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><u>静态代码块</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义：</span></span><br><span class="line"><span class="comment">	在类中直接定义的只有static关键字修饰的代码块即为静态代码块，其可以对静态属性、类进行初始化，并且只执行一次。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	&gt;静态代码块内部可以输出语句；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块随着类的加载而执行,而且只执行一次，优先于main方法和构造方法的执行；</span></span><br><span class="line"><span class="comment">	&gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块的执行要优先于非静态代码块的执行；</span></span><br><span class="line"><span class="comment">	&gt;静态代码块内只能调用静态变量和静态方法。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Test.num);<span class="comment">//这是一个静态代码块\n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h2><h3 id="（1）继承的概念"><a href="#（1）继承的概念" class="headerlink" title="（1）继承的概念"></a>（1）继承的概念</h3><blockquote>
<p>子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。</p>
</blockquote>
<h3 id="（2）继承的优缺点"><a href="#（2）继承的优缺点" class="headerlink" title="（2）继承的优缺点"></a>（2）继承的优缺点</h3><p>优点：代码共享，减少重复代码。</p>
<ul>
<li>减少了代码冗余，提高了代码的复用性。</li>
<li>提高了代码的维护性，更有利于功能的扩展。</li>
<li>让类与类之间产生了关系，是多态的前提</li>
</ul>
<p>缺点：提高了类的耦合性，使得代码之间的联系更加紧密，那么代码独立性更差。</p>
<h3 id="（3）继承的格式"><a href="#（3）继承的格式" class="headerlink" title="（3）继承的格式"></a>（3）继承的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用extends关键字。</span></span><br><span class="line"><span class="keyword">public</span> class 父类名称&#123;</span><br><span class="line">	代码体;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称&#123;</span><br><span class="line">	代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）继承的特点"><a href="#（4）继承的特点" class="headerlink" title="（4）继承的特点"></a>（4）继承的特点</h3><ul>
<li><p>子类拥有父类非 private 的属性、方法。</p>
</li>
<li><p>子类可以拥有自己特有的属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以对父类的方法进行重写，即子类可以用自己的方式实现父类的方法。</p>
</li>
<li><p>顶层父类是Object类。所有的类默认继承Object作为父类。</p>
</li>
<li><p>java支持单继承、多级继承、不同类继承同一个类，不支持多继承</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162516.png" style="zoom:60%;" /></li>
</ul>
<h3 id="（5）重写"><a href="#（5）重写" class="headerlink" title="（5）重写"></a>（5）重写</h3><blockquote>
<p>重写（也称为覆盖）：子类对父类方法的实现过程进行重新编写。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 父类名称&#123;</span><br><span class="line">    <span class="comment">// 父类被重写的方法A</span></span><br><span class="line">	修饰符 返回值类型 方法名称(参数列表)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 子类名称 extends 父类名称&#123;</span><br><span class="line">    <span class="comment">// 子类重写父类的方法A</span></span><br><span class="line">	修饰符 返回值类型 和父类相同方法名称(和父类相同的参数列表)&#123;</span><br><span class="line">        新的方法体;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>重写的好处</u>：子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p><u>重写的要求</u>：</p>
<ul>
<li><p>子类重写的方法必须和父类被重写的方法具有相同的方法名称和参数列表。</p>
</li>
<li><p>父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void</p>
<p>父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类</p>
<p>父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型(一模一样)。</p>
</li>
<li><p>子类方法的权限必须【大于等于】父类方法的权限修饰符。public &gt; protected &gt; (default) &gt; private</p>
<p> 子类不能重写父类中声明为 private 权限的方法。</p>
</li>
<li><p>子类方法抛出的异常不能大于父类被重写方法的异常。</p>
</li>
<li><p>在子类的重写方法前，可以加一个注解 @override，用来检测是不是有效的正确覆盖重写。</p>
</li>
</ul>
<p><u>重写的特点</u>：创建的是子类对象，则优先用子类方法。</p>
<p><u>重写与重载的区别★★★：</u></p>
<p>重载：同一个类中不同方法具有相同的名字，但是参数不一样，即参数的名称和参数的类型不一样。同类不同参。</p>
<p>重写：子父类的，即子类与父类具有相同的方法名字还有参数参数相同和相同的返回类型。即同名同参同类型。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">参数列表</th>
<th align="center">是否有继承关系</th>
</tr>
</thead>
<tbody><tr>
<td align="center">重载（overload）</td>
<td align="center">必须不同</td>
<td align="center">无继承关系，在同一个类中</td>
</tr>
<tr>
<td align="center">重写（override）</td>
<td align="center">必须相同</td>
<td align="center">有继承关系，在不同类中</td>
</tr>
</tbody></table>
<h3 id="（6）super-关键字"><a href="#（6）super-关键字" class="headerlink" title="（6）super 关键字"></a>（6）super 关键字</h3><p>如果子类想要调用父类中的内容，可以使用super关键字，主要有下面三种用法：</p>
<p>​    ① super 可用于访问父类中定义的成员变量【因为成员变量时私有的，所有子类不能直接调用父类的，需要用到super关键字】</p>
<p>​    ② super 可用于调用父类中定义的成员方法</p>
<p>​    ③ super 可用于在子类构造器中调用父类的构造器</p>
<p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用 super 表明调用的是父类中的成员</li>
<li>super 的追溯不仅限于直接父类</li>
<li>super 和 this 的用法相像，this 代表本类对象的引用，super 代表父类的内存空间的标识</li>
</ul>
<p><strong>super 关键字的使用</strong>：</p>
<p>① <u>访问成员变量</u>★</p>
<p>​    <code>this.成员变量</code> -&gt;本类的  </p>
<p>​    <code>super.成员变量</code> -&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);<span class="comment">// 没有this和super，局部变量，30</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num);<span class="comment">// 有this，本类中的成员变量，20</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num);<span class="comment">// 有super，父类中的成员变量，10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② <u>访问成员方法</u>★</p>
<p>​    <code>this.成员方法名() </code>-&gt;本类的  </p>
<p>​    <code>super.成员方法名() </code>-&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类的成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.method();<span class="comment">// 有this，调用子类中方法</span></span><br><span class="line">        <span class="built_in">super</span>.method();<span class="comment">// 有super，调用父类中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ <u>访问构造方法</u>★</p>
<p>​    <code>this.(形参列表)</code> -&gt;本类的  </p>
<p>​    <code>super(形参列表)</code> -&gt;父类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 子类构造方法当中有一个默认隐含的“super()”调用，调用父类的空参构造。所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">2. 子类构造可以通过super关键字来调用父类重载构造，手动调用父类构造会覆盖默认的super(),</span></span><br><span class="line"><span class="comment">3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 隐含有一个super()；</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类的构造方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在main方法中，new了一个子类B，那么会使用B的构造方法，而B继承了A，则会先调用父类A的构造方法，再调用子类B的构造方法</span></span><br><span class="line"><span class="comment">结果为：</span></span><br><span class="line"><span class="comment">父类的构造方法执行了</span></span><br><span class="line"><span class="comment">子类的构造方法执行了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>总结：★ <strong>this 和 super 的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">访问成员变量</th>
<th align="center">调用成员方法</th>
<th>调用构造方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">this</td>
<td align="center">访问本类中的成员变量，如果本类没有，则从父类中继续查找</td>
<td align="center">访问本类中的成员方法，如果本类没有，则从父类中继续查找</td>
<td>访问本类中的构造方法</td>
</tr>
<tr>
<td align="center">super</td>
<td align="center">直接访问父类中的成员变量</td>
<td align="center">直接访问父类中的成员方法</td>
<td>访问父类中的构造方法</td>
</tr>
</tbody></table>
<p>在主函数中，创建具有继承关系的对象时，</p>
<p>如果成员变量或者静态方法重名，看等号左边是谁，则优先用谁，没有则向上找。（编译看左边，运行看左边）</p>
<p>如果成员方法重名，看 new 的谁，则优先用谁，没有则向上找。（编译看左边，运行看右边）</p>
<h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h2><h3 id="（1）多态的概念"><a href="#（1）多态的概念" class="headerlink" title="（1）多态的概念"></a>（1）多态的概念</h3><blockquote>
<p>同一行为发生在不同的对象上会产生不同的结果。（同一行为，具有多个不同表现形式）</p>
</blockquote>
<h3 id="（2）多态的优缺点"><a href="#（2）多态的优缺点" class="headerlink" title="（2）多态的优缺点"></a>（2）多态的优缺点</h3><p>优点：提高了代码的扩展性，前期定义的代码可以使用后期的内容，而且可以接口复用（子类共用一个父类接口）。</p>
<p>缺点：多态不能访问子类特有的功能（ 前期定义的内容不能使用(调用)后期子类的特有内容。）</p>
<h3 id="（3）多态的使用"><a href="#（3）多态的使用" class="headerlink" title="（3）多态的使用"></a>（3）多态的使用</h3><p>使用多态的前提：</p>
<p>① 存在继承或者实现关系</p>
<p>② 子类覆盖（重写）父类方法</p>
<p>③ 向上转型（父类引用指向子类对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多态的格式：</span></span><br><span class="line"><span class="comment">	父类类型 变量名 = new 子类对象；</span></span><br><span class="line"><span class="comment">	变量名.方法名();</span></span><br><span class="line"><span class="comment">在多态的代码当中，</span></span><br><span class="line"><span class="comment">成员方法的访问规则是：看new的是谁，就优先用谁，没有则向上找。（编译看左边，运行看右边）</span></span><br><span class="line"><span class="comment">成员变量或者静态方法的访问规则是：看等号左边是谁，则优先用谁，没有则向上找。（编译看左边，运行看左边）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法不是重写，因为有static关键字，如果加上 @override 会报错</span></span><br><span class="line">    <span class="comment">// 如果子类有和父类相同的静态方法，那么父类的静态方法将会被隐藏，对于子类不可见</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法不是重写，因为有static关键字，如果加上@override会报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        System.out.println(animal.name);<span class="comment">// 成员变量，编译看左，运行也看左。运行的是父类的成员变量，结果为：动物</span></span><br><span class="line">        animal.eat();<span class="comment">// 成员方法，编译看左，运行看右。运行的是子类的成员方法，结果为：猫吃鱼</span></span><br><span class="line">        animal.sleep();<span class="comment">// 静态方法，编译看左，运行也看左。运行的是父类的静态方法，结果为：动物在睡觉</span></span><br><span class="line">        <span class="comment">// animal.catchMouse();错误！多态时，不能使用子类特有的属性和方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        function(cat);<span class="comment">// 发生了多态</span></span><br><span class="line">        function(dog);<span class="comment">// 发生了多态，实现了接口复用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(Animal animal)</span>&#123; <span class="comment">// 接口复用，如果没有多态性，则需要重载</span></span><br><span class="line">        animal.eat();</span><br><span class="line">        animal.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）instanceof-关键字"><a href="#（4）instanceof-关键字" class="headerlink" title="（4）instanceof 关键字"></a>（4）instanceof 关键字</h3><p>instanceof 关键字用于来判断多态中父类引用的对象，原本是哪个子类（判断某个对象是否是某个 Class 类的实例）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：对象名 instanceof 数据类型</span></span><br><span class="line"><span class="comment">返回值为boolean。</span></span><br><span class="line"><span class="comment">	如果对象属于该数据类型，返回true。</span></span><br><span class="line"><span class="comment">	如果对象不属于该数据类型，返回false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        System.out.println(animal <span class="keyword">instanceof</span> Cat);<span class="comment">//由于定义的时候，animal原本是Cat类，则结果为true</span></span><br><span class="line">        System.out.println(animal <span class="keyword">instanceof</span> Dog);<span class="comment">//由于定义的时候，animal原本是Cat类，不是Dog类，则结果为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（5）引用类型转换"><a href="#（5）引用类型转换" class="headerlink" title="（5）引用类型转换"></a>（5）引用类型转换</h3><ul>
<li><p><u>向上转型</u></p>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。（类似于基本类型中的自动类型转换）</span></span><br><span class="line"><span class="comment">使用格式：</span></span><br><span class="line"><span class="comment">	父类类型  变量名 = new 子类类型();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>向下转型</u></p>
<p>一个已经向上转型的子类对象，将父类引用再转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父类类型向子类类型向下转换的过程，这个过程是强制的。（类似于基本类型中的强制类型转换）</span></span><br><span class="line"><span class="comment">使用格式：</span></span><br><span class="line"><span class="comment">	变量名 = (子类类型) 父类变量名;</span></span><br><span class="line"><span class="comment">向下转型的目的：</span></span><br><span class="line"><span class="comment">	多态的一个缺点就是不能调用子类中特有的方法。而如果想要调用子类特有的方法，就需要向下转型。</span></span><br><span class="line"><span class="comment">向下转型的注意事项：</span></span><br><span class="line"><span class="comment">	使用强转时，可能出现ClassCastException的异常，出现异常的原因是多态中父类引用的对象，原本不是此子类，却想要转型为此子类。为了避免在向下转型时出现ClassCastException的异常，在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Cat</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 猫特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 狗特有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keepHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗看家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建主方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();  <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="comment">// Dog dog = (Dog)animal; 语句错误，本来new的是Cat，却要转换为Dog，会出现ClassCastException</span></span><br><span class="line">        <span class="comment">// Cat cat = (Cat)animal; //向下转型</span></span><br><span class="line"></span><br><span class="line">        function(animal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">(Animal animal)</span> &#123; <span class="comment">// 接口复用</span></span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Cat) &#123;  <span class="comment">// 如果animal对象原本属于Cat类，则进行向下转型，并调用Cat特有的方法</span></span><br><span class="line">            <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal;</span><br><span class="line">            cat.catchMouse();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Dog) &#123;  <span class="comment">// 如果animal对象原本属于Dog类，则进行向下转型，并调用Dog特有的方法</span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">            dog.keepHouse();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于定义的animal原本属于Cat类，故最终结果为：猫抓老鼠</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（6）final关键字"><a href="#（6）final关键字" class="headerlink" title="（6）final关键字"></a>（6）final关键字</h3><p>final 关键字代表最终、不可改变的，可以用来修饰：类、方法、变量。</p>
<ul>
<li><p><u>final 修饰类</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	final class 类名 &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的类，不能被继承。比如：String类、System类、StringBuffer类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>final 修饰方法</u></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 final 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">    	//方法体</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的方法，不能被重写。比如：Object类中getClass();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><u>final 修饰变量</u></p>
<p>① 修饰局部变量——基本类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	方式一：</span></span><br><span class="line"><span class="comment">		final 数据类型 变量名;</span></span><br><span class="line"><span class="comment">		变量名 = 值;</span></span><br><span class="line"><span class="comment">	方式二：</span></span><br><span class="line"><span class="comment">		final 数据类型 变量名 = 值;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	被final修饰的局部变量，只能被赋值一次。</span></span><br><span class="line"><span class="comment">	被final修饰的常量名称，一般都有书写规范，所有字母都大写。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> NUM;	<span class="comment">//声明变量，使用final修饰        </span></span><br><span class="line">        NUM = <span class="number">10</span>;	<span class="comment">//赋值</span></span><br><span class="line">        <span class="comment">//NUM = 20; // 报错,不可重新赋值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 声明变量，直接赋值，使用final修饰</span></span><br><span class="line">        <span class="comment">//NUM1 = 20; // 报错,不可重新赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 修饰局部变量——引用类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	final 引用数据类型 变量名 = new 引用数据类型(参数列表);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;引用类型final关键字的测试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="comment">//test  =new Test();//报错，不能指向新的对象。</span></span><br><span class="line">        test.method();<span class="comment">//引用类型final关键字的测试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员初始化方式有两种，只能二选一：</span></span><br><span class="line"><span class="comment">	①显示初始化；</span></span><br><span class="line"><span class="comment">		public class Test &#123;</span></span><br><span class="line"><span class="comment">    		final int NUM = 10;</span></span><br><span class="line"><span class="comment">		&#125;	</span></span><br><span class="line"><span class="comment">	②构造方法初始化。</span></span><br><span class="line"><span class="comment">		public class Test &#123;</span></span><br><span class="line"><span class="comment">   		 	final int NUM;</span></span><br><span class="line"><span class="comment">   		 	public Test(int num) &#123;</span></span><br><span class="line"><span class="comment">       		 	this.NUM = num;</span></span><br><span class="line"><span class="comment">  		 	&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-抽象"><a href="#5-抽象" class="headerlink" title="5. 抽象"></a>5. 抽象</h2><h3 id="（1）抽象类"><a href="#（1）抽象类" class="headerlink" title="（1）抽象类"></a>（1）抽象类</h3><p>用 abstract 关键字来修饰一个类，这个类就叫做抽象类。</p>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类；</p>
<p>随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 abstract class 类名 &#123;</span></span><br><span class="line"><span class="comment"> 		代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 抽象类不能实例化，即不能创建对象；</span></span><br><span class="line"><span class="comment">	② 抽象类一定要被继承，否则没有意义。且抽象类中一定有构造器，便于其子类实例化时调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">animal</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）抽象方法"><a href="#（2）抽象方法" class="headerlink" title="（2）抽象方法"></a>（2）抽象方法</h3><p>用 abstract 关键字来修饰一个方法，这个方法就叫做抽象方法。</p>
<p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 abstract 返回值类型 方法名 (参数列表);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 抽象方法只有方法声明，没有方法体；</span></span><br><span class="line"><span class="comment">	② 如果一个类中含有抽象方法，那么这个类必须定义为抽象类。反之不成立，抽象类中可以没有抽象方法的。</span></span><br><span class="line"><span class="comment">	③ 继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</span></span><br><span class="line"><span class="comment">	④ 不能用abstract修饰变量、代码块、构造器；</span></span><br><span class="line"><span class="comment">	⑤ 不能用abstract修饰私有方法、静态方法、final的方法、final的类。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建一个抽象的父类Animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个子类Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//子类重写父类的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Animal animal = new Aniaml();错误，抽象类不能实例化</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6. 接口"></a>6. 接口</h2><blockquote>
<p>Java 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p>
</blockquote>
<p>类的内部封装了成员变量、构造方法和成员方法，而接口的内部封装了常量和抽象方法（JDK 7及以前）、默认方法和静态方法（JDK 8）、私有方法（JDK 9）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public interface 接口名称 &#123;</span></span><br><span class="line"><span class="comment">		// 成员变量，使用 public static final 修饰，关键字可以省略，供子类调用或者子类重写。</span></span><br><span class="line"><span class="comment">    	// 抽象方法，使用 public abstract 修饰，关键字可以省略，没有方法体。该方法供子类实现使用。</span></span><br><span class="line"><span class="comment">   	 	// 默认方法，使用 public default 修饰，default不可省略，供子类调用或者子类重写。（JDK 8有的新特性）</span></span><br><span class="line"><span class="comment">   		// 静态方法，使用 public static 修饰，static不可省略，供接口直接调用。（JDK 8有的新特性）</span></span><br><span class="line"><span class="comment">   	 	// 私有方法，使用 private 修饰，供接口中的默认方法或者静态方法调用。（JDK 9有的新特性）</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 接口中没有构造器，意味着接口不可以实例化。</span></span><br><span class="line"><span class="comment">	② 接口不能直接使用，必须有一个“实现类”来实现（implements）该接口。如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化；如果实现类没覆盖接口中所有的抽象方法，则此实现类必须为一个抽象类。</span></span><br><span class="line"><span class="comment">	③ 一个类可以实现多个接口（多实现），接口也可以继承其它接口（且可以多继承）。---&gt;弥补了Java单继承性的局限性</span></span><br><span class="line"><span class="comment">	④ 接口与实现类之间存在多态性。</span></span><br><span class="line"><span class="comment">	⑤ 继承是一个&quot;是不是&quot;（is a）的关系，而接口实现则是 &quot;能不能&quot;（hava a）的关系。</span></span><br><span class="line"><span class="comment">	⑥ 默认方法可以解决接口升级的问题，直接在接口中写默认方法，而实现类不需要重写，默认就有了此方法。</span></span><br><span class="line"><span class="comment">	⑦ 优先级的问题：当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</span></span><br><span class="line"><span class="comment">	⑧ 接口中，有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。</span></span><br><span class="line"><span class="comment">	⑨ 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</span></span><br><span class="line"><span class="comment">接口的使用步骤（实现）：</span></span><br><span class="line"><span class="comment">	public class 实现类名称 implements 接口名称 &#123;</span></span><br><span class="line"><span class="comment">   	 	// 重写接口中抽象方法【必须】</span></span><br><span class="line"><span class="comment">   		// 重写接口中默认方法【可选】</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">haveWings</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有翅膀可以飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写接口中的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小鸟正在飞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        bird.fly();<span class="comment">// 小鸟正在飞</span></span><br><span class="line">        bird.haveWings(); <span class="comment">// 有翅膀可以飞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★ <strong>抽象类与接口的对比</strong></p>
<ul>
<li>相同点<ul>
<li>均不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</li>
</ul>
</li>
<li>不同点<ul>
<li>抽象类中有构造方法，而接口中没有。</li>
<li>抽象类不能多继承，而接口可以。</li>
<li>接口中的变量必须有 static、final 修饰，实际是一个常量，必须赋初值，而抽象类可以任意。</li>
</ul>
</li>
</ul>
<h2 id="7-内部类"><a href="#7-内部类" class="headerlink" title="7. 内部类"></a>7. 内部类</h2><blockquote>
<p>如果将一个类定义在另一个类里面或者一个方法里面，这样的类就称为内部类。内部类又可以分为成员内部类、局部内部类、匿名内部类和静态内部类。</p>
</blockquote>
<h3 id="（1）成员内部类"><a href="#（1）成员内部类" class="headerlink" title="（1）成员内部类"></a>（1）成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部。在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这种结构。比如，汽车类 Car 中包含发动机类 Engine ，这时，Engine 就可以使用成员内部类来描述。</p>
<p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的 .class文件，但是前面冠以外部类的类名和$符号 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	class 外部类名 &#123;</span></span><br><span class="line"><span class="comment">		外部类属性;</span></span><br><span class="line"><span class="comment">		外部类方法;</span></span><br><span class="line"><span class="comment">		class 内部类名 &#123;</span></span><br><span class="line"><span class="comment">			内部类属性;</span></span><br><span class="line"><span class="comment">			内部类方法;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">创建内部类对象格式：</span></span><br><span class="line"><span class="comment">（成员内部类是依附外部类的，只有创建了外部类才能创建内部类）</span></span><br><span class="line"><span class="comment">	方式一：</span></span><br><span class="line"><span class="comment">		外部类名.内部类名 内部对象名 = new 外部类名().new 内部类名();</span></span><br><span class="line"><span class="comment">	方式二：</span></span><br><span class="line"><span class="comment">		外部类名 外部对象名 = new 外部类名();</span></span><br><span class="line"><span class="comment">		外部类名.内部类名 内部对象名 = 外部对象名.new 内部类名();</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 和外部类不同，内部类可以被任意权限修饰符修饰；</span></span><br><span class="line"><span class="comment">	② 内部类可以直接访问外部类的成员，包括私有成员；</span></span><br><span class="line"><span class="comment">	③ 外部类要访问内部类的成员，必须要建立内部类的对象；</span></span><br><span class="line"><span class="comment">	④ 当内部类属性和外部类属性重名时，内部类可以通过【外部类名.this.属性名】的方式调用外部类重名属性；</span></span><br><span class="line"><span class="comment">	⑤ 当内部类方法和外部类方法重名时，内部类可以通过【外部类名.this.方法名】的方式调用外部类重名方法；</span></span><br><span class="line"><span class="comment">	⑥ 内部类的内部不能有静态信息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">            System.out.println(num); <span class="comment">// 内部类调用内部类属性，20</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.num); <span class="comment">// 内部类调用外部类属性，10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        outer.outerMethod(); <span class="comment">// 这是一个外部类方法</span></span><br><span class="line">        inner.innerMethod(); <span class="comment">//  这是一个内部类方法 \n20 \n10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）局部内部类"><a href="#（2）局部内部类" class="headerlink" title="（2）局部内部类"></a>（2）局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	class 外部类名 &#123;</span></span><br><span class="line"><span class="comment">		外部类属性;</span></span><br><span class="line"><span class="comment">		修饰符 返回值类型 外部类方法名(形参)&#123;</span></span><br><span class="line"><span class="comment">			class 内部类名 &#123;</span></span><br><span class="line"><span class="comment">				内部类属性;</span></span><br><span class="line"><span class="comment">				内部类方法;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private；</span></span><br><span class="line"><span class="comment">	② 局部内部类不能使用static修饰，因此也不能包含静态成员，因为在方法结束之后，内存需要释放；</span></span><br><span class="line"><span class="comment">	③ 局部内部类只能在定义的方法中使用，创建对象后使用，并且可以直接访问方法内的局部变量和参数，但是不能更改。</span></span><br><span class="line"><span class="comment">	④ 当内部类属性和外部类属性重名时，内部类可以通过【外部类名.this.属性名】的方式调用外部类重名属性；</span></span><br><span class="line"><span class="comment">	⑤ 当内部类方法和外部类方法重名时，内部类可以通过【外部类名.this.方法名】的方式调用外部类重名方法；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">// 方法的局部变量</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">                System.out.println(num); <span class="comment">// 内部类调用内部类属性，30</span></span><br><span class="line">                System.out.println(Outer.<span class="built_in">this</span>.num); <span class="comment">// 内部类调用外部类属性，10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        outer.outerMethod(); <span class="comment">// 这是一个外部类方法 \n30 \n10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）匿名内部类"><a href="#（3）匿名内部类" class="headerlink" title="（3）匿名内部类"></a>（3）匿名内部类</h3><p>匿名内部类是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口】的匿名的子类对象。开发中，最常用到的内部类就是匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">方式一：（匿名内部类，非匿名对象）</span></span><br><span class="line"><span class="comment">	父接口名 实现名  = new 父类名或父接口名() &#123;</span></span><br><span class="line"><span class="comment">		重写父类或父接口的abstract方法;</span></span><br><span class="line"><span class="comment">		自己特有的方法;</span></span><br><span class="line"><span class="comment">	&#125;;</span></span><br><span class="line"><span class="comment">	实现名.方法名(形参);</span></span><br><span class="line"><span class="comment">方式二：（匿名内部类且匿名对象）</span></span><br><span class="line"><span class="comment">	new 父类名或父接口名() &#123;</span></span><br><span class="line"><span class="comment">		重写父类或父接口的abstract方法;</span></span><br><span class="line"><span class="comment">		自己特有的方法;</span></span><br><span class="line"><span class="comment">	&#125;.方法名(形参);</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 匿名内部类必须继承一个父类或者实现一个父接口；</span></span><br><span class="line"><span class="comment">	② 如果某个局部类你只需要用一次，则可以考虑使用匿名内部类；</span></span><br><span class="line"><span class="comment">	③ 匿名内部类没有类名，因此没有构造方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义一个父类接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类，非匿名对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;  <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.method(); <span class="comment">// 实现接口中的抽象方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类且匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>() &#123;  <span class="comment">// 匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;实现接口中的抽象方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();<span class="comment">// 在大括号后直接调用类中方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）静态内部类"><a href="#（4）静态内部类" class="headerlink" title="（4）静态内部类"></a>（4）静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态内部类创建对象格式：</span></span><br><span class="line"><span class="comment">	外部类名.内部类名 对象名 = new 外部类名.内部类名(); //注意和成员内部类不同</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 静态内部类的创建不需要依赖外部类可以直接创建。</span></span><br><span class="line"><span class="comment">	② 静态内部类不可以使用任何外部类的非static类（包括属性和方法），但可以存在自己的成员变量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// 外部类属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123; <span class="comment">// 外部类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个外部类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 内部类属性</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123; <span class="comment">// 内部类方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个内部类方法&quot;</span>);</span><br><span class="line">            <span class="comment">//outerMethod();// 错误，不能调用非静态方法</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 内部类调用内部类属性，20</span></span><br><span class="line">            <span class="comment">//System.out.println(Outer.this.num);// 错误，不能调用外部非静态属性</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五-Java常用API"><a href="#五-Java常用API" class="headerlink" title="五. Java常用API"></a>五. Java常用API</h1><blockquote>
<p>API（Application Programming Interface），应用程序编程接口。它是 JDK 中提供给使用者的一些常用类的说明文档，使用者不需要访问源码或理解内部工作机制的细节，只需要会使用即可。在查看 API 文档时，使用者需要查看当前类的包路径、构造方法以及方法摘要。</p>
</blockquote>
<p>引用类型的一般使用步骤：</p>
<ul>
<li><p>①<code>导包</code>。import 包路径.类名称；</p>
<ul>
<li>如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</li>
<li>如果使用的类或接口是 java.lang 包下定义的，则可以省略 import 结构。</li>
<li>可以使用 “xxx.*” 的方式，表示可以导入 xxx 包下的所结构。    </li>
<li>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</li>
</ul>
</li>
<li><p>②<code>创建</code>。类名称 对象名 &#x3D; new 类名称 ( 参数列表 );</p>
</li>
<li><p>③<code>使用</code>。对象名.成员方法名 ()；</p>
</li>
</ul>
<h2 id="1-Object-类"><a href="#1-Object-类" class="headerlink" title="1. Object 类"></a>1. Object 类</h2><ul>
<li>Object 类在 java.lang 包下，导包语句可以省略不写</li>
<li>java.lang.Object 类是 Java 语言中的根类，即所有类的父类。</li>
<li>如果一个类没有特别指定父类，那么默认则继承自 Object 类。</li>
<li>Object 类只声明了一个空参的构造器</li>
<li>Object 类中的所有方法，子类均都可以使用。（equals() 、toString() 、getClass() 、hashCode()…）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★ equals方法</span></span><br><span class="line"><span class="comment">定义： </span></span><br><span class="line"><span class="comment">    public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">    	return (this == obj);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	①Object类中定义的equals()和==的作用是相同的：比较两个对象的【地址值】是否相同，即两个引用是否指向同一个对象实体。</span></span><br><span class="line"><span class="comment">	②对于自定义的类，如果希望进行对象【内容】的比较，则可以覆盖重写equals方法。</span></span><br><span class="line"><span class="comment">	③像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的&quot;实体内容&quot;是否相同。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//equals方法的重写：</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;	</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//对equals方法进行重写</span></span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 转换为当前类型</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">            <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">            <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★ toString方法</span></span><br><span class="line"><span class="comment">定义： </span></span><br><span class="line"><span class="comment">	 public String toString() &#123;</span></span><br><span class="line"><span class="comment">        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	①当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。</span></span><br><span class="line"><span class="comment">	②toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</span></span><br><span class="line"><span class="comment">	③对于自定义的类，如果希望返回对象的【实体内容】，则可以覆盖重写toSting方法。</span></span><br><span class="line"><span class="comment">	④像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回&quot;实体内容&quot;信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// toString方法的重写：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 对toSting方法进行重写</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> + <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Scanner类"><a href="#2-Scanner类" class="headerlink" title="2. Scanner类"></a>2. Scanner类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中，实现人机交互。</span></span><br><span class="line"><span class="comment">Scanner类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Scanner;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		Scanner 对象名 = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">	③使用		</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个int数字：int 变量名 = 对象名.nextInt();</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个double数字：double 变量名 = 对象名.nextDouble();</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个字符串：String 变量名 = 对象名.next();//结束符是回车/空格/Tab</span></span><br><span class="line"><span class="comment">		● 获取键盘输入的一个字符串：String 变量名 = 对象名.nextLine();//读取一行，结束符只有回车</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：从键盘输入两个int数字并求和</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); </span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;两数之和为：&quot;</span>+(num1+num2));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Random类"><a href="#3-Random类" class="headerlink" title="3. Random类"></a>3. Random类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类的功能：用来生成随机数字。</span></span><br><span class="line"><span class="comment">Random类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Random;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		Random 对象名 = new Random();</span></span><br><span class="line"><span class="comment">	③使用		</span></span><br><span class="line"><span class="comment">		● 获取一个随机的int数字（范围是int所有范围）：int 变量名 = 对象名.nextInt();</span></span><br><span class="line"><span class="comment">		● 获取一个随机的int数字（参数代表了范围，左闭右开区间）：int 变量名 = 对象名.nextInt(n);</span></span><br><span class="line"><span class="comment">		● 如果输入的为n，那么此时随机的数字范围是【0，n)，又由于是整数，那么实际取值为0 1 2 ... n-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：创建一个随机整数，范围为[1, 10]</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>)+<span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数为：&quot;</span>+num);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-String类"><a href="#4-String类" class="headerlink" title="4. String类"></a>4. String类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String类的功能：字符串。</span></span><br><span class="line"><span class="comment">String类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.String;//String类在java.lang包下，导包语句可以省略不写</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		方式一：直接创建</span></span><br><span class="line"><span class="comment">			String 对象名 = &quot;Hello&quot;; //最常用</span></span><br><span class="line"><span class="comment">        方式二：无参或有参构造</span></span><br><span class="line"><span class="comment">        	String 对象名 = new String();// 创建了一个空白字符串，不含有任何内容。</span></span><br><span class="line"><span class="comment">        	String 对象名 = new String(String original);。</span></span><br><span class="line"><span class="comment">		方式三：通过字符数组构造</span></span><br><span class="line"><span class="comment">			char[] 字符数组名= &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;    </span></span><br><span class="line"><span class="comment">			String 对象名 = new String(字符数组名);</span></span><br><span class="line"><span class="comment">		方式四：通过字节数组构造</span></span><br><span class="line"><span class="comment">			byte [] 字节数组名= &#123; 97, 98, 99 &#125;;    </span></span><br><span class="line"><span class="comment">			String 对象名 = new String(字节数组名);</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● ★boolean equals(Object obj)：比较字符串的内容是否相同，如果相同，则返回true，如果不同，则返回false。</span></span><br><span class="line"><span class="comment">			注意：如果比较双方一个常量一个变量，推荐把常量字符串写在前面，即</span></span><br><span class="line"><span class="comment">				 推荐：&quot;abc&quot;.equals(str)    </span></span><br><span class="line"><span class="comment">			 	 不推荐：str.equals(&quot;abc&quot;)（因为如果变量值为null，则会报NullPointerException的错误）</span></span><br><span class="line"><span class="comment">		● ★boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。（比如验证码）</span></span><br><span class="line"><span class="comment">		● ★int length() ：返回此字符串的长度。</span></span><br><span class="line"><span class="comment">		● String concat (String str) ：将指定的字符串连接到该字符串的末尾，等价于用“+”。</span></span><br><span class="line"><span class="comment">		● ★char charAt (int index) ：返回指定索引处的char值。</span></span><br><span class="line"><span class="comment">		● int indexOf (String str / Char c) ：返回指定子字符串/字符第一次出现在该字符串内的索引。如果没有，返回-1</span></span><br><span class="line"><span class="comment">		● int indexOf (String str,int Startindex) ：返回指定子字符串/字符第一次出现在该字符串内的索引(从StartIndex处开始进行搜索)。如果没有，返回-1</span></span><br><span class="line"><span class="comment">		● boolean isEmpty() ：判断是否是空字符串</span></span><br><span class="line"><span class="comment">		● String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="comment">		● String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到endIndex截取字符串。包含beginIndex，不包含endIndex。</span></span><br><span class="line"><span class="comment">		● int compareTo(String anotherString)：比较两个字符串的大小（一个字符一个字符的比较），如果原字符串更大，返回1，相同返回0，原字符串更小返回-1</span></span><br><span class="line"><span class="comment">		● String replace(char oldChar, char newChar)：返回一个新的字符串，用newChar替换此字符串中出现的所有oldChar（比如敏感词用*替代）</span></span><br><span class="line"><span class="comment">		● ★char[] toCharArray () ：将此字符串转换为新的字符数组。</span></span><br><span class="line"><span class="comment">		● ★byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span></span><br><span class="line"><span class="comment">		● String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">String类的注意事项：</span></span><br><span class="line"><span class="comment">	①Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。</span></span><br><span class="line"><span class="comment">	②字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改，即不可以修改字符串中的单个字符。</span></span><br><span class="line"><span class="comment">	③字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。</span></span><br><span class="line"><span class="comment">	④字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中，而new出来的不在字符串常量池中。</span></span><br><span class="line"><span class="comment">		对于基本类型来说，==是进行数值的比较（数据类型不一定要相同，会发生自动类型转换）。</span></span><br><span class="line"><span class="comment">		对于引用类型来说，==是进行【地址值】的比较。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// String中，==和equals方法的比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">// 直接创建的字符串在字符串常量池中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);<span class="comment">// 通过字符数组创建的字符串不在字符串常量池中。</span></span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str1 == str3); <span class="comment">// false，对于引用类型来说，==是进行【地址值】的比较。</span></span><br><span class="line">        System.out.println(str1.equals(str3));<span class="comment">// true,string类中equals方法比较的是内容。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：输入一个字符串，统计其中的大写字母个数、小写字母个数、数字个数以及其他字符个数。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numbers</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">others</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                upper++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                lower++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; chars[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                numbers++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                others++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;大写字母有&quot;</span> + upper + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字母有&quot;</span> + lower + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字有&quot;</span> + numbers + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;其他字符有&quot;</span> + others + <span class="string">&quot;个&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串一旦创建，不可改变（优点是编译器可以让字符串共享）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        System.out.println(str);<span class="comment">// aaa</span></span><br><span class="line">        str = <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        System.out.println(str);<span class="comment">// bbb，此时并不是字符串改变了，只是str不指向aaa，而指向一个新的字符串bbb了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：输入一个字符串，如果字符串中有“你大爷的”四个汉字，则用“****”替代。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串：&quot;</span>);<span class="comment">// 输入：我可去你大爷的，真的醉了，你大爷的！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> string.replace(<span class="string">&quot;你大爷的&quot;</span>,<span class="string">&quot;****&quot;</span>);</span><br><span class="line">        System.out.println(string1);<span class="comment">// 输出：我可去****，真的醉了，****！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-StringBuffer、StringBuilder"><a href="#5-StringBuffer、StringBuilder" class="headerlink" title="5. StringBuffer、StringBuilder"></a>5. StringBuffer、StringBuilder</h2><p>String 类对象一旦创建不可改变，如果想要<u>对字符串进行修改，并且不产生新的对象</u>，可以使用 StringBuffer 和 StringBuilder 类。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">StringBuffer类的功能：线程安全的可变字符串。</span></span><br><span class="line"><span class="comment">StringBuffer类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.StringBuffer;//导包语句可以省略不写</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer();// 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符。</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer(String str);//指定字符串内容。</span></span><br><span class="line"><span class="comment">        	StringBuffer 对象名 = new StringBuffer(int capacity);//指定初始容量</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● 增	  StringBuffer append(xxx)： 将任意数据类型参数的字符串表示形式追加到此序列，并返回当前对象自身。</span></span><br><span class="line"><span class="comment">			   StringBuffer insert(int offset, xxx)：将任意数据类型参数的字符串表示形式插入此序列中的指定位置。</span></span><br><span class="line"><span class="comment">		● 删   StringBuffer delete(int start, int end)：移除此序列指定位置的子字符串中的字符（左闭右开）。 </span></span><br><span class="line"><span class="comment">			   StringBuffer deleteCharAt(int index) ：移除此序列指定位置的char。 </span></span><br><span class="line"><span class="comment">		● 改   StringBuffer replace(int start, int end, String str) ：使用给定字符串替换序列子字符串中的字符。</span></span><br><span class="line"><span class="comment">        	   void setCharAt(int index, char ch)：将给定索引处的字符设置为 ch。 </span></span><br><span class="line"><span class="comment">		● 查    char charAt(int index)：返回此序列中指定索引处的char值。 </span></span><br><span class="line"><span class="comment">		● 反转  StringBuffer reverse()：将此字符序列用其反转形式取代。 </span></span><br><span class="line"><span class="comment">		● 长度  int length()：返回长度（字符数）。（实际值）</span></span><br><span class="line"><span class="comment">			    int capacity()：返回当前容量。 （理论值）</span></span><br><span class="line"><span class="comment">		● 遍历  String toString() ：返回此序列中数据的字符串表示形式。 </span></span><br><span class="line"><span class="comment">				// for() + charAt()</span></span><br><span class="line"><span class="comment">StringBuffer类的注意事项：</span></span><br><span class="line"><span class="comment">	① StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</span></span><br><span class="line"><span class="comment">	② String、StringBuilder和StringBuffer底层均为字符数组</span></span><br><span class="line"><span class="comment">	③ 执行效率：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">	④ StringBuffe对字符串进行修改时不产生新的对象。调用方法时，本身就被修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-Arrays-类"><a href="#6-Arrays-类" class="headerlink" title="6. Arrays 类"></a>6. Arrays 类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Arrays类的功能：用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，不需要创建对象，调用起来非常简单。</span></span><br><span class="line"><span class="comment">Arrays类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.Arrays;</span></span><br><span class="line"><span class="comment">	②使用：</span></span><br><span class="line"><span class="comment">		Arrays.方法名</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）</span></span><br><span class="line"><span class="comment">		● static 新数组 copyOf(数组，长度)：会将数组赋值给新数组，第二个参数是新数组的长度(直接使用==的话，其实复制的是地址而不是值)，此方法还可以用于扩容。</span></span><br><span class="line"><span class="comment">		● static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序（直接对数组进行了排序，没有返回值，采用的是优化的快速排序）				</span></span><br><span class="line"><span class="comment">		● static &lt;T&gt; List&lt;T&gt;  asList(T... a) 返回一个受指定数组支持的固定大小的列表，【此方法有坑，易错】，</span></span><br><span class="line"><span class="comment">Arrays类的注意事项：</span></span><br><span class="line"><span class="comment">	①如果是数值，sort默认按照升序从小到大；</span></span><br><span class="line"><span class="comment">	②如果是字符串，sort默认按照字母升序；</span></span><br><span class="line"><span class="comment">	③如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 示例：创建一个数组，并按照 [元素1, 元素2, 元素3...] 格式打印输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays =<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arrays));<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：创建一个数组，排序后打印输出</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            System.out.print(arrays[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//1 2 3 4 5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：asList的坑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    Integer[] b = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(a);</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(b);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1,而不是3，它把整个数组当成了一个整体</span></span><br><span class="line">    System.out.println(integers.size());<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Math-类（包含-BigDecimal）"><a href="#7-Math-类（包含-BigDecimal）" class="headerlink" title="7. Math 类（包含 BigDecimal）"></a>7. Math 类（包含 BigDecimal）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Math类的功能：用于执行基本数学运算的方法，其所有方法均为静态方法，不需要创建对象，调用起来非常简单。</span></span><br><span class="line"><span class="comment">Math类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.lang.Math;（位于java.lang包下，导包可以省略不写）</span></span><br><span class="line"><span class="comment">	②使用：</span></span><br><span class="line"><span class="comment">		Math.方法名</span></span><br><span class="line"><span class="comment">	③常用方法：</span></span><br><span class="line"><span class="comment">		● static double abs(double num)：获取绝对值。有多种重载。</span></span><br><span class="line"><span class="comment">		● static double ceil(double num)：向上取整。</span></span><br><span class="line"><span class="comment">        ● static double floor(double num)：向下取整。</span></span><br><span class="line"><span class="comment">		● static long round(double num)：四舍五入（注意返回值为整型）。</span></span><br><span class="line"><span class="comment">		● static double random()：返回带正号的double值，该值【大于等于】0.0且【小于】1.0。</span></span><br><span class="line"><span class="comment">		● static double pow(double x,double a)：返回x^a，幂运算，返回值类型为double</span></span><br><span class="line"><span class="comment">		● Math.PI代表近似的圆周率常量（double）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：使用Math中的常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println( Math.abs(-<span class="number">5.6</span>));<span class="comment">//5.6</span></span><br><span class="line">        System.out.println( Math.ceil(<span class="number">4.1</span>));<span class="comment">//5.0</span></span><br><span class="line">        System.out.println( Math.floor(<span class="number">4.9</span>));<span class="comment">//4.0</span></span><br><span class="line">        System.out.println( Math.round(<span class="number">4.6</span>));<span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的:BigInteger和BigDecimal</span></span><br><span class="line"><span class="comment">BigInteger类实现任意精度的整数运算，BigDecimal实现任意精度的浮点数运算。</span></span><br><span class="line"><span class="comment">初始化：</span></span><br><span class="line"><span class="comment">	①使用静态的valueOf方法，将普通的数值转化为大数</span></span><br><span class="line"><span class="comment">		BigInteger a = BigInteger.valueOf(100)</span></span><br><span class="line"><span class="comment">	② 使用带字符串参数的构造器得到大数</span></span><br><span class="line"><span class="comment">		BigInteger b = new BigInteger(&quot;123456789123456789123456789&quot;)</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	● BigInteger add(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger subtract(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger multiply(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger devide(BigInteger other)</span></span><br><span class="line"><span class="comment">	● BigInteger compareTo(BigInteger other)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高精度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">2.0</span>-<span class="number">1.1</span>;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">a2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">1.0</span>).subtract(BigDecimal.valueOf(<span class="number">0.1</span>));</span><br><span class="line">        System.out.println(a1); <span class="comment">// 0.8999999999999999</span></span><br><span class="line">        System.out.println(a2); <span class="comment">// 0.9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-包装类"><a href="#8-包装类" class="headerlink" title="8. 包装类"></a>8. 包装类</h2><p>为了使基本数据类型的变量具有类的特征，引入了包装类的概念。基本数据类型及其对应的包装类如下所示：</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left"><strong>Integer</strong></td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left"><strong>Character</strong></td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
</tbody></table>
<ul>
<li><input checked="" disabled="" type="checkbox"> 基本数据类型与对应的包装类对象之间的转换【记住自动装箱与自动拆箱】</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★基本数据类型----&gt;包装对象【装箱】</span></span><br><span class="line"><span class="comment">	int i = 1;</span></span><br><span class="line"><span class="comment">	Integer i1 = new Integer(i);//通过包装类的构造方法实现</span></span><br><span class="line"><span class="comment">	Integer i2 = Integer.valueOf(i);//使用包装类中的valueOf方法</span></span><br><span class="line"><span class="comment">★包装对象----&gt;基本数据类型【拆箱】</span></span><br><span class="line"><span class="comment">	int num = i1.intValue();//调用包装类的.xxxValue()方法：</span></span><br><span class="line"><span class="comment">自动装箱与自动拆箱：从Java 1.5开始，【基本类型与包装类的装箱、拆箱动作可以自动完成(但类型必须匹配)】例如：</span></span><br><span class="line"><span class="comment">	int i = 1</span></span><br><span class="line"><span class="comment">	Integer i1 = i;//自动装箱。相当于Integer i = Integer.valueOf(i);</span></span><br><span class="line"><span class="comment">	int num = i1; //自动拆箱。 相当于 int num = i1.intValue();</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> 基本数据类型与字符串之间的转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">★基本数据类型----&gt;String</span></span><br><span class="line"><span class="comment">	方式一：调用字符串重载的valueOf()方法：</span></span><br><span class="line"><span class="comment">		String str = String.valueOf(2.34f);</span></span><br><span class="line"><span class="comment">	方式二：基本数据类型通过+号与””相连接</span></span><br><span class="line"><span class="comment">		String str = 1 + “”;</span></span><br><span class="line"><span class="comment">★String----&gt;基本数据类型</span></span><br><span class="line"><span class="comment">	方式一：通过包装类的构造器实现：</span></span><br><span class="line"><span class="comment">		int i = new Integer(“12”);//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">	方式二：通过包装类的parseXxx(String s)或者valueOf(String s)静态方法</span></span><br><span class="line"><span class="comment">		float f = Float.parseFloat(“12.1”)//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">		float f = Float.valueOf(“12.1”)//此时会有自动拆箱</span></span><br><span class="line"><span class="comment">注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。例如：</span></span><br><span class="line"><span class="comment">	int num = Integer.parseInt(&quot;abc&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>包装类是不可变的，即一旦构造了包装类，就不允许更改包装在其中的值，同时包装类还是 final，因此不能派生它们的子类。</p>
<h2 id="9-日期时间类"><a href="#9-日期时间类" class="headerlink" title="9. 日期时间类"></a>9. 日期时间类</h2><p><em>Date类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Date类表示特定的瞬间，精确到毫秒。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public Date()：分配Date对象并初始化此对象，表示分配它的时间（即系统当前时间）。</span></span><br><span class="line"><span class="comment">	public Date(long date)：分配Date对象并初始化此对象，表示从基准时间（1970年1月1日00:00:00 GMT）以来的指定毫秒数。</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	★ getTime():返回自1970年1月1日00:00:00 GMT以来，此Date对象表示的毫秒数。</span></span><br><span class="line"><span class="comment">	★ toString():把此Date对象转换为以下形式的 String： 星期 月 日 时：分：秒 日期标准 年</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date); <span class="comment">//Sat Aug 01 11:09:31 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>DateFormat类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.text.DateFormat是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。由于DateFormat为抽象类，不能直接使用，所以常用其子类java.text.SimpleDateFormat。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	SimpleDateFormat() ：用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。 </span></span><br><span class="line"><span class="comment">	SimpleDateFormat(String pattern) ：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。日期和时间格式由日期和时间模式字符串指定。常用模式字母：y年、M月、d日、H时、m分、s秒。模式举例：SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;)</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	★ String format(Date date)：将Date对象按照给定模式格式化为字符串。</span></span><br><span class="line"><span class="comment">	★ Date parse(String source)：将字符串解析为Date对象。(需要异常处理，因为字符串可能没有按照指定模式创建)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);<span class="comment">//格式化日期之前：Sat Aug 01 11:34:53 CST 2020</span></span><br><span class="line">        System.out.println(s.format(date)); <span class="comment">//格式化日期之后：2020年08月01日 11:34:53</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           date = s.parse(<span class="string">&quot;2020年01月01日 00:00:00&quot;</span>);<span class="comment">//将指定模式的字符串解析为一个日期</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date); <span class="comment">//解析后的结果：Wed Jan 01 00:00:00 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Calendar类</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Calendar是一个抽象类，该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</span></span><br><span class="line"><span class="comment">获取Calendar实例的方法： </span></span><br><span class="line"><span class="comment">	①使用Calendar.getInstance()方法 </span></span><br><span class="line"><span class="comment">	②调用它的子类GregorianCalendar的构造器。</span></span><br><span class="line"><span class="comment">常用方法有：</span></span><br><span class="line"><span class="comment">	★ int get(int field)：返回给定日历字段的值。</span></span><br><span class="line"><span class="comment">	  常见字段YEAR年、MONTH月、HOUR时（12小时制）、MINUTE分、SECOND秒、DAY_OF_MONTH月中的天、HOUR_OF_DAY时（24小时		制）、DAY_OF_WEEK周中的天（周几，周日为1，可以-1使用）</span></span><br><span class="line"><span class="comment">	★ void set(int field, int value)：将给定的日历字段设置为给定值。</span></span><br><span class="line"><span class="comment">	★ abstract void add(int field, int amount)：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</span></span><br><span class="line"><span class="comment">	★ Date getTime()：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 西方星期的开始为周日，即周日为1</span></span><br><span class="line"><span class="comment">	② 在Calendar类中，月份的表示是以0-11代表1-12月。</span></span><br><span class="line"><span class="comment">	③ 日期是有大小关系的，时间靠后，时间越大。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar.get(Calendar.YEAR));<span class="comment">//2020</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        System.out.println(time);<span class="comment">//Sat Aug 01 16:42:09 CST 2020</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-java-比较器"><a href="#10-java-比较器" class="headerlink" title="10. java 比较器"></a>10. java 比较器</h2><p>在Java 中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题，此时不能直接通过关系运算符（&gt;、&lt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;）进行比较，java 有三种实现对象比较的方法：</p>
<p>1）重写 Object 类的 equals() 方法，但不能比较大小，只能比较是否相等。</p>
<p>2）自然排序：继承 Comparable 接口，并实现 compareTo() 方法；</p>
<p>3）定制排序：定义一个单独的对象比较器，继承自 Comparator 接口，实现 compare() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*自然排序</span></span><br><span class="line"><span class="comment">Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 实现Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。 </span></span><br><span class="line"><span class="comment">	② 实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</span></span><br><span class="line"><span class="comment">    ③ 对于类C的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与e1.equals(e2) 具有相同的 boolean 值时，类C的自然排序才叫做与 equals 一致。建议（虽然不是必需的）最好使自然排序与equals一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个学生类，具有的属性为姓名，年龄，成绩，对于学生，首先按照成绩从低到高排序，如果成绩相同，再按照姓名自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.score &gt; s.score)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.score &lt; s.score)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student[] student = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">        student[<span class="number">0</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">12</span>,<span class="number">90</span>);</span><br><span class="line">        student[<span class="number">1</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">16</span>,<span class="number">80</span>);</span><br><span class="line">        student[<span class="number">2</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">14</span>,<span class="number">90</span>);</span><br><span class="line">        Arrays.sort(student);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; student.length; i++) &#123;</span><br><span class="line">            System.out.println(student[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">16</span>, score=<span class="number">80</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">14</span>, score=<span class="number">90</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">12</span>, score=<span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定制排序</span></span><br><span class="line"><span class="comment">当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序。 </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2 ；如果返回0，表示相等；返回负整数，表示o1 小于o2。</span></span><br><span class="line"><span class="comment">	② 可以将Comparator传递给sort方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</span></span><br><span class="line"><span class="comment">    ③ 可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 定义一个学生类，具有的属性为姓名，年龄，成绩，对于学生，首先按照成绩从低到高排序，如果成绩相同，再按照姓名自然排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;  <span class="comment">//匿名内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student &amp;&amp; o2 <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student)o1;</span><br><span class="line">                    <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student)o2;</span><br><span class="line">                    <span class="keyword">if</span>(s1.score &gt; s2.score)&#123;</span><br><span class="line">                        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1.score &lt;s2.score)&#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型比较错误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Student[] student = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">3</span>];</span><br><span class="line">        student[<span class="number">0</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">12</span>,<span class="number">90</span>);</span><br><span class="line">        student[<span class="number">1</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">16</span>,<span class="number">80</span>);</span><br><span class="line">        student[<span class="number">2</span>]= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">14</span>,<span class="number">90</span>);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(student,comparator);<span class="comment">//使用Arrays.sort进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; student.length; i++) &#123;</span><br><span class="line">            System.out.println(student[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">16</span>, score=<span class="number">80</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">14</span>, score=<span class="number">90</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">12</span>, score=<span class="number">90</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六-异常"><a href="#六-异常" class="headerlink" title="六. 异常"></a>六. 异常</h1><h2 id="1-异常的概念"><a href="#1-异常的概念" class="headerlink" title="1. 异常的概念"></a>1. 异常的概念</h2><blockquote>
<p>异常是指程序在执行过程中，出现的非正常的情况，最终会导致 JVM 的非正常停止。在 Java 等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java 处理异常的方式是中断处理。</p>
</blockquote>
<h2 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2. 异常的分类"></a>2. 异常的分类</h2><img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162550.png" style="zoom:50%;" />

<p><code>Throwable</code>：Throwable 类是 Java 语言中所有错误或异常的超类。类中常用方法有：</p>
<ul>
<li><p><u>public void printStackTrace()</u>：打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><u>public String getMessage()</u> ：获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
</ul>
<p><code>Error</code>：程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。比如栈溢出、堆溢出等错误。</p>
<p><code>Exception</code>：程序本身可以捕获并且可以处理的异常。可以分为两大类：</p>
<ul>
<li><u>非受检异常（运行时异常）</u>：指 RuntimeException 类及其子类异常，编译器不会检查此类异常，并且不要求处理异常。程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。比如数组索引越界异常，空指针异常等等。</li>
<li><u>受检异常（编译时异常</u>）：是 RuntimeException 以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常。</li>
</ul>
<h2 id="3-常见异常"><a href="#3-常见异常" class="headerlink" title="3. 常见异常"></a>3. 常见异常</h2><ul>
<li><p><code>java.lang.ArrayIndexOutOfBoundsException</code> 数组索引越界异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(array[<span class="number">10</span>]);<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.NullPointerException  </code>空指针异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当应用程序试图在需要对象的地方使用null时，抛出该异常。这种情况包括：调用 null 对象的实例方法、访问或修改null对象的字段、将null作为一个数组，获得其长度、将null作为一个数组，访问或修改其时间片、将null作为Throwable值抛出。*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(string.equals(<span class="literal">null</span>));<span class="comment">//报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.ClassCastException  </code>类型转换异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当试图将对象强制转换为不是实例的子类时，抛出该异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">//多态</span></span><br><span class="line">        <span class="type">Math</span> <span class="variable">math</span>  <span class="operator">=</span>  (Math) obj; <span class="comment">//编译不报错，但运行会报错</span></span><br><span class="line">        System.out.println(math);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.ArithmeticException</code> 算术异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span> / <span class="number">0</span>);<span class="comment">//除0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>java.lang.NumberFormatException</code> 数字格式异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">string2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(string1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> Integer.valueOf(string2);<span class="comment">//编译不报错</span></span><br><span class="line">        System.out.println(integer1);</span><br><span class="line">        System.out.println(integer2);<span class="comment">//运行报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-异常的处理"><a href="#4-异常的处理" class="headerlink" title="4. 异常的处理"></a>4. 异常的处理</h2><p>异常的处理分为两步：</p>
<p>第一步：<code>抛出异常</code>。程序在正常执行的过程中，如果出现异常，会在异常代码处生成一个对应异常类的对象，并将此对象抛出，其后的代码就不再执行。对于异常对象的产生分为两种：① 系统自动生成的异常对象  ② 手动的生成一个异常对象，并抛出（throw）</p>
<p>第二步：<code>捕获异常</code>。捕获异常分为两种：① try…catch…finally 代码块直接处理  ② 通过 throws 进行声明，让调用者去处理。</p>
<h3 id="（1）try…catch…finally"><a href="#（1）try…catch…finally" class="headerlink" title="（1）try…catch…finally"></a>（1）try…catch…finally</h3><p>通过 try…catch…finally 代码块可以对出现的异常进行指定方式的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">    try&#123;</span></span><br><span class="line"><span class="comment">        //可能发生异常的代码。</span></span><br><span class="line"><span class="comment">    &#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">        //对异常进行处理</span></span><br><span class="line"><span class="comment">    &#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    &#125;finally&#123;</span></span><br><span class="line"><span class="comment">        //一定要执行的代码</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果执行完try没有发生异常，则执行finally块和finally后面的代码（如果有的话），如果发生异常，则尝试去匹配catch块。</span></span><br><span class="line"><span class="comment">	② 每一个catch块用于捕获并处理一个特定的异常，或者此异常类型的子类。</span></span><br><span class="line"><span class="comment">	③ catch中的异常类型如果有子父类关系，则要求子类一定声明在父类的上面。否则，报错。</span></span><br><span class="line"><span class="comment">	④ 在try结构中声明的变量，再出了try结构以后，就不能再被调用</span></span><br><span class="line"><span class="comment">	⑤ finally块通常是可选的。</span></span><br><span class="line"><span class="comment">	⑥ 无论异常是否发生，异常是否匹配被处理，finally都会执行。</span></span><br><span class="line"><span class="comment">	⑦ finally主要做一些清理工作，如流的关闭，数据库连接的关闭等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a / b;</span><br><span class="line">            System.out.println(<span class="string">&quot;两个数相除的结果为：&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一条一定会执行的语句&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;这是一条测试语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入被除数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">请输入除数：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at innerclass.Main.main(Main.java:<span class="number">17</span>)</span><br><span class="line">这是一条一定会执行的语句</span><br><span class="line">这是一条测试语句</span><br><span class="line"><span class="comment">//如果没有try...catch...finally代码块处理异常，那么测试语句则不会输出。</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）throws"><a href="#（2）throws" class="headerlink" title="（2）throws"></a>（2）throws</h3><p>如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常或者由调用者处理更好，则此方法应显示地通过 throws 关键字声明抛出异常，表明该方法本身将不对这些异常进行处理，而由该方法的调用者负责处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;</span></span><br><span class="line"><span class="comment">    	代码体;</span></span><br><span class="line"><span class="comment">    &#125;	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入被除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入除数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//调用者自己处理异常</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> divide(a, b);</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相除的结果为：&quot;</span> + result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一条测试语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">throws</span> ArithmeticException &#123; <span class="comment">//自己进行处理，而是声明交给调用者处理</span></span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入被除数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">请输入除数：</span><br><span class="line"><span class="number">0</span></span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">	at innerclass.Main.divide(Main.java:<span class="number">26</span>)</span><br><span class="line">	at innerclass.Main.main(Main.java:<span class="number">17</span>)</span><br><span class="line">这是一条测试语句</span><br></pre></td></tr></table></figure>

<h3 id="（3）throw"><a href="#（3）throw" class="headerlink" title="（3）throw"></a>（3）throw</h3><p>Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要使用人工创建并抛出 ，即通过 throw 语句手动显式的抛出一个异常。throw 语句的后面必须是一个异常对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用步骤：</span></span><br><span class="line"><span class="comment">	① 异常类名 对象名 = new 异常类名(参数); // 创建一个异常对象。封装一些提示信息(信息可自行编写)。</span></span><br><span class="line"><span class="comment">	  如：ArrayIndexOutOfBoundsException  e  = new ArrayIndexOutOfBoundsException(数组索引越界了！);</span></span><br><span class="line"><span class="comment">	② throw 对象名; // 在方法内使用关键字throw，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</span></span><br><span class="line"><span class="comment">	  如：throw e;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 注意：上述两步可以通过使用匿名对象合二为一，格式为：throw new 异常类名(参数);</span></span><br><span class="line"><span class="comment">	  如：throw new ArrayIndexOutOfBoundsException(数组索引越界了！);</span></span><br><span class="line"><span class="comment">	② throw 仅仅是将异常进行抛出，返回给该方法的调用者并没有进行处理，对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrays = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> value(arrays,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">value</span><span class="params">(<span class="type">int</span>[] arrays ,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">0</span> || num &gt;= arrays.length)&#123; <span class="comment">//此时不能返回一个整数，可以考虑抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;数组角标越界了！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> arrays[num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw 和 throws 的区别：</p>
<p>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。<br>throws 属于异常处理的一种方式，声明在方法的声明处。</p>
<h2 id="5-自定义异常类"><a href="#5-自定义异常类" class="headerlink" title="5. 自定义异常类"></a>5. 自定义异常类</h2><p>在开发中根据自己业务的异常情况来自定义异常类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义步骤：</span></span><br><span class="line"><span class="comment">  ① 继承于现的异常结构：RuntimeException 、Exception</span></span><br><span class="line"><span class="comment">  ③ 提供重载的构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 计算一个圆的面积，并自定义一个异常类 RediusException，当输入半径小于0时，抛出异常信息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RediusException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RediusException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RediusException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入圆的半径：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">redius</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (redius &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RediusException</span>(<span class="string">&quot;圆的半径不能小于0！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;圆的面积为：&quot;</span> + Math.PI * redius * redius);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(RediusException r)&#123;</span><br><span class="line">            r.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">控制台信息如下：</span><br><span class="line">请输入圆的半径：</span><br><span class="line">-<span class="number">5</span></span><br><span class="line">commonexception.RediusException: 圆的半径不能小于<span class="number">0</span>！</span><br><span class="line">	at first.Main.main(Main.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h1 id="七-多线程"><a href="#七-多线程" class="headerlink" title="七. 多线程"></a>七. 多线程</h1><h2 id="1-程序、进程与线程"><a href="#1-程序、进程与线程" class="headerlink" title="1. 程序、进程与线程"></a>1. 程序、进程与线程</h2><blockquote>
<p><code>程序</code>：一组计算机能识别和执行的指令，运行于电子计算机上，满足人们某种需求的信息化工具。即一段静态的代码。</p>
<p><code>进程</code>：一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。进程是系统进行资源分配和调度的基本单位，</p>
<p><code>线程</code>：进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。线程是程序执行的最小单位。</p>
</blockquote>
<h2 id="2-多线程的创建"><a href="#2-多线程的创建" class="headerlink" title="2. 多线程的创建"></a>2. 多线程的创建</h2><ul>
<li><p>方式一：继承 Thread 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 创建一个继承于Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</span></span><br><span class="line"><span class="comment">	② 创建Thread子类的对象。</span></span><br><span class="line"><span class="comment">	③ 调用子类对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 启动一个线程，必须调用start()，不能调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">	② 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出异常“IllegalThreadStateException”。</span></span><br><span class="line"><span class="comment">	③ 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().</span></span><br><span class="line"><span class="comment">★Thread类的构造方法：</span></span><br><span class="line"><span class="comment">	Thread() :分配一个新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(String name) :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(Runnable target) :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="comment">	Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</span></span><br><span class="line"><span class="comment">★Thread类的常用方法：</span></span><br><span class="line"><span class="comment">	String getName() :获取当前线程名称。</span></span><br><span class="line"><span class="comment">	void setName(String name) :改变线程名称，使之与参数 name 相同 </span></span><br><span class="line"><span class="comment">	void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</span></span><br><span class="line"><span class="comment">	void run() :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="comment">	void join() :等待该线程终止。（在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态） </span></span><br><span class="line"><span class="comment">	static void yield() :暂停当前正在执行的线程对象，并执行其他线程（释放当前CPU的执行权）。 </span></span><br><span class="line"><span class="comment">	static void sleep(long millis) :在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。</span></span><br><span class="line"><span class="comment">	static Thread currentThread() :返回对当前正在执行的线程对象的引用。	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">// 第一步：创建一个继承于Thread类的子类，并重写该类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()  + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>(); <span class="comment">// 第二步：创建Thread子类对象</span></span><br><span class="line">        m1.start(); <span class="comment">// 第三步：启动分线程</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：实现 Runnable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span></span><br><span class="line"><span class="comment">	② 创建Runnable实现类的对象。	</span></span><br><span class="line"><span class="comment">	③ 将实现类对象作为Thread类构造方法的参数，创建Thread对象，该Thread对象才是真正的线程对象。</span></span><br><span class="line"><span class="comment">	④ 调用Thread对象的start()方法来启动线程。</span></span><br><span class="line"><span class="comment">注意：在开发中，相较于方式一，优先选择实现Runable接口的方式，因为可以实现“多继承”。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; <span class="comment">// 第一步：定义Runnable接口的实现类，并重写该接口的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">m2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();<span class="comment">// 第二步：创建Runnable实现类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(m2); <span class="comment">// 第三步：创建Thread类的对象，构造方法参数为Runnable实现类对象</span></span><br><span class="line">        thread.start(); <span class="comment">// 第四步：通过start()方法启动线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：实现 Callable 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	① 创建Callable接口的实现类 ，并实现Call方法。</span></span><br><span class="line"><span class="comment">	② 创建Callable实现类的对象。</span></span><br><span class="line"><span class="comment">	③ 将Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line"><span class="comment">	④ 将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象。</span></span><br><span class="line"><span class="comment">	⑤ 调用Thread对象的start()方法来启动线程。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① call()方法是有返回值的，可以通过FutureTask的get()方法获取返回值。</span></span><br><span class="line"><span class="comment">	② call()可以抛出异常，被外面的操作捕获，获取异常的信息</span></span><br><span class="line"><span class="comment">	③ Callable是支持泛型的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123; <span class="comment">// 第一步：创建Callable接口的实现类 ，并实现Call方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 注意有返回值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread3</span> <span class="variable">m3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>(); <span class="comment">// 第二步：创建Callable实现类的对象。</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(m3);<span class="comment">// 第三步：创建FutureTask的对象，Callable实现类的对象为参数</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);<span class="comment">// 第四步：创建Thread类的对象，FutureTask类的对象为参数</span></span><br><span class="line">        thread.start();<span class="comment">// 第五步：通过start()方法启动线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get()); <span class="comment">// 获取call()方法的返回值</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式四：线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">概念：一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</span></span><br><span class="line"><span class="comment">好处：</span></span><br><span class="line"><span class="comment">	① 降低资源消耗。（减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务）</span></span><br><span class="line"><span class="comment">	② 提高响应速度。（当任务到达时，任务可以不需要等到线程创建就能立即执行）</span></span><br><span class="line"><span class="comment">	③ 提高线程的可管理性。（可以调整线程池中工作线线程的数目，防止内存消耗过多而出现故障）</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">	1. 创建线程池对象。（提供指定线程数量的线程池）</span></span><br><span class="line"><span class="comment">	2. 创建 Runnable 接口子类对象。</span></span><br><span class="line"><span class="comment">	3. 提交 Runnable 接口子类对象。</span></span><br><span class="line"><span class="comment">	4. 关闭线程池。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread4</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);<span class="comment">//创建线程池对象</span></span><br><span class="line">	<span class="type">MyThread4</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread4</span>();<span class="comment">//创建Runnable接口子类对象。</span></span><br><span class="line">	service.submit(r);<span class="comment">//提交Runnable接口子类对象。</span></span><br><span class="line">	service.submit(r);</span><br><span class="line">    service.shutdown();<span class="comment">//关闭线程池。</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h2><p>一个线程的生命周期包含 5 个状态：新建、就绪、运行、阻塞、死亡。</p>
<ul>
<li><p><code>新建（New）</code>：当线程对象对创建后（new），即进入了新建状态。</p>
</li>
<li><p><code>就绪（Runnable）</code>：当调用线程对象的 start() 方法后，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说此线程立即就会执行；</p>
</li>
<li><p><code>运行（Running）</code>：当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注意：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
<li><p><code>阻塞（Blocked）</code>：处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：</p>
<p>1.等待阻塞：运行状态中的线程执行 wait() 方法，使本线程进入到等待阻塞状态；</p>
<p>2.同步阻塞 – 线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</p>
<p>3.其他阻塞 – 通过调用线程的 sleep() 或 join() 或发出了 I&#x2F;O 请求时，线程会进入到阻塞状态。当 sleep() 状态超时、join() 等待线程终止或者超时、或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</p>
</li>
<li><p><code>死亡（Dead）</code>：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162603.png" style="zoom:80%;" /></li>
</ul>
<h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4. 线程的同步"></a>4. 线程的同步</h2><p>当多个线程共同操作同一块共享数据时，很有可能引发线程安全问题，从而造成数据异常。（一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。）</p>
<p><u>&#x2F;&#x2F; 经典案例：三个窗口共同卖10张票。</u></p>
<p>可能出现两个问题：</p>
<ul>
<li>三个窗口卖出同一张票（比如都卖出了第10号票） </li>
<li>卖出不应该存在的票（比如出现了第-1票）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                tickets--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">3</span>：卖第<span class="number">1</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第-<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>

<p>解决此类问题的思路：<u>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行</u>。但是由于操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率比较低。</p>
<p>实现线程同步的方式：</p>
<ul>
<li><p>方式一：同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步代码块：在方法中的某个区块中使用synchronized关键字，表示只对这个区块的资源实行互斥访问。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	synchronized(同步锁)&#123; </span></span><br><span class="line"><span class="comment">		//需要同步操作的代码 </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 任意对象都可以作为同步锁，但是多个线程要使用同一把锁【重要】。</span></span><br><span class="line"><span class="comment">	② 在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)，当线程执行完对应代码块/代码块发生异常后自动释放锁。</span></span><br><span class="line"><span class="comment">	③ 同步代码块的锁除了自己指定外，很多时候也可以指定为this或类名.class</span></span><br><span class="line"><span class="comment">	④ 在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span></span><br><span class="line"><span class="comment">	⑤ 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。	</span></span><br><span class="line"><span class="comment">	⑥ 需要同步操作的代码范围不能太大，也不能太小。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">2</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同步方法:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public synchronized void method()&#123; </span></span><br><span class="line"><span class="comment">		//可能会产生线程安全问题的代码 </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 对于非static方法,此时的同步锁就是this。</span></span><br><span class="line"><span class="comment">	② 对于static方法,此时的同步锁是方法所在类的字节码对象(类名.class)。</span></span><br><span class="line"><span class="comment">	③ 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sell();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123; <span class="comment">// 同步方法</span></span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：Lock 锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lock锁机制：通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	//类中</span></span><br><span class="line"><span class="comment">		Lock 对象名 = new ReentrantLock();//创建对象</span></span><br><span class="line"><span class="comment">	//run方法中</span></span><br><span class="line"><span class="comment">		对象名.lock();//加同步锁</span></span><br><span class="line"><span class="comment">		try&#123;</span></span><br><span class="line"><span class="comment">			//同步代码块</span></span><br><span class="line"><span class="comment">		&#125;catch(异常类型 e)&#123;</span></span><br><span class="line"><span class="comment">			//异常处理</span></span><br><span class="line"><span class="comment">		&#125;finally&#123;</span></span><br><span class="line"><span class="comment">			对象名.unlock();//释放同步锁</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① Lock实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，优先使用Lock锁。</span></span><br><span class="line"><span class="comment">	② java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</span></span><br><span class="line"><span class="comment">	③ ReentrantLock类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</span></span><br><span class="line"><span class="comment">	④ 锁定和取消锁定出现在不同作用范围中时，最好用try-【catch】-finally 加以保护，以确保在必要时释放锁。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTickets</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock();<span class="comment">// 加同步锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="comment">// 为了更明显的突出线程安全问题，使用sleep()让线程执行慢一些</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +<span class="string">&quot;：卖第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();<span class="comment">// 释放同步锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTickets</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口1&quot;</span>); <span class="comment">// 新建线程1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口2&quot;</span>); <span class="comment">// 新建线程2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(s,<span class="string">&quot;窗口3&quot;</span>); <span class="comment">// 新建线程3</span></span><br><span class="line">        t1.start(); <span class="comment">// 启动线程1</span></span><br><span class="line">        t2.start(); <span class="comment">// 启动线程2</span></span><br><span class="line">        t3.start(); <span class="comment">// 启动线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下（每次结果都可能不同）：</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">10</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">9</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">8</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">7</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">6</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">5</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">4</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">3</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">2</span>张票</span><br><span class="line">窗口<span class="number">1</span>：卖第<span class="number">1</span>张票</span><br></pre></td></tr></table></figure></li>
</ul>
<p>★ Synchronized 和 Lock 的对比：</p>
<ul>
<li>Lock 是显式锁（手动开启和关闭锁），synchronized 是隐式锁，出了作用域自动释放锁。</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ul>
<h2 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5. 线程的通信"></a>5. 线程的通信</h2><blockquote>
<p>多个线程在处理同一个资源时，处理的动作（线程的任务）不相同，线程之间进行通信用来保证线程协调运行，比如控制线程执行先后顺序、获取某个线程执行的结果等</p>
</blockquote>
<p><u>等待唤醒机制</u>：在一个线程进行了规定操作后，就进入等待状态， 等待其他线程执行完他们的指定代码过后 再将其唤醒。</p>
<ul>
<li><p><code>wait()</code>：令当前线程挂起，放弃CPU同步资源并等待（此时不会去竞争锁了，处于阻塞状态），使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用 notify() 或 notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。</p>
</li>
<li><p><code>notify()</code>：唤醒正在排队等待同步资源的线程，如果有多个会任意选择一个唤醒。</p>
</li>
<li><p><code>notifyAll ()</code>：唤醒正在排队等待资源的所有线程结束等待。</p>
</li>
</ul>
<p>注意：</p>
<p>​    ① wait 方法与 notify 方法必须由同一个锁对象调用。只有对应的锁对象可以通过 notify 唤醒使用同一个锁对象调用 wait 方法后的线程。</p>
<p>​    ② wait 方法与 notify 方法是属于 Object 类的方法的。</p>
<p>​    ③ wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用，否则会报异常。因为：必须要通过锁对象调用这2个方法。</p>
<p><u>&#x2F;&#x2F; 经典案例：生产者消费者问题（Producer-consumer problem）</u></p>
<blockquote>
<p>生产者负责生产产品，而消费者负责消费产品。两个线程同时运行，要求产品的个数要大于0个，并小于10个。<br>如果产品个数为0，那么消费者需要等待生产者进行生产（只要生产了1个，消费者就可以继续进行消费）。<br>如果产品个数为10，那么生产者需要等待消费者进行消费（只要消费了1个，生产者就可以继续进行生产）。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Amount</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123; <span class="comment">// 进行消费</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();  <span class="comment">// 如果数量小于等于0时，消费者就进行等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:消费第&quot;</span> + num +<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            num --;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">producer</span><span class="params">()</span>  &#123; <span class="comment">// 进行生产</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();  <span class="comment">// 如果数量大于等于10时，生产者就进行等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num ++;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:生产第&quot;</span> + num +<span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">    Amount amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Amount amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            amount.producer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123; </span><br><span class="line">    Amount amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Amount amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.currentThread().yield();</span><br><span class="line">            amount.consumer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Amount</span> <span class="variable">amount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Amount</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(amount);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(amount);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(c,<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★sleep() 和 wait()的异同</p>
<p>相同点：一旦执行，都可以使得当前的线程进入阻塞状态。</p>
<p>不同点：</p>
<p>​    1）两个方法声明的位置不同：Thread 类中声明 sleep() , Object 类中声明 wait()</p>
<p>​    2）调用的要求不同：sleep() 可以在任何需要的场景下调用。 wait() 必须使用在同步代码块或同步方法中</p>
<p>​    3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放锁，wait() 会释放锁。</p>
<h1 id="八-枚举"><a href="#八-枚举" class="headerlink" title="八. 枚举"></a>八. 枚举</h1><h2 id="1-自定义枚举类"><a href="#1-自定义枚举类" class="headerlink" title="1. 自定义枚举类"></a>1. 自定义枚举类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">class Season&#123;</span></span><br><span class="line"><span class="comment">    // 1.声明Season对象的属性：private final修饰</span></span><br><span class="line"><span class="comment">    private final String seasonName;</span></span><br><span class="line"><span class="comment">    private final String seasonDesc;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"><span class="comment">    private Season(String seasonName,String seasonDesc)&#123;</span></span><br><span class="line"><span class="comment">        this.seasonName = seasonName;</span></span><br><span class="line"><span class="comment">        this.seasonDesc = seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line"><span class="comment">    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);</span></span><br><span class="line"><span class="comment">    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冰天雪地&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line"><span class="comment">    public String getSeasonName() &#123;</span></span><br><span class="line"><span class="comment">        return seasonName;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getSeasonDesc() &#123;</span></span><br><span class="line"><span class="comment">        return seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    // 4.其他诉求2：提供toString()</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public String toString() &#123;</span></span><br><span class="line"><span class="comment">        return &quot;Season&#123;&quot; +</span></span><br><span class="line"><span class="comment">                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意:	</span></span><br><span class="line"><span class="comment">	① 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰；</span></span><br><span class="line"><span class="comment">	② 枚举类的使用 private final 修饰的属性应该在构造器中为其赋值；</span></span><br><span class="line"><span class="comment">	③ 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数；</span></span><br><span class="line"><span class="comment">	④ 如果枚举类中只一个对象，则可以作为单例模式的实现方式；</span></span><br><span class="line"><span class="comment">	⑤ 私有化类的构造器，保证不能在类的外部创建其对象。  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-enum关键字"><a href="#2-enum关键字" class="headerlink" title="2. enum关键字"></a>2. enum关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">步骤：</span></span><br><span class="line"><span class="comment">enum Season1 &#123;</span></span><br><span class="line"><span class="comment">    // 1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line"><span class="comment">    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;),</span></span><br><span class="line"><span class="comment">    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;),</span></span><br><span class="line"><span class="comment">    AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;),</span></span><br><span class="line"><span class="comment">    WINTER(&quot;冬天&quot;,&quot;冰天雪地&quot;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 2.声明Season对象的属性：private final修饰</span></span><br><span class="line"><span class="comment">    private final String seasonName;</span></span><br><span class="line"><span class="comment">    private final String seasonDesc;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 3.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    private Season1(String seasonName,String seasonDesc)&#123;</span></span><br><span class="line"><span class="comment">        this.seasonName = seasonName;</span></span><br><span class="line"><span class="comment">        this.seasonDesc = seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line"><span class="comment">    public String getSeasonName() &#123;</span></span><br><span class="line"><span class="comment">        return seasonName;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public String getSeasonDesc() &#123;</span></span><br><span class="line"><span class="comment">        return seasonDesc;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类</span></span><br><span class="line"><span class="comment">	② 枚举类的构造器只能使用 private 权限修饰符</span></span><br><span class="line"><span class="comment">	③ 枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的实例系统会自动添加 public static final 修饰</span></span><br><span class="line"><span class="comment">	④ 必须在枚举类的第一行声明枚举类对象</span></span><br><span class="line"><span class="comment">	⑤ 枚举类是线程安全的</span></span><br><span class="line"><span class="comment">	⑥ 每个枚举成员实际上是一个枚举实例。 </span></span><br><span class="line"><span class="comment">Enum类的主要方法：</span></span><br><span class="line"><span class="comment">	① values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</span></span><br><span class="line"><span class="comment">	② valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span></span><br><span class="line"><span class="comment">	③ toString()：返回当前枚举类对象常量的名称</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="九-注解"><a href="#九-注解" class="headerlink" title="九. 注解"></a>九. 注解</h1><blockquote>
<p><code>Annotation</code> 其实就是代码里的特殊标记，这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。注解类同于标签，标签为了解释事物，注解为了解释代码。(如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重要的部分就是，创建与使用注解处理器。Java 拓展了反射机制的 API 用于帮助你创造这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。)</p>
</blockquote>
<h2 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注解和class、interface一样也是一种类型，通过 @interface 关键字进行定义。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	public @interface 注解名&#123;</span></span><br><span class="line"><span class="comment">		成员变量；</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 自定义注解自动继承了java.lang.annotation.Annotation</span></span><br><span class="line"><span class="comment">	② 注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。如：int id();</span></span><br><span class="line"><span class="comment">	③ 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字</span></span><br><span class="line"><span class="comment">	④ 如果注解有成员，在使用注解时，需要指明成员的值。除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=”。</span></span><br><span class="line"><span class="comment">	⑤ 【重要】自定义注解必须配上注解的信息处理流程(使用反射)才意义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Java-预置的注解"><a href="#2-Java-预置的注解" class="headerlink" title="2. Java 预置的注解"></a>2. Java 预置的注解</h2><p><code>@Override</code>:：限定重写父类方法, 该注解只能用于方法<br><code>@Deprecated</code>： 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择<br><code>@SuppressWarnings</code>： 抑制编译器警告</p>
<h2 id="3-元注解"><a href="#3-元注解" class="headerlink" title="3. 元注解"></a>3. 元注解</h2><p>元注解可以理解为注解的注解。有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。</p>
<p><code>@Retention </code>当 @Retention 应用到一个注解上的时候，它指定了所修饰的 Annotation 的生命周期，默认为CLASS。取值如下：</p>
<ul>
<li>RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</li>
<li>RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。</li>
<li>RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</li>
</ul>
<p>对于自定义注解，如果只存着源码中或者字节码文件中就无法发挥作用，而在运行期间能获取到注解才能实现目的，所以自定义注解中肯定是使用 **@Retention(RetentionPolicy.RUNTIME)**。</p>
<p><code>@Documented</code> 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。</p>
<p><code>@Target</code> 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。取值如下：</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
<p><code>@Inherited  </code>  如果父类被 @Inherited 注解过的注解进行了注解，那么当其子类没有被任何注解应用，这个子类就继承了超类的注解。 </p>
<p><code>@Repeatable</code> 被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。</p>
<h1 id="十-集合"><a href="#十-集合" class="headerlink" title="十. 集合"></a>十. 集合</h1><h2 id="1-集合概述"><a href="#1-集合概述" class="headerlink" title="1. 集合概述"></a>1. 集合概述</h2><blockquote>
<p><strong>集合</strong>：java 中提供的一种容器，可以用来存储多个数据，所有集合类都位于 java.util 包下。</p>
</blockquote>
<p>集合和数组的区别：</p>
<ul>
<li>数组的长度不可变，而集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
<li>数组进行插入和删除操作较为麻烦，而集合很方便。</li>
</ul>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code></p>
<p><code>Collection</code> 接口：单列数据，定义了存取一组对象的方法的集合，它有两个重要的子接口：</p>
<ul>
<li>List：元素有序且可重复的集合，主要实现类有 <strong>ArrayList</strong>  、<strong>LinkedList</strong> 和 Vector 。</li>
<li>Set： 元素无序且不可重复的集合，主要实现类有 <strong>HashSet</strong> 、LinkedHashSet 和 TreeSet  。</li>
</ul>
<p><code>Map</code> 接口：双列数据，保存具有映射关系“key-value”的集合，主要实现类有 <strong>HashMap</strong>，LinkedHashMap，TreeMap。</p>
<img src="https://cdn.jsdelivr.net/gh/SniperCoding/images_one/Java基础/20220324162634.PNG" style="zoom: 60%;" />

<h2 id="2-Collection-接口"><a href="#2-Collection-接口" class="headerlink" title="2. Collection 接口"></a>2. Collection 接口</h2><ul>
<li><p>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。</p>
</li>
<li><p>JDK 不提供 Collection 接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</p>
</li>
<li><p>Collection 是所有单列集合的父接口，因此在 Collection 中定义了单列集合( List 和 Set )通用的一些方法，这些方法可用于操作所有的单列集合，常用方法如下：</p>
<ul>
<li><p><code> boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</p>
</li>
<li><p><code>boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定  collection 中的所有元素都添加到此 collection 中）。</p>
</li>
<li><p><code>void clear()</code> :清空集合中所有的元素。</p>
</li>
<li><p><code>boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</p>
</li>
<li><p><code>boolean removeAll(Collection&lt;?&gt; c)</code> ：移除此 collection 中那些也包含在指定 collection 中的所有元素（差集）。</p>
</li>
<li><p><code>boolean contains(E e)</code>: 通过元素的 equals 方法判断当前集合中是否包含给定的对象。</p>
</li>
<li><p><code>boolean isEmpty()</code>: 判断当前集合是否为空。</p>
</li>
<li><p><code>int size()</code>: 返回集合中有效元素的个数。</p>
</li>
<li><p><code>Object[] toArray()</code>: 把集合中的元素，存储到数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(collection); <span class="comment">//[aaa, bbb, ccc]</span></span><br><span class="line">        <span class="comment">//删</span></span><br><span class="line">        collection.remove(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        System.out.println(collection);<span class="comment">//[aaa, ccc]</span></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        System.out.println(collection.size());<span class="comment">//2</span></span><br><span class="line">        <span class="comment">//清空</span></span><br><span class="line">        collection.clear();</span><br><span class="line">        System.out.println(collection);<span class="comment">//[]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Collection 集合的遍历</p>
<ul>
<li><p>方式一：Iterator 迭代器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	① Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。</span></span><br><span class="line"><span class="comment">	② Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</span></span><br><span class="line"><span class="comment">	③ Iterator仅用于遍历集合，本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</span></span><br><span class="line"><span class="comment">	④ 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line"><span class="comment">	⑤ 迭代：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></span><br><span class="line"><span class="comment">	⑥ Iterator接口的常用方法如下：</span></span><br><span class="line"><span class="comment">		public E next():返回迭代的下一个元素。</span></span><br><span class="line"><span class="comment">		public boolean hasNext():如果仍有元素可以迭代，则返回 true。</span></span><br><span class="line"><span class="comment">		注意：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，则会发生异常。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	Iterator 对象名 = 集合名.iterator(); </span></span><br><span class="line"><span class="comment">	while(对象名.hasnext())&#123;  </span></span><br><span class="line"><span class="comment">		System.out.println(iterator.next()); </span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//使用多态方式 创建对象</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 添加元素到集合</span></span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator(); <span class="comment">//创建迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">            System.out.println(iterator.next()); <span class="comment">//输出迭代出的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：增强 for 循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">	① 增强for循环(也称for each循环)是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</span></span><br><span class="line"><span class="comment">	② 遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</span></span><br><span class="line"><span class="comment">格式：</span></span><br><span class="line"><span class="comment">	for(元素的数据类型  变量名 : Collection集合or数组)&#123; </span></span><br><span class="line"><span class="comment">  		System.out.println(变量名);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//使用多态方式 创建对象</span></span><br><span class="line">        collection.add(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 添加元素到集合</span></span><br><span class="line">        collection.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        collection.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object obj : collection)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-List-接口"><a href="#3-List-接口" class="headerlink" title="3. List 接口"></a>3. List 接口</h2><h3 id="（1）List-接口概述"><a href="#（1）List-接口概述" class="headerlink" title="（1）List 接口概述"></a>（1）List 接口概述</h3><blockquote>
<p>List 接口继承自 Collection 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为 List 集合。List 作为 Collection集合的子接口，不但继承了 Collection 接口中的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法。</p>
</blockquote>
<p>List接口特点：</p>
<ul>
<li>元素存取有序。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>带有索引，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的 equals 方法，来比较是否为重复的元素。</li>
</ul>
<h3 id="（2）List-接口常用方法"><a href="#（2）List-接口常用方法" class="headerlink" title="（2）List 接口常用方法"></a>（2）List 接口常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>： 向列表的尾部添加指定的元素。</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span>:  在列表的指定位置插入指定元素</span><br><span class="line">删：</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>: 从此列表中移除第一次出现的指定元素（如果存在）</span><br><span class="line">	E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span><br><span class="line">改：</span><br><span class="line">	E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span><br><span class="line">查：</span><br><span class="line">    E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>:返回集合中指定位置的元素。</span><br><span class="line">长度：</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中有效元素的个数。</span><br><span class="line">遍历：</span><br><span class="line">	① Iterator迭代器方式</span><br><span class="line">	② 增强<span class="keyword">for</span>循环</span><br><span class="line">	③ 普通的循环</span><br></pre></td></tr></table></figure>

<h3 id="（3）List接口实现类"><a href="#（3）List接口实现类" class="headerlink" title="（3）List接口实现类"></a>（3）List接口实现类</h3><ul>
<li><p><code>ArrayList</code>：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 Object[] elementData 存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ArrayList类的功能：用于实现长度可变的数组。</span></span><br><span class="line"><span class="comment">ArrayList类的使用：</span></span><br><span class="line"><span class="comment">	①导包</span></span><br><span class="line"><span class="comment">		import java.util.ArrayList;</span></span><br><span class="line"><span class="comment">	②创建</span></span><br><span class="line"><span class="comment">		ArrayList&lt;引用数据类型&gt; 对象名 = new ArrayList&lt;&gt;();//构造一个初始容量为10的空列表。</span></span><br><span class="line"><span class="comment">		ArrayList&lt;引用数据类型&gt; 对象名 = new ArrayList&lt;&gt;(int initialCapacity);//构造有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">	③使用</span></span><br><span class="line"><span class="comment">    	增删改查长度遍历</span></span><br><span class="line"><span class="comment">ArrayList类的注意事项：</span></span><br><span class="line"><span class="comment">	①对于ArrayList来说，有一个尖括号&lt;E&gt;代表泛型，E取自Element（元素）的首字母。使用一种引用数据类型将E其替换即可。</span></span><br><span class="line"><span class="comment">	②泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。（泛型只能是引用类型，不能是基本类型。）</span></span><br><span class="line"><span class="comment">	③对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。如果内容是空，得到的是空的中括号：[]</span></span><br><span class="line"><span class="comment">	④对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用。但是对于其他集合来说，add添加动作不一定成功。</span></span><br><span class="line"><span class="comment">	⑤如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。</span></span><br><span class="line"><span class="comment">	⑥ArrayList元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//示例：生成3个范围为[1,10]的随机数字，添加到ArrayList集合中，并遍历输出。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;集合中的元素为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.print(list.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinkedList</code>：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高；底层使用双向链表存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增方法：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span><br><span class="line">E <span class="title function_">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span><br><span class="line">E <span class="title function_">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。 </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Vector</code>：作为 List 接口的古老实现类；线程安全的，效率低；底层使用 Object[] elementData 存储</p>
<p>与 ArrayList 相似，但是 Vector 是同步的。所以说 Vector 是线程安全的动态数组。它的操作与 ArrayList 几乎一样。</p>
</li>
</ul>
<p> ★ ArrayList 和 LinkedList 的异同</p>
<p>二者都线程不安全，相对线程安全的 Vector，执行效率高。此外，ArrayList 是实现了基于动态数组的数据结构。LinkedList 基于链表的数据结构。对于随机访问 get 和 set，ArrayList 优于 LinkedList，因为 LinkedList 要移动针。对于新增和删除操作 add(特指插入)和 remove，LinkedList 比较占优势，因为 ArrayList 要移动数据。</p>
<h2 id="4-Set-接口"><a href="#4-Set-接口" class="headerlink" title="4. Set 接口"></a>4. Set 接口</h2><h3 id="（1）Set-接口概述"><a href="#（1）Set-接口概述" class="headerlink" title="（1）Set 接口概述"></a>（1）Set 接口概述</h3><blockquote>
<p>Set 接口和 List 接口一样，同样继承自 Collection 接口，它与 Collection 接口中的方法基本一致，并没有对Collection 接口进行功能上的扩充，只是比 Collection 接口更加严格了。与 List 接口不同的是，Set 接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
</blockquote>
<p>Set 接口特点：</p>
<ul>
<li>元素存取无序。不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是<strong>根据数据的哈希值决定的。</strong></li>
<li>集合中不可以有重复的元素。<strong>保证添加的元素照 equals() 判断时，不能返回 true。</strong></li>
</ul>
<h3 id="（2）Set接口实现类"><a href="#（2）Set接口实现类" class="headerlink" title="（2）Set接口实现类"></a>（2）Set接口实现类</h3><ul>
<li><p><code>HashSet</code>：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值。</p>
<ul>
<li><p>java.util.HashSet 底层的实现其实是一个 java.util.HashMap 支持。</p>
</li>
<li><p>HashSet 是<strong>根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能</strong>。保证元素唯一性的方式依赖于：<u>hashCode与equals方法。两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。</u></p>
</li>
<li><p><strong>对于存放在 Set 容器中的对象，对应的类一定要重写 equals() 和 hashCode(Object obj) 方法，以实现对象相等规则。</strong></p>
</li>
<li><p><u>向HashSet中添加元素的过程</u></p>
<ol>
<li>当向 HashSet 集合中存入一个元素时，HashSet 会<strong>调用该对象的 hashCode()方法来得到该对象的hashCode 值，然后根据 hashCode 值，通过某种散列函数决定该对象在 HashSet 底层数组中的存储位置。</strong>（这个散列函数会与底层数组的长度相计算得到在数组中的下标，并且这种散列函数计算还尽可能保证能均匀存储元素，越是散列分布，该散列函数设计的越好）</li>
<li><strong>如果两个元素的 hashCode 值相等，会再继续调用 equals 方法，如果 equals 方法结果为 true，添加失败；如果为 false，那么会保存该元素，若该数组的位置已经有元素了，那么会通过链表的方式继续链接。</strong></li>
<li>如果两个元素的 equals() 方法返回 true，但它们的 hashCode() 返回值不相等，hashSet 将会把它们存储在不同的位置，但依然可以添加成功【因此当重写了 equals 后一定要重写 hashCode】。</li>
</ol>
</li>
<li><p><u>重写 hashCode() 方法的基本原则</u></p>
<ul>
<li>在程序运行时，同一个对象多次调用 hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的 equals() 方法比较返回 true 时，这两个对象的 hashCode()方法的返回值也应相等。</li>
<li>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
</li>
<li><p><u>重写 equals() 方法的基本原则</u></p>
<p> 当一个类有自己特有的“逻辑相等”概念，当改写 equals() 的时候，总是要改写 hashCode()，根据一个类的equals 方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据 Object.hashCode() 方法，它们仅仅是两个对象。因此，违反了“相等的对象必须具有相等的散列码”。 </p>
<p>结论：<strong>重写 equals 方法的时候一般都需要同时复写 hashCode方法</strong>。通常参与计算 hashCode 的对象的属性也应该参与到 equals() 中进行计算。</p>
</li>
<li><p><u>HashSet集合存储数据的结构（哈希表）</u></p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一 hash 值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过 key 值依次查找的效率较低。而 JDK1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  <span class="comment">//自定义学生类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写hashcode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        hashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj: hashSet)&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历结果为：<span class="comment">//不可重复，不按插入顺序输出</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;王二&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">20</span>&#125;   </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>LinkedHashSet</code>：作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历。</p>
<ul>
<li>LinkedHashSet 是 HashSet 的子类。</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的，在遍历时会按照插入顺序输出。</li>
<li>LinkedHashSet 插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet 不允许集合元素重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;  <span class="comment">//自定义学生类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= student.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写hashcode方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LinkedHashSet</span> <span class="variable">linkedHashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        linkedHashSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedHashSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遍历结果为：<span class="comment">//不可重复，按插入顺序输出</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">18</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;王二&#x27;</span>, age=<span class="number">24</span>&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TreeSet</code>：可以照添加对象的指定属性，进行排序。</p>
<ul>
<li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</li>
<li>TreeSet 底层使用 红黑树结构存储数据。</li>
<li>TreeSet 支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造 TreeSet时，若使用不带参数的构造函数，则 TreeSet 的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</li>
<li>注意 TreeSet 集合不是通过 hashcode 和 equals 函数来比较元素的。它是通过 compare 或者 comparaeTo 函数来判断元素是否相等。compare 函数通过判断两个对象的 id，相同的 id 判断为重复元素，不会被加入到集合中。</li>
<li>向 TreeSet 中添加的数据，要求是相同类的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自然排序：TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素的大小，然后将集合元素按升序(默认情况)排列。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;  <span class="comment">//先按照学生的age进行排序，如果age相同，再按照姓名自然排序</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; s.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; s.age)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(s.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定制排序，要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写toString方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123; <span class="comment">//先按学生的age排序，如果age相同，再按照姓名自然排序</span></span><br><span class="line">                    <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Student  &amp;&amp; o2 <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) o1;</span><br><span class="line">                        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) o2;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (s1.age &gt; s2.age)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s1.age &lt; s2.age)&#123;</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;比较类型错误！&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(comparator);  <span class="comment">//定制排序</span></span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">24</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wanger&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;  <span class="comment">//遍历</span></span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;wanger&#x27;</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;lisi&#x27;</span>, age=<span class="number">24</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;zhangsan&#x27;</span>, age=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-Map-接口"><a href="#5-Map-接口" class="headerlink" title="5. Map 接口"></a>5. Map 接口</h2><h3 id="（1）Map-接口概述"><a href="#（1）Map-接口概述" class="headerlink" title="（1）Map 接口概述"></a>（1）Map 接口概述</h3><p> Map 与 Collection 并列存在。用于保存具有映射关系的数据：key-value。</p>
<p>List 接口特点：</p>
<ul>
<li>key 和 value 都可以是任何引用类型的数据</li>
<li>key 用 Set 来存放， 不允许重复，即<strong>同一个 Map 对象所对应的类，必须重写hashCode()和equals()方法</strong>。</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</li>
</ul>
<h3 id="（2）Map接口常用方法"><a href="#（2）Map接口常用方法" class="headerlink" title="（2）Map接口常用方法"></a>（2）Map接口常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">增：</span><br><span class="line">	V <span class="title function_">put</span><span class="params">(K key, V value)</span>: 把指定的键与指定的值添加到Map集合中。  </span><br><span class="line">删：</span><br><span class="line">	V <span class="title function_">remove</span><span class="params">(Object key)</span>: 移除指定key的key-value对，并返回value(如果存在)</span><br><span class="line">改：</span><br><span class="line">	V <span class="title function_">put</span><span class="params">(K key, V value)</span>: 将指定key-value修改当前map对象中。</span><br><span class="line">查：</span><br><span class="line"> 	V <span class="title function_">get</span><span class="params">(Object key)</span>: 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回<span class="literal">null</span>, 并把指定的键值添加到集合中。 </span><br><span class="line">长度：</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回此映射中的键-值映射关系数。 。</span><br><span class="line">遍历：</span><br><span class="line">	Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>: 获取Map集合中所有的键，存储到Set集合中。</span><br><span class="line">	Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): 获取到Map集合中所有的键值对对象的集合(Set集合)。</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Map中存放的是两种对象，一种称为key(键)，一种称为value(值)，它们在在Map中是一一对应关系，这一对对象又称做Map中的一个Entry(项)。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</span></span><br><span class="line"><span class="comment">既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</span></span><br><span class="line"><span class="comment"> K getKey()：获取Entry对象中的键。</span></span><br><span class="line"><span class="comment"> V getValue()：获取Entry对象中的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 遍历方式一：KeySet() + get()    </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王二&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        Set&lt;String&gt; set = map.keySet(); <span class="comment">//获取所有的键</span></span><br><span class="line">        <span class="keyword">for</span> (String str: set)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key：&quot;</span> + str + <span class="string">&quot;,value：&quot;</span> + map.get(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">key：李四,value：<span class="number">80</span></span><br><span class="line">key：张三,value：<span class="number">90</span></span><br><span class="line">key：王二,value：<span class="number">90</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 遍历方式二：entrySet() + getkey() getValue()  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;张三&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">&quot;李四&quot;</span>,<span class="number">80</span>);</span><br><span class="line">        map.put(<span class="string">&quot;王二&quot;</span>,<span class="number">90</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry str: set)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;key：&quot;</span> + str.getKey() + <span class="string">&quot;,value：&quot;</span> + str.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果如下：</span><br><span class="line">key：李四,value：<span class="number">80</span></span><br><span class="line">key：张三,value：<span class="number">90</span></span><br><span class="line">key：王二,value：<span class="number">90</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）Map接口实现类"><a href="#（3）Map接口实现类" class="headerlink" title="（3）Map接口实现类"></a>（3）Map接口实现类</h3><ul>
<li><p><code>HashMap</code>：作为 Map 的主要实现类；线程不安全的，效率高；可以存储 null 的 key 和 value</p>
<ul>
<li><p>允许使用 null 键和 null 值，与 HashSet 一样，不保证映射的顺序。</p>
</li>
<li><p>所有的 key 构成的集合是 Set：无序的、不可重复的。所以，<u>key所在的类要重写：equals()和hashCode()</u>。</p>
</li>
<li><p>所有的 value 构成的集合是 Collection：无序的、可以重复的。所以，value 所在的类要重写：equals()。</p>
</li>
<li><p>一个 key-value 构成一个 entry，所有的 ntry构成的集合是 Set:无序的、不可重复的</p>
</li>
<li><p>HashMap 判断两个 key 相等的标准是：<u>两个 key 通过 equals() 方法返回 true，hashCode 值也相等。</u></p>
</li>
<li><p>HashMap 判断两个 value 相等的标准是：<u>两个 value 通过 equals() 方法返回 true。</u></p>
</li>
<li><p><u>HashMap 在 jdk7 中实现原理</u>：</p>
<ul>
<li><p>HashMap map &#x3D; new HashMap(); 在实例化以后，底层创建了长度是 16 的一维数组 Entry[] table</p>
</li>
<li><p>map.put(key1,value1); </p>
</li>
<li><p>首先：调用 key1 所在类的 <code>hashCode()</code> 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到</p>
<p>在Entry数组中的存放位置。</p>
<ul>
<li>如果此位置上的数据为空，此时的 key1-value1 添加成功。 【情况1】</li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在))，比较 key1和已经存在的一个或多个数据的哈希值：</li>
<li>如果key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功。【情况2】</li>
<li>如果key1 的哈希值和已经存在的某一个数据 (key2-value2) 的哈希值相同，继续比较：调用 key1 所在类 <code>equals(key2) </code>方法：<ul>
<li>如果equals() 返回false：此时key1-value1添加成功。【情况3】</li>
<li>如果equals() 返回 true：使用 value1 替换 value2。【情况】</li>
</ul>
</li>
</ul>
</li>
<li><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</p>
</li>
</ul>
</li>
<li><p><u>HashMap 在 jdk8 中相较于 jdk7 在底层实现方面的不同</u></p>
<ul>
<li>new HashMap(); 底层默认创建一个长度为16的数组</li>
<li>首次调用put()方法时，底层创建长度为16的数组，jdk8底层的数组是：Node[]，而非Entry[]</li>
<li>jdk7 底层结构：数组+链表。jdk8 中底层结构：<strong>数组+链表+红黑树</strong>。</li>
<li>形成链表时（jdk7：新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ul>
</li>
<li><p><u>HashMap底层典型属性的属性的说明</u></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</li>
<li>threshold：扩容的临界值，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</li>
<li>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</li>
<li>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</li>
</ul>
</li>
</ul>
</li>
<li><pre><code> `LinkedHashMap`：LinkedHashMap 是 HashMap 的子类。在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序，与 LinkedHashSet 类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致。
</code></pre>
</li>
<li><pre><code> `TreeMap`： 保证照添加的 key-value 对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树。
 
 - 自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException。
 - 定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现Comparable 接口。
 - TreeMap判断 两个key 相等的标准：两个key通过compareTo()方法或者compare()方法返回0。
</code></pre>
</li>
<li><pre><code> `Hashtable`：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value，Hashtable 实现原理、功能和 HashMap 相同。
</code></pre>
</li>
</ul>
<h3 id="（4）Collections-工具类"><a href="#（4）Collections-工具类" class="headerlink" title="（4）Collections 工具类"></a>（4）Collections 工具类</h3><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类，就像 Arrays 是操作数组的工具类一样。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法，常用方法如下：</p>
<ul>
<li><p><code>static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>：将所有指定元素添加到指定 collection 中。</p>
</li>
<li><p><code>static void shuffle(List&lt;?&gt; list) </code>：对 List 集合元素进行随机排序。</p>
</li>
<li><p><code>static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：根据元素的自然顺序对指定列表按升序进行排序。</p>
</li>
<li><p><code>static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>：根据指定比较器产生的顺序对指定列表进行排序。</p>
</li>
<li><p><code>static void swap(List&lt;?&gt; list,  int i, int j)</code> ：在指定列表的指定位置处交换元素</p>
</li>
<li><p><code>static void reverse(List&lt;?&gt; list)</code> ：反转指定列表中元素的顺序</p>
</li>
<li><p><code>static Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</p>
</li>
<li><p><code>static Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素。</p>
</li>
<li><p>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。使用<code>synchronizedList(List list）</code> 和 <code>synchronizedMap(Map map）</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="number">2</span>);</span><br><span class="line">        arrayList.add(<span class="number">3</span>);</span><br><span class="line">        arrayList.add(<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[2, 3, 1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转</span></span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 3, 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Collections.sort(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最大小值</span></span><br><span class="line">        System.out.println(Collections.max(arrayList));<span class="comment">//3</span></span><br><span class="line">        System.out.println(Collections.min(arrayList));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机排序</span></span><br><span class="line">        Collections.shuffle(arrayList);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        Collections.swap(arrayList,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[1, 3, 2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十一-泛型"><a href="#十一-泛型" class="headerlink" title="十一. 泛型"></a>十一. 泛型</h1><h2 id="1-泛型的概念"><a href="#1-泛型的概念" class="headerlink" title="1. 泛型的概念"></a>1. 泛型的概念</h2><blockquote>
<p>泛型，即“参数化类型”，把类型当作是参数一样传递。就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</p>
</blockquote>
<h2 id="2-泛型的好处"><a href="#2-泛型的好处" class="headerlink" title="2. 泛型的好处"></a>2. 泛型的好处</h2><ul>
<li>泛型将代码安全性检查提前到编译期（程序更加健壮）</li>
<li>泛型能够省去类型强制转换（代码更加简洁）</li>
<li>在编写的时候，就限定了类型（可读性和稳定性更好）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个集合，不使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//没有使用泛型，任何数据类型都可以存储，</span></span><br><span class="line">        arrayList.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) arrayList.get(i);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ① 此程序编译正常，运行时就会出现ClassCastException的异常。</span></span><br><span class="line"><span class="comment">// ② 获取数据元素时，需要类型强制转换。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义一个集合，使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//        arrayList.add(123); //编译报错</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line"><span class="comment">//            String str = (String) arrayList.get(i);</span></span><br><span class="line">            <span class="type">String</span>  <span class="variable">str</span> <span class="operator">=</span> arrayList.get(i); <span class="comment">// 不需要再强制类型转换</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-泛型的定义与使用"><a href="#3-泛型的定义与使用" class="headerlink" title="3. 泛型的定义与使用"></a>3. 泛型的定义与使用</h2><h3 id="（1）泛型类的定义与使用"><a href="#（1）泛型类的定义与使用" class="headerlink" title="（1）泛型类的定义与使用"></a>（1）泛型类的定义与使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于类的定义中，被称为泛型类，用户使用该类的时候，才把类型明确下来。</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 class 类名&lt;泛型类型变量&gt; &#123;  </span></span><br><span class="line"><span class="comment">		//代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 一些常用的泛型类型变量：</span></span><br><span class="line"><span class="comment">		E：元素（Element），多用于java集合框架</span></span><br><span class="line"><span class="comment">		K：关键字（Key）</span></span><br><span class="line"><span class="comment">		N：数字（Number）</span></span><br><span class="line"><span class="comment">		T：类型（Type）</span></span><br><span class="line"><span class="comment">		V：值（Value）</span></span><br><span class="line"><span class="comment">	② 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</span></span><br><span class="line"><span class="comment">	③ 泛型类的构造器如下：public GenericClass()&#123;&#125;。而public GenericClass&lt;E&gt;()&#123;&#125;是错误的。</span></span><br><span class="line"><span class="comment">	④ 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</span></span><br><span class="line"><span class="comment">	⑤ 泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理，但不等价于 Object。 </span></span><br><span class="line"><span class="comment">	⑥ &lt;数据类型&gt; 只能是引用类型</span></span><br><span class="line"><span class="comment">泛型类的实例化：</span></span><br><span class="line"><span class="comment">	类名&lt;数据类型&gt; 对象名 = new 类名&lt;&gt;(参数列表);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&lt;T&gt;  &#123;</span><br><span class="line">    <span class="keyword">private</span> T phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhoneNumber</span><span class="params">(T phoneNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Student&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;();</span><br><span class="line">        Student&lt;Long&gt; s2 = <span class="keyword">new</span> <span class="title class_">Student</span>&lt;&gt;();</span><br><span class="line">        s1.setPhoneNumber(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line"><span class="comment">//      s1.setPhoneNumber(123456789);// 编译报错，类型必须是String</span></span><br><span class="line">        s2.setPhoneNumber(<span class="number">987654321L</span>);</span><br><span class="line">        <span class="type">String</span>  <span class="variable">str1</span> <span class="operator">=</span> s1.getPhoneNumber();<span class="comment">// 不再需要强制类型转换</span></span><br><span class="line">        <span class="type">Long</span>  <span class="variable">str2</span> <span class="operator">=</span> s2.getPhoneNumber();<span class="comment">// 不再需要强制类型转换</span></span><br><span class="line">        System.out.println(str1);<span class="comment">// 123456789</span></span><br><span class="line">        System.out.println(str2);<span class="comment">// 987654321</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）泛型接口的定义与使用"><a href="#（2）泛型接口的定义与使用" class="headerlink" title="（2）泛型接口的定义与使用"></a>（2）泛型接口的定义与使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于接口的定义中，被称为泛型接口。</span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 interface 接口名&lt;泛型类型变量&gt;&#123;  </span></span><br><span class="line"><span class="comment">		//代码体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">实现泛型接口：</span></span><br><span class="line"><span class="comment">	方式一：定义类时确定泛型的类型</span></span><br><span class="line"><span class="comment">		修饰符 class 类名 implements 接口名&lt;具体数据类型&gt;&#123;</span></span><br><span class="line"><span class="comment">			//方法重写</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	方式二：定义类时不确定泛型的类型(直到创建对象时，才确定泛型的类型)</span></span><br><span class="line"><span class="comment">		修饰符 class 类名&lt;泛型类型变量&gt; implements 接口名&lt;泛型类型变量&gt;&#123;</span></span><br><span class="line"><span class="comment">			//方法重写</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 自定义泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">USB</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Equipment</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;的USB正在使用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Equipment</span> <span class="variable">equipment</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Equipment</span>();</span><br><span class="line">        equipment.use(<span class="string">&quot;电脑&quot;</span>);<span class="comment">// 电脑的USB正在使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）泛型方法的定义与使用"><a href="#（3）泛型方法的定义与使用" class="headerlink" title="（3）泛型方法的定义与使用"></a>（3）泛型方法的定义与使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*泛型类型用于方法的定义中，被称为泛型方法。</span></span><br><span class="line"><span class="comment">	泛型类，是在实例化类的时候指明泛型的具体类型；</span></span><br><span class="line"><span class="comment">	泛型方法，是在调用方法的时候指明泛型的具体类型 </span></span><br><span class="line"><span class="comment">定义格式：</span></span><br><span class="line"><span class="comment">	修饰符 &lt;泛型类型变量&gt; 返回值类型 方法名(参数) &#123;  </span></span><br><span class="line"><span class="comment">		//方法体;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//自定义泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;	<span class="comment">// 泛型方法</span></span><br><span class="line">        <span class="keyword">if</span>(t <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个String类型&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是一个Integer类型&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这既不是一个String类型，也不是一个Integer类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.show(<span class="string">&quot;张三&quot;</span>);<span class="comment">// 这是一个String类型</span></span><br><span class="line">        student.show(<span class="number">123</span>);<span class="comment">// 这是一个Integer类型</span></span><br><span class="line">        student.show(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]);<span class="comment">//这既不是一个String类型，也不是一个Integer类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4. 泛型通配符"></a>4. 泛型通配符</h2><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用 Object 类中的共性方法，集合中元素自身方法无法使用。</p>
<p>无界通配符：<code>类型名称 &lt;?&gt; 对象名称</code> （可以接收任何类型）</p>
<p>上界通配符：<code>类型名称 &lt;? extends 类 &gt; 对象名称</code> （只能接收该类型及其子类）</p>
<p>下界通配符： <code>类型名称 &lt;? super 类 &gt; 对象名称</code> （只能接收该类型及其父类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类</span></span><br><span class="line">        Collection&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collection&lt;Number&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">        Collection&lt;Object&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 测试无界通配符</span></span><br><span class="line">        getElement(list1);</span><br><span class="line">        getElement(list2);</span><br><span class="line">        getElement(list3);</span><br><span class="line">        getElement(list4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试上界通配符</span></span><br><span class="line">        getElement1(list1);</span><br><span class="line"><span class="comment">//      getElement1(list2);// 编译报错</span></span><br><span class="line">        getElement1(list3);</span><br><span class="line"><span class="comment">//      getElement1(list4);// 编译报错</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 测试下界通配符</span></span><br><span class="line"><span class="comment">//      getElement2(list1);// 编译报错</span></span><br><span class="line"><span class="comment">//      getElement2(list2);// 编译报错</span></span><br><span class="line">        getElement2(list3);</span><br><span class="line">        getElement2(list4);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无界通配符：任意都可以接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上界通配符：此时的泛型?，必须是Number类型或者Number类型的子类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement1</span><span class="params">(Collection&lt;? extends Number&gt; coll)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下界通配符：此时的泛型?，必须是Number类型或者Number类型的父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement2</span><span class="params">(Collection&lt;? <span class="built_in">super</span> Number&gt; coll)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二-IO-流"><a href="#十二-IO-流" class="headerlink" title="十二. IO 流"></a>十二. IO 流</h1><h2 id="1-File-类的使用"><a href="#1-File-类的使用" class="headerlink" title="1. File 类的使用"></a>1. File 类的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的File实例。  </span></span><br><span class="line"><span class="comment">	public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的File实例。</span></span><br><span class="line"><span class="comment">	public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的File实例。。</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">	获取</span></span><br><span class="line"><span class="comment">		public String getAbsolutePath() ：返回此File的绝对路径名字符串。</span></span><br><span class="line"><span class="comment">		public String getPath() ：将此File转换为路径名字符串。 </span></span><br><span class="line"><span class="comment">		public String getName() ：返回由此File表示的文件或目录的名称。  </span></span><br><span class="line"><span class="comment">		public String getParent()：获取上层文件目录路径。若无，返回null。</span></span><br><span class="line"><span class="comment">		public long length() ：返回由此File表示的文件的长度。</span></span><br><span class="line"><span class="comment">	判断</span></span><br><span class="line"><span class="comment">		public boolean exists() ：此File表示的文件或目录是否实际存在。</span></span><br><span class="line"><span class="comment">		public boolean isDirectory() ：此File表示的是否为目录。</span></span><br><span class="line"><span class="comment">		public boolean isFile() ：此File表示的是否为文件。</span></span><br><span class="line"><span class="comment">	创建</span></span><br><span class="line"><span class="comment">		public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </span></span><br><span class="line"><span class="comment">		public boolean mkdir() ：创建由此File表示的目录。</span></span><br><span class="line"><span class="comment">		public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录（如果父目录不存在，一并创建）。</span></span><br><span class="line"><span class="comment">	删除</span></span><br><span class="line"><span class="comment">		public boolean delete() ：删除由此File表示的文件或目录。</span></span><br><span class="line"><span class="comment">    目录的遍历</span></span><br><span class="line"><span class="comment">		public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span></span><br><span class="line"><span class="comment">		public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。  </span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 一个File对象代表硬盘中实际存在的一个文件或者目录。无论该路径下是否存在文件或者目录，都不影响File对象的创建。</span></span><br><span class="line"><span class="comment">	② File类中涉及到关于文件或文件目录的创建、删除、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</span></span><br><span class="line"><span class="comment">	③ 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的&quot;终点&quot;。</span></span><br><span class="line"><span class="comment">	④ 路径的分类：</span></span><br><span class="line"><span class="comment">		相对路径：相较于某个路径下，指明的路径。（如果用IDEA开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下，如果使用main()测试，相对路径即为当前的Project下）。</span></span><br><span class="line"><span class="comment">		绝对路径：包含盘符在内的文件或文件目录的路径</span></span><br><span class="line"><span class="comment">	⑤ 对于delete方法，如果此File表示目录，则目录必须为空才能删除，且java的删除不走回收站。</span></span><br><span class="line"><span class="comment">	⑥ 路径分隔符</span></span><br><span class="line"><span class="comment">		windows和DOS系统默认使用“\”来表示</span></span><br><span class="line"><span class="comment">		UNIX和URL使用“/”来表示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line">        System.out.println(file.getName());  <span class="comment">// Hello.txt</span></span><br><span class="line">        System.out.println(file.getParent()); <span class="comment">// D:\IO</span></span><br><span class="line">        System.out.println(file.getAbsolutePath()); <span class="comment">// D:\IO\Hello.txt</span></span><br><span class="line">        System.out.println(file.length()); <span class="comment">// 0,文件是空的，所以长度为0</span></span><br><span class="line"></span><br><span class="line">        System.out.println(file.exists()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(file.isDirectory());<span class="comment">// false</span></span><br><span class="line">        System.out.println(file.isFile());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line">            System.out.println(newFile);<span class="comment">// false，因为文件已经存在</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> file.delete();</span><br><span class="line">        System.out.println(delete);<span class="comment">// true</span></span><br><span class="line">        </span><br><span class="line">                <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹的名称(如果目录下没文件和文件夹，则会报NullPointerException异常)</span></span><br><span class="line">        String[] list = file1.list();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = file1.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-IO-概述"><a href="#2-IO-概述" class="headerlink" title="2. IO 概述"></a>2. IO 概述</h2><h3 id="（1）基本概念-1"><a href="#（1）基本概念-1" class="headerlink" title="（1）基本概念"></a>（1）基本概念</h3><blockquote>
<p>I&#x2F;O 是 Input&#x2F;Output 的缩写， I&#x2F;O 技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。Java程序中，对于数据的输入&#x2F;输出操作以 “流(stream)” ” 的方式进行。</p>
<p>流代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象。</p>
</blockquote>
<h3 id="（2）流的分类"><a href="#（2）流的分类" class="headerlink" title="（2）流的分类"></a>（2）流的分类</h3><ul>
<li><p>按数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。</p>
<ul>
<li><p><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </p>
</li>
<li><p><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</p>
</li>
</ul>
</li>
<li><p>按处理数据单位不同分为：<strong>字节流</strong>和<strong>字符流</strong>。</p>
<ul>
<li><p><strong>字节流</strong> ：以字节为单位，读写数据的流（用于操作图片、视频等非文本文件，建议不要操作文本文件，可能会乱码）。</p>
</li>
<li><p><strong>字符流</strong> ：以字符为单位，读写数据的流（只能操作文本文件，不能操作图片，视频等非文本文件。）。</p>
</li>
</ul>
</li>
<li><p>按功能不同分为：<strong>节点流</strong>、<strong>处理流</strong></p>
<ul>
<li><p><strong>节点流</strong>：以从或向一个特定的地方（节点）读写数据。如 FileInputStream</p>
</li>
<li><p><strong>处理流</strong>：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。<u>处理流的构造方法总是要带一个其他的流对象做参数</u>。一个流对象经过其他流的多次包装。</p>
</li>
</ul>
</li>
</ul>
<p>所有的流都继承下面四个抽象基类，且子类名称是以其父类名作为子类名后缀。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">InputStream</td>
<td align="center">OutputStream</td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">Reader</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<p>IO流体系</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">字节输入流</th>
<th align="center">字节输出流</th>
<th align="center">字符输入流</th>
<th align="center">字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td align="center"><strong><code>InputStream</code></strong></td>
<td align="center"><strong><code>OutputStream</code></strong></td>
<td align="center"><strong><code>Reader</code></strong></td>
<td align="center"><strong><code>Writer</code></strong></td>
</tr>
<tr>
<td>访问文件</td>
<td align="center"><strong><code>FileInputStream</code></strong></td>
<td align="center"><strong><code>FileOutputStream</code></strong></td>
<td align="center"><strong><code>FileReader</code></strong></td>
<td align="center"><strong><code>FileWriter</code></strong></td>
</tr>
<tr>
<td>访问数组</td>
<td align="center">ByteArrayInputStream</td>
<td align="center">ByteArrayOutputStream</td>
<td align="center">CharArrayReader</td>
<td align="center">CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td align="center">PipedInputStream</td>
<td align="center">PipedOutputStream</td>
<td align="center">PipedReader</td>
<td align="center">PipedWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td align="center"><strong><code>BufferedInputStream</code></strong></td>
<td align="center"><strong><code>BufferedOutputStream</code></strong></td>
<td align="center"><strong><code>BufferedReader</code></strong></td>
<td align="center"><strong><code>BufferedWriter</code></strong></td>
</tr>
<tr>
<td>转换流</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"><strong><code>InputStreamReader</code></strong></td>
<td align="center"><strong><code>InputStreamWriter</code></strong></td>
</tr>
<tr>
<td>对象流</td>
<td align="center"><strong><code>ObjectInputStream</code></strong></td>
<td align="center"><strong><code>ObjectOutputStream</code></strong></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td></td>
<td align="center">FilterInputStream</td>
<td align="center">FilterOutputStream</td>
<td align="center">FilterReader</td>
<td align="center">FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td align="center"></td>
<td align="center">PrintStream</td>
<td align="center"></td>
<td align="center">PrintWriter</td>
</tr>
<tr>
<td>特殊流</td>
<td align="center">DataInputStream</td>
<td align="center">DataOutputStream</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="3-抽象基类"><a href="#3-抽象基类" class="headerlink" title="3. 抽象基类"></a>3. 抽象基类</h2><h3 id="（1）InputStream"><a href="#（1）InputStream" class="headerlink" title="（1）InputStream"></a>（1）InputStream</h3><p>java.io.InputStream 类是字节输入流所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>void close() </code>：关闭此输入流并释放与此流相关联的任何系统资源。(<strong>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应显式关闭文件 IO 资源</strong>。)  </li>
<li><code>abstract int read()</code> ：从输入流读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</li>
<li><code>int read(byte[] b)</code>：从输入流中读取最多 b.length 一些字节数，<u>并将它们存储到字节数组 b 中</u>。如果<u>因为已经到达流末尾而没有可用的字节，则返回值 -1</u>。否则以整数形式返回实际读取的字节数。</li>
<li><code>int read(byte[] b, int off, int len)</code>：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。<u>如果因为流位于文件末尾而没有可用的字节，则返回值 -1</u></li>
</ul>
<h3 id="（2）OutputStream"><a href="#（2）OutputStream" class="headerlink" title="（2）OutputStream"></a>（2）OutputStream</h3><p>java.io.OutputStream 类是字节输出流所有类的超类，将指定字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li>
<li><code>void flush() </code>：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>void write(byte[] b) </code>：将 b.length 字节从指定的字节数组写入此输出流。 </li>
<li><code>void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len 字节，从偏移量 off 开始输出到此输出流。  </li>
<li><code>abstract void write(int b) </code>：将指定的字节写入此输出流。</li>
</ul>
<h3 id="（3）Reader"><a href="#（3）Reader" class="headerlink" title="（3）Reader"></a>（3）Reader</h3><p>java.io.Reader 类是用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>int read() </code>： 从输入流读取一个字符，自动提升为int类型。 范围在 0 到 65535 之间 ，如果已到达流的末尾，则返回 -1</li>
<li><code>int read(char[] cbuf)</code> ： 将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li>
<li><code>int read(char[] cbuf,int off,int len)</code> : 将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</li>
</ul>
<h3 id="（4）Writer"><a href="#（4）Writer" class="headerlink" title="（4）Writer"></a>（4）Writer</h3><p>java.io.Writer 类是用于写出字符流的所有类的超类，将指定字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> : 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>: 写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>: 写入字符数组的某一部分，off为开始索引，len为字符个数。 入len个字符部分到文件写入器， 从偏移量 off 的位置读取字符数组。</li>
<li><code>void write(String str) </code> : 写入字符串。 </li>
<li><code>void write(String str, int off, int len) </code>:  写入字符串的某一部分，off字符串的开始索引，len写的字符个数。</li>
<li><code>void flush() </code> : 刷新该流的缓冲。  </li>
<li><code>void close()</code> : 关闭此流，但要先刷新它。</li>
</ul>
<h2 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4. 文件流"></a>4. 文件流</h2><h3 id="（1）FileReader类"><a href="#（1）FileReader类" class="headerlink" title="（1）FileReader类"></a>（1）FileReader类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。   </span></span><br><span class="line"><span class="comment">	FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的名称（底层会调用上面一个构造方法）。</span></span><br><span class="line"><span class="comment">读取文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将已存在的一个文件加载进流。</span></span><br><span class="line"><span class="comment">	② 读入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 在读取文件时，必须保证该文件已存在，否则报异常。</span></span><br><span class="line"><span class="comment">	② 为了能够确定的关闭流，应该使用try-catch-finally处理异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//将一个文件的内容输出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);<span class="comment">// 文本内容为HelloWorld！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读入操作</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fileReader.read(chars)) !=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,len)); <span class="comment">// HelloWorld！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流资源</span></span><br><span class="line">        fileReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）FileWriter类"><a href="#（2）FileWriter类" class="headerlink" title="（2）FileWriter类"></a>（2）FileWriter类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。   </span></span><br><span class="line"><span class="comment">	FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。</span></span><br><span class="line"><span class="comment">	FileWriter(String fileName,true)： 创建一个新的 FileWriter，给定要读取的文件的名称。</span></span><br><span class="line"><span class="comment">写入文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将一个文件加载进流（文件可以存在，也可以不存在）。</span></span><br><span class="line"><span class="comment">	② 写入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 如果不关闭流资源,数据只是保存到缓冲区，并未保存到文件。</span></span><br><span class="line"><span class="comment">	② 因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush方法了。</span></span><br><span class="line"><span class="comment">		flush ：刷新缓冲区，流对象可以继续使用。</span></span><br><span class="line"><span class="comment">		close ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</span></span><br><span class="line"><span class="comment">	③ 在写入一个文件时，如果使用构造器FileWriter(file,false) / FileWriter(file)，则目录下有同名文件将被覆盖。</span></span><br><span class="line"><span class="comment">	④ 如果使用构造器FileWriter(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将abcdefghijklmnopqrstuvwxyz追加到Hello.txt文件末尾，注意不是覆盖。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.写入操作</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;abcdefghijklm&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;nopqrstuvwxyz&quot;</span>);<span class="comment">// 继续写</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流资源</span></span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本文件的复制，将Hello.txt文件复制一份为Hello1.txt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建流对象</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcfile);</span><br><span class="line">            fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destfile);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 2.读出写入操作</span></span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, len);</span><br><span class="line">                fileWriter.write(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.关闭流资源</span></span><br><span class="line">            <span class="keyword">if</span> (fileReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileWriter != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileWriter.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）FileInputStream类"><a href="#（3）FileInputStream类" class="headerlink" title="（3）FileInputStream类"></a>（3）FileInputStream类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileInputStream 类是文件输入流，从文件中读取字节。</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	FileInputStream(File file)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象file命名。 </span></span><br><span class="line"><span class="comment">	FileInputStream(String name)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。</span></span><br><span class="line"><span class="comment">读取文件步骤</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将已存在的一个文件加载进流。</span></span><br><span class="line"><span class="comment">	② 读入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）FileOutputStream类"><a href="#（4）FileOutputStream类" class="headerlink" title="（4）FileOutputStream类"></a>（4）FileOutputStream类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。 </span></span><br><span class="line"><span class="comment">	public FileOutputStream(String name) ：创建文件输出流以指定的名称写入文件。</span></span><br><span class="line"><span class="comment">写入文件步骤：</span></span><br><span class="line"><span class="comment">	① 建立一个流对象，将一个文件加载进流（文件可以存在，也可以不存在）。</span></span><br><span class="line"><span class="comment">	② 写入操作</span></span><br><span class="line"><span class="comment">	③ 关闭资源。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 流的关闭原则：先开后关，后开先关。</span></span><br><span class="line"><span class="comment">	② 在写入一个文件时，如果使用构造器FileOutputStream(file)，则目录下有同名文件将被覆盖。</span></span><br><span class="line"><span class="comment">	③ 如果使用构造器FileOutputStream(file,true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 非文本文件的复制。将Test.jpg图片复制一份为Test1.jpg</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.创建流对象</span></span><br><span class="line">            fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile);</span><br><span class="line">            fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.读出写入操作</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fileOutputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3.关闭流资源</span></span><br><span class="line">            <span class="keyword">if</span> (fileInputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileInputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileOutputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileOutputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5. 缓冲流"></a>5. 缓冲流</h2><p>使用缓冲流的好处是，能够高效的读写信息，原理是<strong>在创建流对象时，会创建一个内置的默认大小（8Kb）的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</li>
<li><input checked="" disabled="" type="checkbox"> 当使用 BufferedInputStream 读取字节文件时，BufferedInputStream 会一次性从文件中读取 8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个 8192 个字节数组。</li>
<li><input checked="" disabled="" type="checkbox"> 向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream 才会把缓冲区中的数据一次性写到文件里。使用方法 flush() 可以强制将缓冲区的内容全部写入输出流。</li>
<li><input checked="" disabled="" type="checkbox"> 关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。</li>
<li><input checked="" disabled="" type="checkbox"> flush() 方法的使用：手动将buffer中内容写入文件。</li>
<li><input checked="" disabled="" type="checkbox"> 如果是带缓冲区的流对象的 close() 方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</li>
</ul>
<h3 id="（1）字节缓冲流"><a href="#（1）字节缓冲流" class="headerlink" title="（1）字节缓冲流"></a>（1）字节缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字节缓冲流：BufferedInputStream，BufferedOutputStream </span></span><br><span class="line"><span class="comment">构造方法:</span></span><br><span class="line"><span class="comment">	public BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流。 </span></span><br><span class="line"><span class="comment">	public BufferedOutputStream(OutputStream out)：创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 非文本文件的复制。将Test.mkv视频（1.15G）复制一份</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 方式一：使用文件流进行大文件的复制</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.mkv&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test1.mkv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.造流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile1);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.复制操作</span></span><br><span class="line">        <span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = fileInputStream1.read(bytes1))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fileOutputStream1.write(bytes1,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        fileInputStream1.close();</span><br><span class="line">        fileOutputStream1.close();</span><br><span class="line">        <span class="type">long</span> <span class="variable">end1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end1 - start1);<span class="comment">//5404</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：使用缓冲流进行大文件的复制</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcfile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.mkv&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destfile2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test2.mkv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.造流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcfile2);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destfile2);</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream2);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.复制操作</span></span><br><span class="line">        <span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span>((len2 = bufferedInputStream.read(bytes2))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(bytes2,<span class="number">0</span>,len2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">end2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end2 - start2);<span class="comment">// 1390，可见缓冲流的效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）字符缓冲流"><a href="#（2）字符缓冲流" class="headerlink" title="（2）字符缓冲流"></a>（2）字符缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符缓冲流：BufferedReader，BufferedWriter</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public BufferedReader(Reader in) ：创建一个新的缓冲输入流。 </span></span><br><span class="line"><span class="comment">	public BufferedWriter(Writer out)：创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="comment">特有方法：</span></span><br><span class="line"><span class="comment">	★ BufferedReader：public String readLine(): 读一行文字，包含该行内容的字符串，不包含任何行终止符，如果已到达流末		尾，则返回null </span></span><br><span class="line"><span class="comment">	★ BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="6-转换流"><a href="#6-转换流" class="headerlink" title="6. 转换流"></a>6. 转换流</h2><p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为<strong>编码</strong> 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong> 。比如说，按照 A 规则存储，同样按照 A 规则解析，那么就能显示正确的文本符号。反之，按照 A 规则存储，再按照 B 规则解析，就会导致乱码现象。</p>
<p>编码：字符(能看懂的)–字节(看不懂的)</p>
<p>解码：字节(看不懂的)–&gt;字符(能看懂的)</p>
<ul>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流：<ul>
<li>InputStreamReader ：将InputStream 转换为Reader（字节到字符的桥梁）</li>
<li>OutputStreamWriter ：将Writer 转换为OutputStream（字符到字节的桥梁）</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效。</li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</li>
</ul>
<h3 id="（1）InputStreamReader-类"><a href="#（1）InputStreamReader-类" class="headerlink" title="（1）InputStreamReader 类"></a>（1）InputStreamReader 类</h3><p>转换流<code>java.io.InputStreamReader</code>，是 Reader 的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p>
<p>在 IDEA 中，使用<code>FileReader</code> 读取项目中的文本文件。由于 IDEA 的设置，都是默认的<code>UTF-8</code>编码，所以没有任何问题。但是，当读取 Windows 系统中创建的文本文件时，由于 Windows 系统的默认是 GBK 编码，就会出现乱码。可以通过转换流读取 GBK 编码文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </span></span><br><span class="line"><span class="comment">	InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 读取一个GBK编码文件，输出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 方式一：用FileReader类读一个GBK编码文件（会出现乱码问题）</span></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.读操作</span></span><br><span class="line">        <span class="type">char</span>[] chars1 = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = fileReader.read(chars1)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars1,<span class="number">0</span>,len1));<span class="comment">//����һ��GBK�����ļ���</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        fileReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：用InputStreamReader类读取一个GBK编码文件</span></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>)), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.读操作</span></span><br><span class="line">        <span class="type">char</span>[] chars2 = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len2;</span><br><span class="line">        <span class="keyword">while</span>((len2 = inputStreamReader.read(chars2)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars2,<span class="number">0</span>,len2));<span class="comment">//这是一个GBK编码文件！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）OutputStreamWriter-类"><a href="#（2）OutputStreamWriter-类" class="headerlink" title="（2）OutputStreamWriter 类"></a>（2）OutputStreamWriter 类</h3><p>转换流<code>java.io.OutputStreamWriter</code> ，是 Writer 的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </span></span><br><span class="line"><span class="comment">	OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将一个GBK编码文件复制一份为UTF-8编码文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO.txt&quot;</span>));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\IO1.txt&quot;</span>));</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fileOutputStream,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.读写操作</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = inputStreamReader.read(chars)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            outputStreamWriter.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭流</span></span><br><span class="line">        inputStreamReader.close();</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-对象流（序列化流）"><a href="#7-对象流（序列化流）" class="headerlink" title="7. 对象流（序列化流）"></a>7. 对象流（序列化流）</h2><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</p>
<p>ObjectOutputStream：内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程</p>
<p>ObjectInputStream：存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</p>
<p>对象的序列化机制：</p>
<blockquote>
<p>对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</p>
</blockquote>
<h3 id="（1）ObjectOutputStream-类"><a href="#（1）ObjectOutputStream-类" class="headerlink" title="（1）ObjectOutputStream 类"></a>（1）ObjectOutputStream 类</h3><p><code>java.io.ObjectOutputStream </code> 类，将 Java 对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public ObjectOutputStream(OutputStream out) ：创建一个指定OutputStream的ObjectOutputStream。</span></span><br><span class="line"><span class="comment">序列化操作</span></span><br><span class="line"><span class="comment">	一个对象要想序列化，必须满足下面条件:</span></span><br><span class="line"><span class="comment">	① 该类必须实现java.io.Serializable接口，Serializable是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException。</span></span><br><span class="line"><span class="comment">	② 当前类提供一个全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment">	③ 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰。</span></span><br><span class="line"><span class="comment">写出对象方法</span></span><br><span class="line"><span class="comment">	public final void writeObject (Object obj): 将指定的对象写出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将一个Student对象存储到Test.txt文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">684979447754667710L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.txt&quot;</span>));</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">// 2.写操作</span></span><br><span class="line">        objectOutputStream.writeObject(student);</span><br><span class="line">        <span class="comment">// 3.关闭流对象</span></span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）ObjectInputStream类"><a href="#（2）ObjectInputStream类" class="headerlink" title="（2）ObjectInputStream类"></a>（2）ObjectInputStream类</h3><p>ObjectInputStream 反序列化流，将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。</span></span><br><span class="line"><span class="comment">反序列化操作：</span></span><br><span class="line"><span class="comment">	如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：</span></span><br><span class="line"><span class="comment">	public final Object readObject () : 读取一个对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将Test.txt文件中的数据读出到控制台上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\Test.txt&quot;</span>));</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="comment">// 2.写操作</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(o); <span class="comment">//Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line">        <span class="comment">// 3.关闭流对象</span></span><br><span class="line">        objectInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十三-网络编程"><a href="#十三-网络编程" class="headerlink" title="十三. 网络编程"></a>十三. 网络编程</h1><h2 id="1-IP-地址和端口号"><a href="#1-IP-地址和端口号" class="headerlink" title="1. IP 地址和端口号"></a>1. IP 地址和端口号</h2><h3 id="（1）IP-地址"><a href="#（1）IP-地址" class="headerlink" title="（1）IP 地址"></a>（1）IP 地址</h3><blockquote>
<p><strong>IP地址：指互联网协议地址（Internet Protocol Address）</strong>，俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。</p>
</blockquote>
<p><u>IP 地址分类</u></p>
<ul>
<li><p>IPv4：是一个 32 位的二进制数，通常被分为 4 个字节，表示成<code>a.b.c.d</code> 的形式，例如<code>192.168.65.100</code> 。其中 a、b、c、d 都是 0~255 之间的十进制整数，那么最多可以表示 42 亿个。</p>
</li>
<li><p>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配越发紧张。</p>
<p>为了扩大地址空间，拟通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一组，分成 8 组十六进制数，表示成<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code>，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。</p>
</li>
</ul>
<p><u>特殊的 IP 地址</u></p>
<ul>
<li>本机IP地址：<code>127.0.0.1</code>、<code>localhost</code> 。</li>
</ul>
<h3 id="（2）端口号"><a href="#（2）端口号" class="headerlink" title="（2）端口号"></a>（2）端口号</h3><p>网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？</p>
<p>如果说 <strong>IP 地址</strong>可以唯一标识网络中的设备，那么<strong>端口号</strong>就可以唯一标识设备中的进程（应用程序）了。 端口与 号与IP 地址的组合得出一个网络套接字：Socket。</p>
<blockquote>
<p>端口号标识正在计算机上运行的进程（程序），用两个字节表示的整数，它的取值范围是 0~65535。</p>
</blockquote>
<p><u>端口分类</u>：</p>
<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP 占用端口 80，FTP 占用端口 21，Telnet 占用端口23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat 占用端口 8080，MySQL 占用端口 3306）</li>
<li>动态&#x2F; 私有端口：49152~65535。</li>
</ul>
<h3 id="（3）InetAddress-类"><a href="#（3）InetAddress-类" class="headerlink" title="（3）InetAddress 类"></a>（3）InetAddress 类</h3><p>InetAddress 类：此类的一个对象就代表着一个具体的 IP 地址，拥有两个子类：Inet4Address、Inet6Address。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取 InetAddress 实例</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getLocalHost</span><span class="params">()</span><span class="comment">// 返回本地主机。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> InetAddress <span class="title function_">getByName</span><span class="params">(String host)</span><span class="comment">// 在给定主机名的情况下确定主机的 IP 地址。</span></span><br><span class="line"><span class="comment">// InetAddress类提供了如下几个常用的方法</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getHostAddress</span><span class="params">()</span> ：返回IP地址字符串（以文本表现形式）。</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getHostName</span><span class="params">()</span> ：获取此IP地址的主机名</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReachable</span><span class="params">(<span class="type">int</span> timeout)</span>： 测试是否可以达到该地址</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// 返回IP地址字符串（以文本表现形式）</span></span><br><span class="line">        System.out.println(localHost.getHostAddress());</span><br><span class="line">        <span class="comment">// 获取此IP地址的主机名</span></span><br><span class="line">        System.out.println(localHost.getHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2. 网络协议"></a>2. 网络协议</h2><h3 id="（1）TCP-协议和-UDP-协议"><a href="#（1）TCP-协议和-UDP-协议" class="headerlink" title="（1）TCP 协议和 UDP 协议"></a>（1）TCP 协议和 UDP 协议</h3><p><code>java.net</code> 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><p><strong>UDP</strong>：用户数据报协议 (User Datagram Protocol)。UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</p>
<p>由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</p>
<p>但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用 UDP 协议。</p>
<p>特点:</p>
<ul>
<li>数据被限制在 64kb 以内，超出这个范围就不能发送了。</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
</ul>
</li>
<li><p><strong>TCP</strong>：传输控制协议 (Transmission Control Protocol)。TCP 协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在 TCP 连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<p>特点：</p>
<ul>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
<li>TCP 协议进行通信的两个应用进程：客户端、服务端。</li>
</ul>
</li>
</ul>
<h3 id="（2）TCP-通信"><a href="#（2）TCP-通信" class="headerlink" title="（2）TCP 通信"></a>（2）TCP 通信</h3><p>TCP 通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。</p>
<p>两端通信时步骤：</p>
<ol>
<li>服务端程序，需要事先启动，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。</li>
</ol>
<p>在Java中，提供了两个类用于实现TCP通信程序：</p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接</li>
</ol>
<h3 id="（3）Socket-类"><a href="#（3）Socket-类" class="headerlink" title="（3）Socket 类"></a>（3）Socket 类</h3><blockquote>
<p>Socket 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法</span></span><br><span class="line"><span class="comment">	public Socket(String host, int port)：创建套接字对象并将其连接到指定主机上的指定端口号。</span></span><br><span class="line"><span class="comment">	public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定IP地址的指定端口号</span></span><br><span class="line"><span class="comment">成员方法</span></span><br><span class="line"><span class="comment">	public InputStream getInputStream() ：返回此套接字的输入流。可以用于接收网络消息</span></span><br><span class="line"><span class="comment">	public OutputStream getOutputStream() ： 返回此套接字的输出流。可以用于发送网络消息</span></span><br><span class="line"><span class="comment">	public void close() ：关闭此套接字。一旦一个socket被关闭，它不可再使用。关闭此socket也将关闭相关的InputStream和	 OutputStream。 </span></span><br><span class="line"><span class="comment">	public void shutdownOutput() ： 禁用此套接字的输出流。任何先前写出的数据将被发送，随后终止输出流。</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	① 网络通信其实就是Socket间的通信。</span></span><br><span class="line"><span class="comment">	② Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）ServerSocket类"><a href="#（4）ServerSocket类" class="headerlink" title="（4）ServerSocket类"></a>（4）ServerSocket类</h3><blockquote>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造方法：</span></span><br><span class="line"><span class="comment">	public ServerSocket(int port) ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</span></span><br><span class="line"><span class="comment">成员方法：</span></span><br><span class="line"><span class="comment">	public Socket accept() ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）简单的TCP通信实例"><a href="#（5）简单的TCP通信实例" class="headerlink" title="（5）简单的TCP通信实例"></a>（5）简单的TCP通信实例</h3><p><u>客户端</u> Socket 的工作过程包含以下四个基本的步骤 ：</p>
<ul>
<li>创建 Socket ：根据指定服务端的 IP 地址或端口号构造 Socket 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到 Socket 的输入&#x2F; 出流： 使用 getInputStream()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输。</li>
<li>按照一定的协议对 Socket 进行读&#x2F; 写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程。</li>
<li>关闭 Socket：断开客户端到服务器的连接，释放线路</li>
</ul>
<p><u>服务器</u>程序的工作过程包含以下四个基本的步骤：</p>
<ul>
<li>调用 ServerSocket(int port) ： 创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 accept()： 监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li>
<li>调用该 Socket 类对象的 getOutputStream() 和 和 getInputStream ()： 获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭 ServerSocket 和 Socket 对象：客户端访问结束，关闭通信套接字。</li>
</ul>
<p>★<u> TCP 通信分析流程</u></p>
<ol>
<li><p>【服务端】启动,创建 ServerSocket 对象，等待连接。</p>
</li>
<li><p>【客户端】启动,创建 Socket 对象，请求连接。</p>
</li>
<li><p>【服务端】接收连接,调用 accept 方法，并返回一个 Socket 对象。</p>
</li>
<li><p>【客户端】Socket 对象，获取 OutputStream，向服务端写出数据。</p>
</li>
<li><p>【服务端】Scoket 对象，获取 InputStream，读取客户端发送的数据。</p>
</li>
<li><p>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</p>
</li>
<li><p>【客户端】Scoket对象，获取InputStream，解析回写数据。</p>
</li>
<li><p>【客户端】释放资源，断开连接。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 【服务端】启动,创建ServerSocket对象，等待连接。</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【服务端】接收连接,调用accept方法，并返回一个Socket对象。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));<span class="comment">//这是客户端向服务器发送的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//*************************************************************</span></span><br><span class="line">        <span class="comment">// 【服务端】Socket对象，获取OutputStream，向客户端回写数据。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;这是服务器回写的内容&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        accept.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 【客户端】启动,创建Socket对象，请求连接。</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【客户端】Socket对象，获取OutputStream，向服务端写出数据。</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;这是客户端向服务器发送的内容&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭数据的输出[如果不关闭输出，那么客户机收不到服务器发送的消息，因为服务器仍然继续等待客户机发送内容]</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//*************************************************************</span></span><br><span class="line">        <span class="comment">// 【客户端】Scoket对象，获取InputStream，解析回写数据。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,len));<span class="comment">//这是服务器回写的内容</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【客户端】释放资源，断开连接</span></span><br><span class="line">        socket.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十四-反射"><a href="#十四-反射" class="headerlink" title="十四. 反射"></a>十四. 反射</h1><blockquote>
<p>Java 的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p>
</blockquote>
<h2 id="1-Class-类的理解"><a href="#1-Class-类的理解" class="headerlink" title="1. Class 类的理解"></a>1. Class 类的理解</h2><p>类的加载过程：</p>
<p>程序经过 javac.exe 命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用 java.exe 命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为 Class 的一个实例。换句话说，Class 的实例就对应着一个运行时类。加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p>
<h2 id="2-获取反射中的-Class-对象"><a href="#2-获取反射中的-Class-对象" class="headerlink" title="2. 获取反射中的 Class 对象"></a>2. 获取反射中的 Class 对象</h2><p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<ul>
<li><p>方法一：<u>使用 Class.forName 静态方法</u>：若已知一个类的全路径名（包名.类名），可通过 Class 类的静态方法forName() 获取，可能抛出异常。例如：Class clz &#x3D; Class.forName(“java.lang.String”);</p>
<p>将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类。</p>
</li>
<li><p>方法二：<u>使用 .class 方法</u>。若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高。例如：Class clz &#x3D; String.class;</p>
<p>多用于参数的传递</p>
</li>
<li><p>方法三：<u>使用类对象的 getClass() 方法</u>。若已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象。<br>例如：String str &#x3D; new String(“Hello”); Class clz &#x3D; str.getClass();</p>
<p>getClass() 方法在 Object 类中定义着。多用于对象的获取字节码的方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 方法一：使用 Class.forName 静态方法。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;reflectiontest.Student&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法二：使用.class方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 方法三：使用类对象的 getClass()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> student.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建运行时类的对象"><a href="#3-创建运行时类的对象" class="headerlink" title="3. 创建运行时类的对象"></a>3. 创建运行时类的对象</h2><p>通过反射创建类对象主要有两种方法：</p>
<ul>
<li><p>方法一：<u>通过 Class 对象的 newInstance() 方法。</u>内部调用了运行时类的空参的构造器。要求：<br>① 运行时类必须提供空参的构造器<br>② 空参的构造器的访问权限得够。通常，设置为 public。</p>
</li>
<li><p>方法二：<u>通过 Constructor 对象的 newInstance() 方法。</u>通过 Constructor 对象创建类对象可以选择特定构造方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法一：通过 Class 对象的 newInstance() 方法。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        System.out.println(o);<span class="comment">// Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法二：通过 Constructor 对象的 newInstance() 方法</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor1</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> declaredConstructor1.newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> declaredConstructor2.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// Student&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line">        System.out.println(o2);<span class="comment">// Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-获取类属性、方法、构造器"><a href="#4-获取类属性、方法、构造器" class="headerlink" title="4. 获取类属性、方法、构造器"></a>4. 获取类属性、方法、构造器</h2><h3 id="（1）获取类属性"><a href="#（1）获取类属性" class="headerlink" title="（1）获取类属性"></a>（1）获取类属性</h3><ul>
<li><p><u>获取类的全部属性</u></p>
<p>使用 Class 对象的 <code>public Field[] getFields() </code>方法可以获取 Class 类的所有 public 属性，无法获取私有属性。</p>
<p>使用 Class 对象的 <code>public Field[] getDeclaredFields() </code>方法则可以获取包括私有属性在内的所有属性。</p>
</li>
<li><p><u>获取类的指定属性</u></p>
<p><code>public Field getField(String name)</code> 返回此 Class 对象表示的类或接口的指定的 public 的 Field。</p>
<p><code>public Field getDeclaredField(String name)</code> 返回此 Class 对象表示的类或接口的指定的 Field。</p>
<p>在反射机制中，可以直接通过 Field 类操作类中的属性，通过 Field 类提供的 set() 和 get() 方法就可以完成设置和取得属性内容的操作。<br><code>public Object get (Object obj)</code>  取得指定对象 obj 上此 Field 的属性内容<br><code>public void set (Object obj,Object value)</code>  设置指定对象 obj 上此 Field 的属性内容。</p>
<p>★注意：</p>
<p>对于私有属性，使用 get，set 时，先使用 <code>Filed对象.setAccessible(true)</code>; 以保证当前属性是可访问的，如果不设置，则不能访问私有属性。</p>
<ul>
<li>Method 和 Field、Constructor 对象都有 setAccessible() 方法。</li>
<li>setAccessible 启动和禁用访问安全检查的开关。</li>
<li>参数值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查。</li>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true。使得原本无法访问的私有成员也可以访问</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有属性&quot;</span>);</span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f :fields)&#123;</span><br><span class="line">            System.out.println(f);<span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部属性&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:declaredFields)&#123;</span><br><span class="line">            System.out.println(f);<span class="comment">// private java.lang.String reflectiontest.Student.name </span></span><br><span class="line">            					  <span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有属性&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(age);<span class="comment">// public int reflectiontest.Student.age</span></span><br><span class="line">        age.set(student,<span class="number">18</span>);</span><br><span class="line">        System.out.println(age.get(student));<span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意属性&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);<span class="comment">// private java.lang.String reflectiontest.Student.name</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);<span class="comment">// 暴力反射，保证当前属性是可访问的，如果不设置，则不能访问私有属性★</span></span><br><span class="line">        name.set(student,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(name.get(student));<span class="comment">// 张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（2）获取类方法"><a href="#（2）获取类方法" class="headerlink" title="（2）获取类方法"></a>（2）获取类方法</h3><ul>
<li><p><u>获取类的全部方法</u></p>
<p><code>public Method[] getDeclaredMethods()</code> 返回此 Class 对象所表示的类或接口的全部方法。</p>
<p><code>public Method[] getMethods()</code> 返回此 Class 对象所表示的类或接口的 public 的方法（包含其父类和父接口的 public 方法）。</p>
</li>
<li><p><u>获取类的指定方法</u></p>
<p>通过反射，调用类中的方法，通过 Method 类完成。步骤：</p>
<ul>
<li><p>使用<code>public Method getMethod(String name,Class…parameterTypes)</code> 返回此 Class 对象表示的类或接口的指定的 public 的 Method。参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</p>
<p>或使用<code>public Method getDeclaredMethod(String name,Class…parameterTypes)</code> 返回此 Class 对象表示的类或接口的指定的 Method。</p>
</li>
<li><p>之后使用 <code>Object invoke (Object obj, Object[] args) </code> 进行调用，并向方法中传递要设置的 obj对象的参数信息</p>
<p>说明：<br>① Object 对应原方法的返回值，若原方法无返回值，此时返回 null<br>② 若原方法若为静态方法，此时形参 Object obj 可为 null<br>③ 若原方法形参列表为空，则Object[] args为null<br>④ <u>若原方法声明为 private，则需要在调用此 invoke() 方法前，显式调用方法对象的 setAccessible(true)方法，才可访问。</u></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有方法&quot;</span>);</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部方法&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有方法&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">sleep</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(sleep);<span class="comment">// public void reflectiontest.Student.sleep()</span></span><br><span class="line">        sleep.invoke(student);<span class="comment">// 学生在睡觉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意方法&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">study</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;study&quot;</span>);</span><br><span class="line">        System.out.println(study);<span class="comment">// private void reflectiontest.Student.study()</span></span><br><span class="line">        study.setAccessible(<span class="literal">true</span>);<span class="comment">// 保证当前方法是可访问的，如果不设置，则不能访问私有方法★</span></span><br><span class="line">        study.invoke(student);<span class="comment">// 学生在学习</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="（3）获取类构造器"><a href="#（3）获取类构造器" class="headerlink" title="（3）获取类构造器"></a>（3）获取类构造器</h3><ul>
<li><p><u>获取类的全部构造器</u></p>
<p><code>public Constructor&lt;T&gt;[] getConstructors()</code> 返回此 Class 对象所表示的类的所有 public 构造方法。</p>
<p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code> 返回此 Class 对象表示的类声明的所有构造方法。</p>
</li>
<li><p><u>获取类的指定构造器</u></p>
<p><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>  返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。参数指明构造器的参数列表</p>
<p><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。</p>
</li>
<li><p>调用构造方法：</p>
<p>Constructor–&gt;newInstance(Object… initargs)</p>
<p>newInstance是 Constructor类的方法（管理构造函数的类）</p>
<p>api 的解释为：newInstance(Object… initargs) ，使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p>
<p>它的返回值是 T 类型，所以 newInstance 是创建了一个构造方法的声明类的新实例对象，并为之调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部公有构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部公有构造器&quot;</span>);</span><br><span class="line">        Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            System.out.println(c);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的全部构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的全部构造器&quot;</span>);</span><br><span class="line">        Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定公有构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定公有构造器&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor);<span class="comment">// public reflectiontest.Student(java.lang.String,int)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(o);<span class="comment">// Student&#123;name=&#x27;张三&#x27;, age=18&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的指定任意构造器</span></span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的指定任意构造器&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(declaredConstructor);<span class="comment">// public reflectiontest.Student(java.lang.String,int)</span></span><br><span class="line"><span class="comment">//        declaredConstructor.setAccessible(true);// 保证当前方法是可访问的，如果不设置，则不能访问私有构造器★</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> declaredConstructor.newInstance(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(o1);<span class="comment">// Student&#123;name=&#x27;李四&#x27;, age=20&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

    </div>

    
    
    
	<div>
	    
	    <div style="text-align:center;color:#ccc;font-size:20px;margin-top:30px">
		-------本 文 结 束 <i class="fa fa-paw"></i> 感 谢 您 的 阅 读-------
	    </div>
	    
	</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>SniperCoding
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://snipercoding.github.io/2022/02/16/Java%E5%9F%BA%E7%A1%80/" title="Java基础知识">https://snipercoding.github.io/2022/02/16/Java基础/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-Hans" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/10/Hexo+GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="prev" title="Hexo+GitHub搭建个人博客">
      <i class="fa fa-chevron-left"></i> Hexo+GitHub搭建个人博客
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/18/MySQL%E5%9F%BA%E7%A1%80/" rel="next" title="MySQL基础知识">
      MySQL基础知识 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-Java-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text">一. Java 开发环境</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-Java-%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83"><span class="nav-text">二. Java 语法规范</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">2. Java 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">3. Java 标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Java-%E7%BC%96%E7%A8%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">4. Java 编程的注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">三. Java 基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B3%A8%E9%87%8A"><span class="nav-text">1. 注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B8%B8%E9%87%8F"><span class="nav-text">3. 常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%98%E9%87%8F"><span class="nav-text">4. 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">5. 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">6. 流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">（1）顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-text">（2）选择结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">（3）循环结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%95%B0%E7%BB%84"><span class="nav-text">7. 数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-Java-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">四. Java 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. 类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">（1）基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（2）类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）对象的创建与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text">（4）成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text">（5）成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89static-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">（6）static 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%B0%81%E8%A3%85"><span class="nav-text">2. 封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88"><span class="nav-text">（1）高内聚低耦合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">（2）封装的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">（3）访问权限修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">（4）实现封装的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">（5）构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">（6）this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89%E6%A0%87%E5%87%86%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94JavaBean"><span class="nav-text">（7）标准代码——JavaBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">（8）代码块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BB%A7%E6%89%BF"><span class="nav-text">3. 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">（1）继承的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">（2）继承的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">（3）继承的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">（4）继承的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E9%87%8D%E5%86%99"><span class="nav-text">（5）重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">（6）super 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%A4%9A%E6%80%81"><span class="nav-text">4. 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">（1）多态的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-text">（2）多态的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）多态的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89instanceof-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">（4）instanceof 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">（5）引用类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">（6）final关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%8A%BD%E8%B1%A1"><span class="nav-text">5. 抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">（1）抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">（2）抽象方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%8E%A5%E5%8F%A3"><span class="nav-text">6. 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">7. 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">（1）成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">（2）局部内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">（3）匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">（4）静态内部类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-Java%E5%B8%B8%E7%94%A8API"><span class="nav-text">五. Java常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Object-%E7%B1%BB"><span class="nav-text">1. Object 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Scanner%E7%B1%BB"><span class="nav-text">2. Scanner类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Random%E7%B1%BB"><span class="nav-text">3. Random类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-String%E7%B1%BB"><span class="nav-text">4. String类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-StringBuffer%E3%80%81StringBuilder"><span class="nav-text">5. StringBuffer、StringBuilder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Arrays-%E7%B1%BB"><span class="nav-text">6. Arrays 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Math-%E7%B1%BB%EF%BC%88%E5%8C%85%E5%90%AB-BigDecimal%EF%BC%89"><span class="nav-text">7. Math 类（包含 BigDecimal）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-text">8. 包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="nav-text">9. 日期时间类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-java-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-text">10. java 比较器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E5%BC%82%E5%B8%B8"><span class="nav-text">六. 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 异常的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">2. 异常的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="nav-text">3. 常见异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">4. 异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89try%E2%80%A6catch%E2%80%A6finally"><span class="nav-text">（1）try…catch…finally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89throws"><span class="nav-text">（2）throws</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89throw"><span class="nav-text">（3）throw</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-text">5. 自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">七. 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-text">1. 程序、进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">2. 多线程的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">3. 线程的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-text">4. 线程的同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">5. 线程的通信</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB-%E6%9E%9A%E4%B8%BE"><span class="nav-text">八. 枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-text">1. 自定义枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-enum%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">2. enum关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D-%E6%B3%A8%E8%A7%A3"><span class="nav-text">九. 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-text">1. 自定义注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java-%E9%A2%84%E7%BD%AE%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="nav-text">2. Java 预置的注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-text">3. 元注解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81-%E9%9B%86%E5%90%88"><span class="nav-text">十. 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="nav-text">1. 集合概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Collection-%E6%8E%A5%E5%8F%A3"><span class="nav-text">2. Collection 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-List-%E6%8E%A5%E5%8F%A3"><span class="nav-text">3. List 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89List-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）List 接口概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89List-%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">（2）List 接口常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89List%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">（3）List接口实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Set-%E6%8E%A5%E5%8F%A3"><span class="nav-text">4. Set 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Set-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）Set 接口概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Set%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">（2）Set接口实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Map-%E6%8E%A5%E5%8F%A3"><span class="nav-text">5. Map 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Map-%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="nav-text">（1）Map 接口概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Map%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">（2）Map接口常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Map%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text">（3）Map接口实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">（4）Collections 工具类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E6%B3%9B%E5%9E%8B"><span class="nav-text">十一. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 泛型的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">2. 泛型的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">3. 泛型的定义与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">（1）泛型类的定义与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">（2）泛型接口的定义与使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-text">（3）泛型方法的定义与使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-text">4. 泛型通配符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-IO-%E6%B5%81"><span class="nav-text">十二. IO 流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-File-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">1. File 类的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-IO-%E6%A6%82%E8%BF%B0"><span class="nav-text">2. IO 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-text">（1）基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">（2）流的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="nav-text">3. 抽象基类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89InputStream"><span class="nav-text">（1）InputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89OutputStream"><span class="nav-text">（2）OutputStream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Reader"><span class="nav-text">（3）Reader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89Writer"><span class="nav-text">（4）Writer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-text">4. 文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89FileReader%E7%B1%BB"><span class="nav-text">（1）FileReader类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89FileWriter%E7%B1%BB"><span class="nav-text">（2）FileWriter类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89FileInputStream%E7%B1%BB"><span class="nav-text">（3）FileInputStream类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89FileOutputStream%E7%B1%BB"><span class="nav-text">（4）FileOutputStream类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-text">5. 缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-text">（1）字节缓冲流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-text">（2）字符缓冲流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-text">6. 转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89InputStreamReader-%E7%B1%BB"><span class="nav-text">（1）InputStreamReader 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89OutputStreamWriter-%E7%B1%BB"><span class="nav-text">（2）OutputStreamWriter 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%AF%B9%E8%B1%A1%E6%B5%81%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%EF%BC%89"><span class="nav-text">7. 对象流（序列化流）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ObjectOutputStream-%E7%B1%BB"><span class="nav-text">（1）ObjectOutputStream 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89ObjectInputStream%E7%B1%BB"><span class="nav-text">（2）ObjectInputStream类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">十三. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-text">1. IP 地址和端口号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89IP-%E5%9C%B0%E5%9D%80"><span class="nav-text">（1）IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-text">（2）端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89InetAddress-%E7%B1%BB"><span class="nav-text">（3）InetAddress 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="nav-text">2. 网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89TCP-%E5%8D%8F%E8%AE%AE%E5%92%8C-UDP-%E5%8D%8F%E8%AE%AE"><span class="nav-text">（1）TCP 协议和 UDP 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89TCP-%E9%80%9A%E4%BF%A1"><span class="nav-text">（2）TCP 通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Socket-%E7%B1%BB"><span class="nav-text">（3）Socket 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89ServerSocket%E7%B1%BB"><span class="nav-text">（4）ServerSocket类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E7%AE%80%E5%8D%95%E7%9A%84TCP%E9%80%9A%E4%BF%A1%E5%AE%9E%E4%BE%8B"><span class="nav-text">（5）简单的TCP通信实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B-%E5%8F%8D%E5%B0%84"><span class="nav-text">十四. 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Class-%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">1. Class 类的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84-Class-%E5%AF%B9%E8%B1%A1"><span class="nav-text">2. 获取反射中的 Class 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">3. 创建运行时类的对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%B1%9E%E6%80%A7%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">4. 获取类属性、方法、构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="nav-text">（1）获取类属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="nav-text">（2）获取类方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">（3）获取类构造器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SniperCoding"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SniperCoding</p>
  <div class="site-description" itemprop="description">请不要假装很努力，因为结果不会陪你演戏！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SniperCoding" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SniperCoding" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SniperCoding</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">135k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:03</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'uEQlOTKrhpXHePOJS3OgRs6i-gzGzoHsz',
      appKey     : 'eO4nhfbFpC6pbqpfrYlQ3zcl',
      placeholder: "撰写你的评论叭~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
    // �����������ݣ�ɾ��Powered By Valine
    var infoEle = document.querySelector('.vpower');
    if (infoEle){
        infoEle.parentNode.removeChild(infoEle);
    }
  });
});
</script>
</body>
</html>
